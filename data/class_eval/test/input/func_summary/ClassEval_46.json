{"qid": "ClassEval_46", "orig_input": "class Interpolation:\n    \"\"\"\n    This is a class that implements the Linear interpolation operation of one-dimensional and two-dimensional data\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def interpolate_1d(x, y, x_interp):\n        \"\"\"\n        Linear interpolation of one-dimensional data\n        :param x: The x-coordinate of the data point, list.\n        :param y: The y-coordinate of the data point, list.\n        :param x_interp: The x-coordinate of the interpolation point, list.\n        :return: The y-coordinate of the interpolation point, list.\n        >>> interpolation = Interpolation()\n        >>> interpolation.interpolate_1d([1, 2, 3], [1, 2, 3], [1.5, 2.5])\n        [1.5, 2.5]\n\n        \"\"\"\n\n    @staticmethod\n    def interpolate_2d(x, y, z, x_interp, y_interp):\n        \u201d\u201c\u201d\n        Linear interpolation of two-dimensional data\n        :param x: The x-coordinate of the data point, list.\n        :param y: The y-coordinate of the data point, list.\n        :param z: The z-coordinate of the data point, list.\n        :param x_interp: The x-coordinate of the interpolation point, list.\n        :param y_interp: The y-coordinate of the interpolation point, list.\n        :return: The z-coordinate of the interpolation point, list.\n        >>> interpolation = Interpolation()\n        >>> interpolation.interpolate_2d([1, 2, 3], [1, 2, 3], [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [1.5, 2.5], [1.5, 2.5])\n        [3.0, 7.0]\n\n        \u201d\u201c\u201d", "input": "class Interpolation:\n    \"\"\"\n    This is a class that implements the Linear interpolation operation of one-dimensional and two-dimensional data\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def interpolate_1d(x, y, x_interp):\n        \"\"\"Linear interpolation function for one-dimensional data, taking input points and returning interpolated values.\"\"\"\n\n    @staticmethod\n    def interpolate_2d(x, y, z, x_interp, y_interp):\n        \u201d\u201c\u201d\n        Linear interpolation of two-dimensional data\n        :param x: The x-coordinate of the data point, list.\n        :param y: The y-coordinate of the data point, list.\n        :param z: The z-coordinate of the data point, list.\n        :param x_interp: The x-coordinate of the interpolation point, list.\n        :param y_interp: The y-coordinate of the interpolation point, list.\n        :return: The z-coordinate of the interpolation point, list.\n        >>> interpolation = Interpolation()\n        >>> interpolation.interpolate_2d([1, 2, 3], [1, 2, 3], [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [1.5, 2.5], [1.5, 2.5])\n        [3.0, 7.0]\n\n        \u201d\u201c\u201d", "method_info": [{"method_name": "interpolate_1d", "method_description": "def interpolate_1d(x, y, x_interp):\n        \"\"\"\n        Linear interpolation of one-dimensional data\n        :param x: The x-coordinate of the data point, list.\n        :param y: The y-coordinate of the data point, list.\n        :param x_interp: The x-coordinate of the interpolation point, list.\n        :return: The y-coordinate of the interpolation point, list.\n        >>> interpolation = Interpolation()\n        >>> interpolation.interpolate_1d([1, 2, 3], [1, 2, 3], [1.5, 2.5])\n        [1.5, 2.5]\n\n        \"\"\"", "test_class": "InterpolationTestInterpolate1d", "test_code": "class InterpolationTestInterpolate1d(unittest.TestCase):\n    def test_interpolate_1d(self):\n        interpolation = Interpolation()\n        self.assertEqual(interpolation.interpolate_1d([1, 2, 3], [1, 2, 3], [1.5, 2.5]), [1.5, 2.5])\n\n    def test_interpolate_1d_2(self):\n        interpolation = Interpolation()\n        self.assertEqual(interpolation.interpolate_1d([1, 6, 4], [1, 2, 5], [1.5, 2.5]), [1.1, 1.3])\n\n    def test_interpolate_1d_3(self):\n        interpolation = Interpolation()\n        self.assertEqual(interpolation.interpolate_1d([1, 6, 4], [1, 7, 5], [1.5, 2.5]), [1.6, 2.8])\n\n    def test_interpolate_1d_4(self):\n        interpolation = Interpolation()\n        self.assertEqual(interpolation.interpolate_1d([1, 6, 4], [1, 2, 5], [2, 3]), [1.2, 1.4])\n\n    def test_interpolate_1d_5(self):\n        interpolation = Interpolation()\n        self.assertEqual(interpolation.interpolate_1d([1, 6, 4], [1, 7, 5], [2, 3]), [2.2, 3.4])\n\n    def test_interpolate_1d_6(self):\n        interpolation = Interpolation()\n        self.assertEqual(interpolation.interpolate_1d([1, 6, 4], [1, 7, 5], []), [])\n\n    def test_interpolate_1d_7(self):\n        interpolation = Interpolation()\n        self.assertEqual(interpolation.interpolate_1d([], [], [[], []]), [])", "solution_code": "def interpolate_1d(x, y, x_interp):\n        y_interp = []\n        for xi in x_interp:\n            for i in range(len(x) - 1):\n                if x[i] <= xi <= x[i+1]:\n                    yi = y[i] + (y[i+1] - y[i]) * (xi - x[i]) / (x[i+1] - x[i])\n                    y_interp.append(yi)\n                    break\n        return y_interp", "dependencies": {"Standalone": true, "lib_dependencies": [], "field_dependencies": [], "method_dependencies": []}}, {"method_name": "interpolate_2d", "method_description": "@staticmethod\n    def interpolate_2d(x, y, z, x_interp, y_interp):\n        \u201d\u201c\u201d\n        Linear interpolation of two-dimensional data\n        :param x: The x-coordinate of the data point, list.\n        :param y: The y-coordinate of the data point, list.\n        :param z: The z-coordinate of the data point, list.\n        :param x_interp: The x-coordinate of the interpolation point, list.\n        :param y_interp: The y-coordinate of the interpolation point, list.\n        :return: The z-coordinate of the interpolation point, list.\n        >>> interpolation = Interpolation()\n        >>> interpolation.interpolate_2d([1, 2, 3], [1, 2, 3], [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [1.5, 2.5], [1.5, 2.5])\n        [3.0, 7.0]\n\n        \u201d\u201c\u201d", "test_class": "InterpolationTestInterpolate2d", "test_code": "class InterpolationTestInterpolate2d(unittest.TestCase):\n    def test_interpolate_2d(self):\n        interpolation = Interpolation()\n        self.assertEqual(\n            interpolation.interpolate_2d([1, 2, 3], [1, 2, 3], [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [1.5, 2.5],\n                                         [1.5, 2.5]), [3.0, 7.0])\n\n    def test_interpolate_2d_2(self):\n        interpolation = Interpolation()\n        self.assertEqual(\n            interpolation.interpolate_2d([1, 2, 3], [1, 2, 3], [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [1.5, 2.5], [3, 4]),\n            [4.5])\n\n    def test_interpolate_2d_3(self):\n        interpolation = Interpolation()\n        self.assertEqual(\n            interpolation.interpolate_2d([1, 2, 3], [1, 2, 3], [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [3, 4], [1.5, 2.5]),\n            [7.5])\n\n    def test_interpolate_2d_4(self):\n        interpolation = Interpolation()\n        self.assertEqual(\n            interpolation.interpolate_2d([1, 2, 3], [1, 2, 3], [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [3, 4], [3, 4]),\n            [9.0])\n\n    def test_interpolate_2d_5(self):\n        interpolation = Interpolation()\n        self.assertEqual(\n            interpolation.interpolate_2d([1, 2, 3], [1, 2, 3], [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [1.5, 2.5],\n                                         [1.5, 2.5]), [3.0, 7.0])", "solution_code": "@staticmethod\n    def interpolate_2d(x, y, z, x_interp, y_interp):\n        z_interp = []\n        for xi, yi in zip(x_interp, y_interp):\n            for i in range(len(x) - 1):\n                if x[i] <= xi <= x[i+1]:\n                    for j in range(len(y) - 1):\n                        if y[j] <= yi <= y[j+1]:\n                            z00 = z[i][j]\n                            z01 = z[i][j+1]\n                            z10 = z[i+1][j]\n                            z11 = z[i+1][j+1]\n                            zi = (z00 * (x[i+1] - xi) * (y[j+1] - yi) +\n                                  z10 * (xi - x[i]) * (y[j+1] - yi) +\n                                  z01 * (x[i+1] - xi) * (yi - y[j]) +\n                                  z11 * (xi - x[i]) * (yi - y[j])) / ((x[i+1] - x[i]) * (y[j+1] - y[j]))\n                            z_interp.append(zi)\n                            break\n                    break\n        return z_interp", "dependencies": {"Standalone": true, "lib_dependencies": [], "field_dependencies": [], "method_dependencies": []}}], "test_cases": "import unittest\n\n\nclass InterpolationTestInterpolate1d(unittest.TestCase):\n    def test_interpolate_1d(self):\n        interpolation = Interpolation()\n        self.assertEqual(interpolation.interpolate_1d([1, 2, 3], [1, 2, 3], [1.5, 2.5]), [1.5, 2.5])\n\n    def test_interpolate_1d_2(self):\n        interpolation = Interpolation()\n        self.assertEqual(interpolation.interpolate_1d([1, 6, 4], [1, 2, 5], [1.5, 2.5]), [1.1, 1.3])\n\n    def test_interpolate_1d_3(self):\n        interpolation = Interpolation()\n        self.assertEqual(interpolation.interpolate_1d([1, 6, 4], [1, 7, 5], [1.5, 2.5]), [1.6, 2.8])\n\n    def test_interpolate_1d_4(self):\n        interpolation = Interpolation()\n        self.assertEqual(interpolation.interpolate_1d([1, 6, 4], [1, 2, 5], [2, 3]), [1.2, 1.4])\n\n    def test_interpolate_1d_5(self):\n        interpolation = Interpolation()\n        self.assertEqual(interpolation.interpolate_1d([1, 6, 4], [1, 7, 5], [2, 3]), [2.2, 3.4])\n\n    def test_interpolate_1d_6(self):\n        interpolation = Interpolation()\n        self.assertEqual(interpolation.interpolate_1d([1, 6, 4], [1, 7, 5], []), [])\n\n    def test_interpolate_1d_7(self):\n        interpolation = Interpolation()\n        self.assertEqual(interpolation.interpolate_1d([], [], [[], []]), [])\n\n\nclass InterpolationTestInterpolate2d(unittest.TestCase):\n    def test_interpolate_2d(self):\n        interpolation = Interpolation()\n        self.assertEqual(\n            interpolation.interpolate_2d([1, 2, 3], [1, 2, 3], [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [1.5, 2.5],\n                                         [1.5, 2.5]), [3.0, 7.0])\n\n    def test_interpolate_2d_2(self):\n        interpolation = Interpolation()\n        self.assertEqual(\n            interpolation.interpolate_2d([1, 2, 3], [1, 2, 3], [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [1.5, 2.5], [3, 4]),\n            [4.5])\n\n    def test_interpolate_2d_3(self):\n        interpolation = Interpolation()\n        self.assertEqual(\n            interpolation.interpolate_2d([1, 2, 3], [1, 2, 3], [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [3, 4], [1.5, 2.5]),\n            [7.5])\n\n    def test_interpolate_2d_4(self):\n        interpolation = Interpolation()\n        self.assertEqual(\n            interpolation.interpolate_2d([1, 2, 3], [1, 2, 3], [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [3, 4], [3, 4]),\n            [9.0])\n\n    def test_interpolate_2d_5(self):\n        interpolation = Interpolation()\n        self.assertEqual(\n            interpolation.interpolate_2d([1, 2, 3], [1, 2, 3], [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [1.5, 2.5],\n                                         [1.5, 2.5]), [3.0, 7.0])\n\n\nclass InterpolationTestMain(unittest.TestCase):\n    def test_main(self):\n        interpolation = Interpolation()\n        self.assertEqual(interpolation.interpolate_1d([1, 2, 3], [1, 2, 3], [1.5, 2.5]), [1.5, 2.5])\n        self.assertEqual(\n            interpolation.interpolate_2d([1, 2, 3], [1, 2, 3], [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [1.5, 2.5],\n                                         [1.5, 2.5]), [3.0, 7.0])", "solutions": ["class Interpolation:\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def interpolate_1d(x, y, x_interp):\n        y_interp = []\n        for xi in x_interp:\n            for i in range(len(x) - 1):\n                if x[i] <= xi <= x[i+1]:\n                    yi = y[i] + (y[i+1] - y[i]) * (xi - x[i]) / (x[i+1] - x[i])\n                    y_interp.append(yi)\n                    break\n        return y_interp\n    \n    @staticmethod\n    def interpolate_2d(x, y, z, x_interp, y_interp):\n        z_interp = []\n        for xi, yi in zip(x_interp, y_interp):\n            for i in range(len(x) - 1):\n                if x[i] <= xi <= x[i+1]:\n                    for j in range(len(y) - 1):\n                        if y[j] <= yi <= y[j+1]:\n                            z00 = z[i][j]\n                            z01 = z[i][j+1]\n                            z10 = z[i+1][j]\n                            z11 = z[i+1][j+1]\n                            zi = (z00 * (x[i+1] - xi) * (y[j+1] - yi) +\n                                  z10 * (xi - x[i]) * (y[j+1] - yi) +\n                                  z01 * (x[i+1] - xi) * (yi - y[j]) +\n                                  z11 * (xi - x[i]) * (yi - y[j])) / ((x[i+1] - x[i]) * (y[j+1] - y[j]))\n                            z_interp.append(zi)\n                            break\n                    break\n        return z_interp"], "task": "class_eval", "split": "test", "transformation_type": "func_summary", "import_statement": [], "test_classes": ["InterpolationTestInterpolate1d", "InterpolationTestInterpolate2d", "InterpolationTestMain"]}