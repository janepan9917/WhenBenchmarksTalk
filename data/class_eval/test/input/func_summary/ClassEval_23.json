{"qid": "ClassEval_23", "orig_input": "import math\nfrom typing import List\n\nclass CombinationCalculator:\n    \"\"\"\n    This is a class that provides methods to calculate the number of combinations for a specific count, calculate all possible combinations, and generate combinations with a specified number of elements.\n    \"\"\"\n\n    def __init__(self, datas: List[str]):\n        \"\"\"\n        Initialize the calculator with a list of data.\n        \"\"\"\n        self.datas = datas\n\n    @staticmethod\n    def count(n: int, m: int) -> int:\n        \"\"\"\n        Calculate the number of combinations for a specific count.\n        :param n: The total number of elements,int.\n        :param m: The number of elements in each combination,int.\n        :return: The number of combinations,int.\n        >>> CombinationCalculator.count(4, 2)\n        6\n        \"\"\"\n\n    @staticmethod\n    def count_all(n: int) -> int:\n        \"\"\"\n        Calculate the number of all possible combinations.\n        :param n: The total number of elements,int.\n        :return: The number of all possible combinations,int,if the number of combinations is greater than 2^63-1,return float(\"inf\").\n        >>> CombinationCalculator.count_all(4)\n        15\n        \"\"\"\n\n    def select(self, m: int) -> List[List[str]]:\n        \"\"\"\n        Generate combinations with a specified number of elements.\n        :param m: The number of elements in each combination,int.\n        :return: A list of combinations,List[List[str]].\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> calc.select(2)\n        [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']]\n\n        \"\"\"\n\n    def select_all(self) -> List[List[str]]:\n        \"\"\"\n        Generate all possible combinations of  selecting elements from the given data list,and it uses the select method.\n        :return: A list of combinations,List[List[str]].\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> calc.select_all()\n        [['A'], ['B'], ['C'], ['D'], ['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D'], ['A', 'B', 'C'], ['A', 'B', 'D'], ['A', 'C', 'D'], ['B', 'C', 'D'], ['A', 'B', 'C', 'D']]\n\n        \"\"\"\n\n    def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):\n        \"\"\"\n        Generate combinations with a specified number of elements by recursion.\n        :param dataIndex: The index of the data to be selected,int.\n        :param resultList: The list of elements in the combination,List[str].\n        :param resultIndex: The index of the element in the combination,int.\n        :param result: The list of combinations,List[List[str]].\n        :return: None.\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> result = []\n        >>> calc._select(0, [None] * 2, 0, result)\n        >>> result\n        [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']]\n\n        \"\"\"", "input": "import math\nfrom typing import List\n\nclass CombinationCalculator:\n    \"\"\"\n    This is a class that provides methods to calculate the number of combinations for a specific count, calculate all possible combinations, and generate combinations with a specified number of elements.\n    \"\"\"\n\n    def __init__(self, datas: List[str]):\n        \"\"\"\n        Initialize the calculator with a list of data.\n        \"\"\"\n        self.datas = datas\n\n    @staticmethod\n    def count(n: int, m: int) -> int:\n        \"\"\"\n        Calculate the number of combinations for a specific count.\n        :param n: The total number of elements,int.\n        :param m: The number of elements in each combination,int.\n        :return: The number of combinations,int.\n        >>> CombinationCalculator.count(4, 2)\n        6\n        \"\"\"\n\n    @staticmethod\n    def count_all(n: int) -> int:\n        \"\"\"\n        Calculate the number of all possible combinations.\n        :param n: The total number of elements,int.\n        :return: The number of all possible combinations,int,if the number of combinations is greater than 2^63-1,return float(\"inf\").\n        >>> CombinationCalculator.count_all(4)\n        15\n        \"\"\"\n\n    def select(self, m: int) -> List[List[str]]:\n        \"\"\"\n        Generate combinations with a specified number of elements.\n        :param m: The number of elements in each combination,int.\n        :return: A list of combinations,List[List[str]].\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> calc.select(2)\n        [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']]\n\n        \"\"\"\n\n    def select_all(self) -> List[List[str]]:\n        \"\"\"\n        Generate all possible combinations of  selecting elements from the given data list,and it uses the select method.\n        :return: A list of combinations,List[List[str]].\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> calc.select_all()\n        [['A'], ['B'], ['C'], ['D'], ['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D'], ['A', 'B', 'C'], ['A', 'B', 'D'], ['A', 'C', 'D'], ['B', 'C', 'D'], ['A', 'B', 'C', 'D']]\n\n        \"\"\"\n\n    def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):\n        \"\"\"Recursively generates combinations of elements, selecting a specified number from a given set of data.\"\"\"", "method_info": [{"method_name": "count", "method_description": "def count(n: int, m: int) -> int:\n        \"\"\"\n        Calculate the number of combinations for a specific count.\n        :param n: The total number of elements,int.\n        :param m: The number of elements in each combination,int.\n        :return: The number of combinations,int.\n        >>> CombinationCalculator.count(4, 2)\n        6\n        \"\"\"", "test_class": "CombinationCalculatorTestCount", "test_code": "class CombinationCalculatorTestCount(unittest.TestCase):\n    def test_count(self):\n        self.assertEqual(CombinationCalculator.count(4, 2), 6)\n    def test_count_2(self):\n        self.assertEqual(CombinationCalculator.count(5, 3), 10)\n\n    def test_count_3(self):\n        self.assertEqual(CombinationCalculator.count(6, 6), 1)\n\n    def test_count_4(self):\n        self.assertEqual(CombinationCalculator.count(6, 0), 1)\n\n    def test_count_5(self):\n        self.assertEqual(CombinationCalculator.count(6, 3), 20)", "solution_code": "def count(n: int, m: int) -> int:\n        if m == 0 or n == m:\n            return 1\n        return math.factorial(n) // (math.factorial(n - m) * math.factorial(m))", "dependencies": {"Standalone": false, "lib_dependencies": ["math"], "field_dependencies": [], "method_dependencies": []}}, {"method_name": "count_all", "method_description": "@staticmethod\n    def count_all(n: int) -> int:\n        \"\"\"\n        Calculate the number of all possible combinations.\n        :param n: The total number of elements,int.\n        :return: The number of all possible combinations,int,if the number of combinations is greater than 2^63-1,return float(\"inf\").\n        >>> CombinationCalculator.count_all(4)\n        15\n        \"\"\"", "test_class": "CombinationCalculatorTestCountAll", "test_code": "class CombinationCalculatorTestCountAll(unittest.TestCase):\n    def test_count_all(self):\n        self.assertEqual(CombinationCalculator.count_all(4), 15)\n\n    def test_count_all_2(self):\n        self.assertEqual(CombinationCalculator.count_all(-1), False)\n\n    def test_count_all_3(self):\n        self.assertEqual(CombinationCalculator.count_all(65), False)\n\n    def test_count_all_4(self):\n        self.assertEqual(CombinationCalculator.count_all(0), 0)\n\n    def test_count_all_5(self):\n        self.assertEqual(CombinationCalculator.count_all(63), float(\"inf\"))", "solution_code": "@staticmethod\n    def count_all(n: int) -> int:\n        if n < 0 or n > 63:\n            return False\n        return (1 << n) - 1 if n != 63 else float(\"inf\")", "dependencies": {"Standalone": true, "lib_dependencies": [], "field_dependencies": [], "method_dependencies": []}}, {"method_name": "select", "method_description": "def select(self, m: int) -> List[List[str]]:\n        \"\"\"\n        Generate combinations with a specified number of elements.\n        :param m: The number of elements in each combination,int.\n        :return: A list of combinations,List[List[str]].\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> calc.select(2)\n        [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']]\n\n        \"\"\"", "test_class": "CombinationCalculatorTestSelect", "test_code": "class CombinationCalculatorTestSelect(unittest.TestCase):\n    def test_select(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        self.assertEqual(calc.count(4, 2), 6)\n\n    def test_select_2(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        self.assertEqual(calc.count(5, 3), 10)\n\n    def test_select_3(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        self.assertEqual(calc.count(6, 6), 1)\n\n    def test_select_4(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        self.assertEqual(calc.count(6, 0), 1)\n\n    def test_select_5(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        self.assertEqual(calc.count(6, 3), 20)", "solution_code": "def select(self, m: int) -> List[List[str]]:\n        result = []\n        self._select(0, [None] * m, 0, result)\n        return result", "dependencies": {"Standalone": false, "lib_dependencies": [], "field_dependencies": [], "method_dependencies": ["_select"]}}, {"method_name": "select_all", "method_description": "def select_all(self) -> List[List[str]]:\n        \"\"\"\n        Generate all possible combinations of  selecting elements from the given data list,and it uses the select method.\n        :return: A list of combinations,List[List[str]].\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> calc.select_all()\n        [['A'], ['B'], ['C'], ['D'], ['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D'], ['A', 'B', 'C'], ['A', 'B', 'D'], ['A', 'C', 'D'], ['B', 'C', 'D'], ['A', 'B', 'C', 'D']]\n\n        \"\"\"", "test_class": "CombinationCalculatorTestSelectAll", "test_code": "class CombinationCalculatorTestSelectAll(unittest.TestCase):\n    def test_select_all(self):\n        calc = CombinationCalculator([\"A\"])\n        self.assertEqual(calc.select_all(), [['A']])\n\n    def test_select_all_2(self):\n        calc = CombinationCalculator([\"A\", \"B\"])\n        self.assertEqual(calc.select_all(), [['A'], ['B'], ['A', 'B']])\n\n    def test_select_all_3(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\"])\n        self.assertEqual(calc.select_all(),[['A'], ['B'], ['C'], ['A', 'B'], ['A', 'C'], ['B', 'C'], ['A', 'B', 'C']])\n\n    def test_select_all_4(self):\n        calc = CombinationCalculator([])\n        self.assertEqual(calc.select_all(),[])\n\n    def test_select_all_5(self):\n        calc = CombinationCalculator([\"B\"])\n        self.assertEqual(calc.select_all(),[['B']])", "solution_code": "def select_all(self) -> List[List[str]]:\n        result = []\n        for i in range(1, len(self.datas) + 1):\n            result.extend(self.select(i))\n        return result", "dependencies": {"Standalone": false, "lib_dependencies": [], "field_dependencies": ["self.datas"], "method_dependencies": ["select"]}}, {"method_name": "_select", "method_description": "def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):\n        \"\"\"\n        Generate combinations with a specified number of elements by recursion.\n        :param dataIndex: The index of the data to be selected,int.\n        :param resultList: The list of elements in the combination,List[str].\n        :param resultIndex: The index of the element in the combination,int.\n        :param result: The list of combinations,List[List[str]].\n        :return: None.\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> result = []\n        >>> calc._select(0, [None] * 2, 0, result)\n        >>> result\n        [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']]\n\n        \"\"\"", "test_class": "CombinationCalculatorTestSelect2", "test_code": "class CombinationCalculatorTestSelect2(unittest.TestCase):\n    def test_select2(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        result = []\n        calc._select(0, [None] * 2, 0, result)\n        self.assertEqual(result, [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']])\n\n    def test_select2_2(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        result = []\n        calc._select(0, [None] * 3, 0, result)\n        self.assertEqual(result, [['A', 'B', 'C'], ['A', 'B', 'D'], ['A', 'C', 'D'], ['B', 'C', 'D']])\n\n    def test_select2_3(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        result = []\n        calc._select(0, [None] * 1, 0, result)\n        self.assertEqual(result, [['A'], ['B'], ['C'], ['D']])\n\n    def test_select2_4(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        result = []\n        calc._select(0, [None] * 0, 0, result)\n        self.assertEqual(result, [[]])\n\n    def test_select2_5(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        result = []\n        calc._select(0, [None] * 4, 0, result)\n        self.assertEqual(result, [['A', 'B', 'C', 'D']])", "solution_code": "def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):\n        resultLen = len(resultList)\n        resultCount = resultIndex + 1\n        if resultCount > resultLen:\n            result.append(resultList.copy())\n            return\n\n        for i in range(dataIndex, len(self.datas) + resultCount - resultLen):\n            resultList[resultIndex] = self.datas[i]\n            self._select(i + 1, resultList, resultIndex + 1, result)", "dependencies": {"Standalone": false, "lib_dependencies": ["List"], "field_dependencies": ["self.datas"], "method_dependencies": ["select"]}}], "test_cases": "import unittest\n\nclass CombinationCalculatorTestCount(unittest.TestCase):\n    def test_count(self):\n        self.assertEqual(CombinationCalculator.count(4, 2), 6)\n    def test_count_2(self):\n        self.assertEqual(CombinationCalculator.count(5, 3), 10)\n\n    def test_count_3(self):\n        self.assertEqual(CombinationCalculator.count(6, 6), 1)\n\n    def test_count_4(self):\n        self.assertEqual(CombinationCalculator.count(6, 0), 1)\n\n    def test_count_5(self):\n        self.assertEqual(CombinationCalculator.count(6, 3), 20)\n\nclass CombinationCalculatorTestCountAll(unittest.TestCase):\n    def test_count_all(self):\n        self.assertEqual(CombinationCalculator.count_all(4), 15)\n\n    def test_count_all_2(self):\n        self.assertEqual(CombinationCalculator.count_all(-1), False)\n\n    def test_count_all_3(self):\n        self.assertEqual(CombinationCalculator.count_all(65), False)\n\n    def test_count_all_4(self):\n        self.assertEqual(CombinationCalculator.count_all(0), 0)\n\n    def test_count_all_5(self):\n        self.assertEqual(CombinationCalculator.count_all(63), float(\"inf\"))\n\nclass CombinationCalculatorTestSelect(unittest.TestCase):\n    def test_select(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        self.assertEqual(calc.count(4, 2), 6)\n\n    def test_select_2(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        self.assertEqual(calc.count(5, 3), 10)\n\n    def test_select_3(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        self.assertEqual(calc.count(6, 6), 1)\n\n    def test_select_4(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        self.assertEqual(calc.count(6, 0), 1)\n\n    def test_select_5(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        self.assertEqual(calc.count(6, 3), 20)\n\nclass CombinationCalculatorTestSelectAll(unittest.TestCase):\n    def test_select_all(self):\n        calc = CombinationCalculator([\"A\"])\n        self.assertEqual(calc.select_all(), [['A']])\n\n    def test_select_all_2(self):\n        calc = CombinationCalculator([\"A\", \"B\"])\n        self.assertEqual(calc.select_all(), [['A'], ['B'], ['A', 'B']])\n\n    def test_select_all_3(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\"])\n        self.assertEqual(calc.select_all(),[['A'], ['B'], ['C'], ['A', 'B'], ['A', 'C'], ['B', 'C'], ['A', 'B', 'C']])\n\n    def test_select_all_4(self):\n        calc = CombinationCalculator([])\n        self.assertEqual(calc.select_all(),[])\n\n    def test_select_all_5(self):\n        calc = CombinationCalculator([\"B\"])\n        self.assertEqual(calc.select_all(),[['B']])\n\n\nclass CombinationCalculatorTestSelect2(unittest.TestCase):\n    def test_select2(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        result = []\n        calc._select(0, [None] * 2, 0, result)\n        self.assertEqual(result, [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']])\n\n    def test_select2_2(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        result = []\n        calc._select(0, [None] * 3, 0, result)\n        self.assertEqual(result, [['A', 'B', 'C'], ['A', 'B', 'D'], ['A', 'C', 'D'], ['B', 'C', 'D']])\n\n    def test_select2_3(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        result = []\n        calc._select(0, [None] * 1, 0, result)\n        self.assertEqual(result, [['A'], ['B'], ['C'], ['D']])\n\n    def test_select2_4(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        result = []\n        calc._select(0, [None] * 0, 0, result)\n        self.assertEqual(result, [[]])\n\n    def test_select2_5(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        result = []\n        calc._select(0, [None] * 4, 0, result)\n        self.assertEqual(result, [['A', 'B', 'C', 'D']])\n\nclass CombinationCalculatorTestMain(unittest.TestCase):\n    def test_main(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        self.assertEqual(calc.count(4, 2), 6)\n        self.assertEqual(calc.count_all(4), 15)\n        self.assertEqual(calc.select(2), [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']])\n        self.assertEqual(calc.select_all(), [['A'], ['B'], ['C'], ['D'], ['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D'], ['A', 'B', 'C'], ['A', 'B', 'D'], ['A', 'C', 'D'], ['B', 'C', 'D'], ['A', 'B', 'C', 'D']])\n        result = []\n        calc._select(0, [None] * 2, 0, result)\n        self.assertEqual(result, [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']])", "solutions": ["import math\nfrom typing import List\n\nclass CombinationCalculator:\n    def __init__(self, datas: List[str]):\n        self.datas = datas\n\n    @staticmethod\n    def count(n: int, m: int) -> int:\n        if m == 0 or n == m:\n            return 1\n        return math.factorial(n) // (math.factorial(n - m) * math.factorial(m))\n\n    @staticmethod\n    def count_all(n: int) -> int:\n        if n < 0 or n > 63:\n            return False\n        return (1 << n) - 1 if n != 63 else float(\"inf\")\n\n    def select(self, m: int) -> List[List[str]]:\n        result = []\n        self._select(0, [None] * m, 0, result)\n        return result\n\n    def select_all(self) -> List[List[str]]:\n        result = []\n        for i in range(1, len(self.datas) + 1):\n            result.extend(self.select(i))\n        return result\n\n    def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):\n        resultLen = len(resultList)\n        resultCount = resultIndex + 1\n        if resultCount > resultLen:\n            result.append(resultList.copy())\n            return\n\n        for i in range(dataIndex, len(self.datas) + resultCount - resultLen):\n            resultList[resultIndex] = self.datas[i]\n            self._select(i + 1, resultList, resultIndex + 1, result)"], "task": "class_eval", "split": "test", "transformation_type": "func_summary", "import_statement": ["import math", "from typing import List"], "test_classes": ["CombinationCalculatorTestCount", "CombinationCalculatorTestCountAll", "CombinationCalculatorTestSelect", "CombinationCalculatorTestSelectAll", "CombinationCalculatorTestSelect2", "CombinationCalculatorTestMain"]}