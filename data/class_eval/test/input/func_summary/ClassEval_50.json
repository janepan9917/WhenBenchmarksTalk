{"qid": "ClassEval_50", "orig_input": "import json\nimport os\n\nclass JSONProcessor:\n    \"\"\"\n    This is a class to process JSON file, including reading and writing JSON files, as well as processing JSON data by removing a specified key from the JSON object.\n    \"\"\"\n\n    def read_json(self, file_path):\n        \"\"\"\n        Read a JSON file and return the data.\n        :param file_path: str, the path of the JSON file.\n        :return: dict, the data from the JSON file if read successfully, or return -1 if an error occurs during the reading process.\n                    return 0 if the file does not exist.\n        >>> json.read_json('test.json')\n        {'name': 'test', 'age': 14}\n        \"\"\"\n\n    def write_json(self, data, file_path):\n        \"\"\"\n        Write data to a JSON file and save it to the given path.\n\n        :param data: dict, the data to be written to the JSON file.\n        :param file_path: str, the path of the JSON file.\n        :return: 1 if the writing process is successful, or -1, if an error occurs during the writing process.\n        >>> json.write_json({'key1': 'value1', 'key2': 'value2'}, 'test.json')\n        1\n        >>> json.read_json('test.json')\n        {'key1': 'value1', 'key2': 'value2'}\n        \"\"\"\n\n    def process_json(self, file_path, remove_key):\n        \"\"\"\n        read a JSON file and process the data by removing a specified key and rewrite the modified data back to the file.\n\n        :param file_path: str, the path of the JSON file.\n        :param remove_key: str, the key to be removed.\n        :return: 1, if the specified key is successfully removed and the data is written back.\n                    0, if the file does not exist or the specified key does not exist in the data.\n        >>> json.read_json('test.json')\n        {'key1': 'value1', 'key2': 'value2'}\n        >>> json.process_json('test.json', 'key1')\n        1\n        >>> json.read_json('test.json')\n        {'key2': 'value2'}\n        \"\"\"", "input": "import json\nimport os\n\nclass JSONProcessor:\n    \"\"\"\n    This is a class to process JSON file, including reading and writing JSON files, as well as processing JSON data by removing a specified key from the JSON object.\n    \"\"\"\n\n    def read_json(self, file_path):\n        \"\"\"Reads JSON file, returns data as dictionary, or specific values for errors or non-existent files.\"\"\"\n\n    def write_json(self, data, file_path):\n        \"\"\"Writes data to a JSON file at a specified path, returning success or failure status.\"\"\"\n\n    def process_json(self, file_path, remove_key):\n        \"\"\"The method reads a JSON file, removes a specified key, and rewrites the modified data back to the file.\"\"\"", "method_info": [{"method_name": "read_json", "method_description": "def read_json(self, file_path):\n        \"\"\"\n        Read a JSON file and return the data.\n        :param file_path: str, the path of the JSON file.\n        :return: dict, the data from the JSON file if read successfully, or return -1 if an error occurs during the reading process.\n                    return 0 if the file does not exist.\n        >>> json.read_json('test.json')\n        {'name': 'test', 'age': 14}\n        \"\"\"", "test_class": "JSONProcessorTestReadJson", "test_code": "class JSONProcessorTestReadJson(unittest.TestCase):\n    def setUp(self):\n        self.processor = JSONProcessor()\n        self.test_data = {\n            \"key1\": \"value1\",\n            \"key2\": \"value2\",\n            \"key3\": \"value3\"\n        }\n        self.file_path = \"test.json\"\n\n    def tearDown(self):\n        if os.path.exists(self.file_path):\n            os.remove(self.file_path)\n\n    # file exists\n    def test_read_json_1(self):\n        with open(self.file_path, 'w') as file:\n            json.dump(self.test_data, file)\n        result = self.processor.read_json(self.file_path)\n        self.assertEqual(result, self.test_data)\n\n    # file not exists\n    def test_read_json_2(self):\n        result = self.processor.read_json(self.file_path)\n        self.assertEqual(result, 0)\n\n    # invalid json file\n    def test_read_json_3(self):\n        with open(self.file_path, 'w') as file:\n            file.write(\"Invalid JSON\")\n        result = self.processor.read_json(self.file_path)\n        self.assertEqual(result, -1)\n\n    def test_read_json_4(self):\n        result = self.processor.read_json('wrong')\n        self.assertEqual(result, 0)\n\n    def test_read_json_5(self):\n        result = self.processor.read_json('abcd')\n        self.assertEqual(result, 0)", "solution_code": "def read_json(self, file_path):\n        if not os.path.exists(file_path):\n            return 0\n        try:\n            with open(file_path, 'r') as file:\n                data = json.load(file)\n            return data\n        except:\n            return -1", "dependencies": {"Standalone": false, "lib_dependencies": ["json", "os"], "field_dependencies": [], "method_dependencies": []}}, {"method_name": "write_json", "method_description": "def write_json(self, data, file_path):\n        \"\"\"\n        Write data to a JSON file and save it to the given path.\n\n        :param data: dict, the data to be written to the JSON file.\n        :param file_path: str, the path of the JSON file.\n        :return: 1 if the writing process is successful, or -1, if an error occurs during the writing process.\n        >>> json.write_json({'key1': 'value1', 'key2': 'value2'}, 'test.json')\n        1\n        >>> json.read_json('test.json')\n        {'key1': 'value1', 'key2': 'value2'}\n        \"\"\"", "test_class": "JSONProcessorTestWriteJson", "test_code": "class JSONProcessorTestWriteJson(unittest.TestCase):\n    def setUp(self):\n        self.processor = JSONProcessor()\n        self.test_data = {\n            \"key1\": \"value1\",\n            \"key2\": \"value2\",\n            \"key3\": \"value3\"\n        }\n        self.file_path = \"test.json\"\n\n        # create a read only file\n        self.file_path_only_read = 'test_only_read.json'\n        with open(self.file_path_only_read, 'w') as f:\n            f.write('{\"key1\": \"value1\"}')\n\n        # set file only read mode\n        os.chmod(self.file_path_only_read, stat.S_IRUSR + stat.S_IRGRP + stat.S_IROTH)\n\n    def tearDown(self):\n        if os.path.exists(self.file_path):\n            os.remove(self.file_path)\n        if os.path.exists(self.file_path_only_read):\n            # unset file only read mode and remove the file\n            os.chmod(self.file_path_only_read,\n                     stat.S_IWUSR + stat.S_IRUSR + stat.S_IWGRP + stat.S_IRGRP + stat.S_IWOTH + stat.S_IROTH)\n            os.remove(self.file_path_only_read)\n\n    def test_write_json_1(self):\n        result = self.processor.write_json(self.test_data, self.file_path)\n        self.assertEqual(result, 1)\n        with open(self.file_path, 'r') as file:\n            written_data = json.load(file)\n        self.assertEqual(written_data, self.test_data)\n\n    def test_write_json_2(self):\n        # Provide a read-only file path to simulate an exception\n        result = self.processor.write_json(self.test_data, self.file_path_only_read)\n        self.assertEqual(result, -1)\n\n    def test_write_json_3(self):\n        result = self.processor.write_json([], self.file_path_only_read)\n        self.assertEqual(result, -1)\n\n    def test_write_json_4(self):\n        result = self.processor.write_json(self.test_data, '')\n        self.assertEqual(result, -1)\n\n    def test_write_json_5(self):\n        result = self.processor.write_json([], '')\n        self.assertEqual(result, -1)", "solution_code": "def write_json(self, data, file_path):\n        try:\n            with open(file_path, 'w') as file:\n                json.dump(data, file)\n            return 1\n        except:\n            return -1", "dependencies": {"Standalone": false, "lib_dependencies": ["json"], "field_dependencies": [], "method_dependencies": []}}, {"method_name": "process_json", "method_description": "def process_json(self, file_path, remove_key):\n        \"\"\"\n        read a JSON file and process the data by removing a specified key and rewrite the modified data back to the file.\n\n        :param file_path: str, the path of the JSON file.\n        :param remove_key: str, the key to be removed.\n        :return: 1, if the specified key is successfully removed and the data is written back.\n                    0, if the file does not exist or the specified key does not exist in the data.\n        >>> json.read_json('test.json')\n        {'key1': 'value1', 'key2': 'value2'}\n        >>> json.process_json('test.json', 'key1')\n        1\n        >>> json.read_json('test.json')\n        {'key2': 'value2'}\n        \"\"\"", "test_class": "JSONProcessorTestProcessJsonExistingKey", "test_code": "class JSONProcessorTestProcessJsonExistingKey(unittest.TestCase):\n    def setUp(self):\n        self.processor = JSONProcessor()\n        self.test_data = {\n            \"key1\": \"value1\",\n            \"key2\": \"value2\",\n            \"key3\": \"value3\"\n        }\n        self.file_path = \"test.json\"\n\n    def tearDown(self):\n        if os.path.exists(self.file_path):\n            os.remove(self.file_path)\n\n    # key exists\n    def test_process_json_1(self):\n        with open(self.file_path, 'w') as file:\n            json.dump(self.test_data, file)\n        remove_key = \"key2\"\n        self.processor.process_json(self.file_path, remove_key)\n        with open(self.file_path, 'r') as file:\n            processed_data = json.load(file)\n        expected_data = {\n            \"key1\": \"value1\",\n            \"key3\": \"value3\"\n        }\n        self.assertEqual(processed_data, expected_data)\n\n    # key not exists\n    def test_process_json_2(self):\n        with open(self.file_path, 'w') as file:\n            json.dump(self.test_data, file)\n        remove_key = \"nonexistent_key\"\n        self.processor.process_json(self.file_path, remove_key)\n        with open(self.file_path, 'r') as file:\n            processed_data = json.load(file)\n        self.assertEqual(processed_data, self.test_data)\n\n    # file is empty\n    def test_process_json_3(self):\n        # Create an empty JSON file\n        with open(self.file_path, 'w') as file:\n            pass\n        remove_key = \"key1\"\n        self.assertEqual(self.processor.process_json(self.file_path, remove_key), 0)\n\n    def test_process_json_4(self):\n        with open(self.file_path, 'w') as file:\n            json.dump(self.test_data, file)\n        remove_key = \"aaa\"\n        self.processor.process_json(self.file_path, remove_key)\n        with open(self.file_path, 'r') as file:\n            processed_data = json.load(file)\n        self.assertEqual(processed_data, self.test_data)\n\n    def test_process_json_5(self):\n        with open(self.file_path, 'w') as file:\n            json.dump(self.test_data, file)\n        remove_key = \"bbb\"\n        self.processor.process_json(self.file_path, remove_key)\n        with open(self.file_path, 'r') as file:\n            processed_data = json.load(file)\n        self.assertEqual(processed_data, self.test_data)", "solution_code": "def process_json(self, file_path, remove_key):\n        data = self.read_json(file_path)\n        if data == 0 or data == -1:\n            return 0\n        if remove_key in data:\n            del data[remove_key]\n            self.write_json(data, file_path)\n            return 1\n        else:\n            return 0", "dependencies": {"Standalone": false, "lib_dependencies": ["json"], "field_dependencies": [], "method_dependencies": ["read_json", "write_json"]}}], "test_cases": "import os\nimport stat\nimport json\nimport unittest\n\n\nclass JSONProcessorTestReadJson(unittest.TestCase):\n    def setUp(self):\n        self.processor = JSONProcessor()\n        self.test_data = {\n            \"key1\": \"value1\",\n            \"key2\": \"value2\",\n            \"key3\": \"value3\"\n        }\n        self.file_path = \"test.json\"\n\n    def tearDown(self):\n        if os.path.exists(self.file_path):\n            os.remove(self.file_path)\n\n    # file exists\n    def test_read_json_1(self):\n        with open(self.file_path, 'w') as file:\n            json.dump(self.test_data, file)\n        result = self.processor.read_json(self.file_path)\n        self.assertEqual(result, self.test_data)\n\n    # file not exists\n    def test_read_json_2(self):\n        result = self.processor.read_json(self.file_path)\n        self.assertEqual(result, 0)\n\n    # invalid json file\n    def test_read_json_3(self):\n        with open(self.file_path, 'w') as file:\n            file.write(\"Invalid JSON\")\n        result = self.processor.read_json(self.file_path)\n        self.assertEqual(result, -1)\n\n    def test_read_json_4(self):\n        result = self.processor.read_json('wrong')\n        self.assertEqual(result, 0)\n\n    def test_read_json_5(self):\n        result = self.processor.read_json('abcd')\n        self.assertEqual(result, 0)\n\n\nclass JSONProcessorTestWriteJson(unittest.TestCase):\n    def setUp(self):\n        self.processor = JSONProcessor()\n        self.test_data = {\n            \"key1\": \"value1\",\n            \"key2\": \"value2\",\n            \"key3\": \"value3\"\n        }\n        self.file_path = \"test.json\"\n\n        # create a read only file\n        self.file_path_only_read = 'test_only_read.json'\n        with open(self.file_path_only_read, 'w') as f:\n            f.write('{\"key1\": \"value1\"}')\n\n        # set file only read mode\n        os.chmod(self.file_path_only_read, stat.S_IRUSR + stat.S_IRGRP + stat.S_IROTH)\n\n    def tearDown(self):\n        if os.path.exists(self.file_path):\n            os.remove(self.file_path)\n        if os.path.exists(self.file_path_only_read):\n            # unset file only read mode and remove the file\n            os.chmod(self.file_path_only_read,\n                     stat.S_IWUSR + stat.S_IRUSR + stat.S_IWGRP + stat.S_IRGRP + stat.S_IWOTH + stat.S_IROTH)\n            os.remove(self.file_path_only_read)\n\n    def test_write_json_1(self):\n        result = self.processor.write_json(self.test_data, self.file_path)\n        self.assertEqual(result, 1)\n        with open(self.file_path, 'r') as file:\n            written_data = json.load(file)\n        self.assertEqual(written_data, self.test_data)\n\n    def test_write_json_2(self):\n        # Provide a read-only file path to simulate an exception\n        result = self.processor.write_json(self.test_data, self.file_path_only_read)\n        self.assertEqual(result, -1)\n\n    def test_write_json_3(self):\n        result = self.processor.write_json([], self.file_path_only_read)\n        self.assertEqual(result, -1)\n\n    def test_write_json_4(self):\n        result = self.processor.write_json(self.test_data, '')\n        self.assertEqual(result, -1)\n\n    def test_write_json_5(self):\n        result = self.processor.write_json([], '')\n        self.assertEqual(result, -1)\n\n\nclass JSONProcessorTestProcessJsonExistingKey(unittest.TestCase):\n    def setUp(self):\n        self.processor = JSONProcessor()\n        self.test_data = {\n            \"key1\": \"value1\",\n            \"key2\": \"value2\",\n            \"key3\": \"value3\"\n        }\n        self.file_path = \"test.json\"\n\n    def tearDown(self):\n        if os.path.exists(self.file_path):\n            os.remove(self.file_path)\n\n    # key exists\n    def test_process_json_1(self):\n        with open(self.file_path, 'w') as file:\n            json.dump(self.test_data, file)\n        remove_key = \"key2\"\n        self.processor.process_json(self.file_path, remove_key)\n        with open(self.file_path, 'r') as file:\n            processed_data = json.load(file)\n        expected_data = {\n            \"key1\": \"value1\",\n            \"key3\": \"value3\"\n        }\n        self.assertEqual(processed_data, expected_data)\n\n    # key not exists\n    def test_process_json_2(self):\n        with open(self.file_path, 'w') as file:\n            json.dump(self.test_data, file)\n        remove_key = \"nonexistent_key\"\n        self.processor.process_json(self.file_path, remove_key)\n        with open(self.file_path, 'r') as file:\n            processed_data = json.load(file)\n        self.assertEqual(processed_data, self.test_data)\n\n    # file is empty\n    def test_process_json_3(self):\n        # Create an empty JSON file\n        with open(self.file_path, 'w') as file:\n            pass\n        remove_key = \"key1\"\n        self.assertEqual(self.processor.process_json(self.file_path, remove_key), 0)\n\n    def test_process_json_4(self):\n        with open(self.file_path, 'w') as file:\n            json.dump(self.test_data, file)\n        remove_key = \"aaa\"\n        self.processor.process_json(self.file_path, remove_key)\n        with open(self.file_path, 'r') as file:\n            processed_data = json.load(file)\n        self.assertEqual(processed_data, self.test_data)\n\n    def test_process_json_5(self):\n        with open(self.file_path, 'w') as file:\n            json.dump(self.test_data, file)\n        remove_key = \"bbb\"\n        self.processor.process_json(self.file_path, remove_key)\n        with open(self.file_path, 'r') as file:\n            processed_data = json.load(file)\n        self.assertEqual(processed_data, self.test_data)\n\n\nclass JSONProcessorTestMain(unittest.TestCase):\n    def setUp(self):\n        self.processor = JSONProcessor()\n        self.test_data = {\n            \"key1\": \"value1\",\n            \"key2\": \"value2\",\n            \"key3\": \"value3\"\n        }\n        self.file_path = \"test.json\"\n\n    def tearDown(self):\n        if os.path.exists(self.file_path):\n            os.remove(self.file_path)\n\n    def test_main(self):\n        # write first\n        result = self.processor.write_json(self.test_data, self.file_path)\n        self.assertEqual(result, 1)\n        with open(self.file_path, 'r') as file:\n            written_data = json.load(file)\n        self.assertEqual(written_data, self.test_data)\n\n        # read\n        result = self.processor.read_json(self.file_path)\n        self.assertEqual(result, self.test_data)\n\n        # process\n        remove_key = \"key2\"\n        self.processor.process_json(self.file_path, remove_key)\n        with open(self.file_path, 'r') as file:\n            processed_data = json.load(file)\n        expected_data = {\n            \"key1\": \"value1\",\n            \"key3\": \"value3\"\n        }\n        self.assertEqual(processed_data, expected_data)", "solutions": ["import json\nimport os\n\n\nclass JSONProcessor:\n    def read_json(self, file_path):\n        if not os.path.exists(file_path):\n            return 0\n        try:\n            with open(file_path, 'r') as file:\n                data = json.load(file)\n            return data\n        except:\n            return -1\n\n    def write_json(self, data, file_path):\n        try:\n            with open(file_path, 'w') as file:\n                json.dump(data, file)\n            return 1\n        except:\n            return -1\n\n    def process_json(self, file_path, remove_key):\n        data = self.read_json(file_path)\n        if data == 0 or data == -1:\n            return 0\n        if remove_key in data:\n            del data[remove_key]\n            self.write_json(data, file_path)\n            return 1\n        else:\n            return 0"], "task": "class_eval", "split": "test", "transformation_type": "func_summary", "import_statement": ["import json", "import os"], "test_classes": ["JSONProcessorTestReadJson", "JSONProcessorTestWriteJson", "JSONProcessorTestProcessJsonExistingKey", "JSONProcessorTestMain"]}