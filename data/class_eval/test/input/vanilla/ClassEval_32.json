{"qid": "ClassEval_32", "orig_input": "class DecryptionUtils:\n    \"\"\"\n    This is a class that provides methods for decryption, including the Caesar cipher, Vigenere cipher, and Rail Fence cipher.\n    \"\"\"\n\n    def __init__(self, key):\n        \"\"\"\n        Initializes the decryption utility with a key.\n        :param key: The key to use for decryption,str.\n        \"\"\"\n        self.key = key\n\n    def caesar_decipher(self, ciphertext, shift):\n        \"\"\"\n        Deciphers the given ciphertext using the Caesar cipher\n        :param ciphertext: The ciphertext to decipher,str.\n        :param shift: The shift to use for decryption,int.\n        :return: The deciphered plaintext,str.\n        >>> d = DecryptionUtils('key')\n        >>> d.caesar_decipher('ifmmp', 1)\n        'hello'\n\n        \"\"\"\n\n    def vigenere_decipher(self, ciphertext):\n        \"\"\"\n        Deciphers the given ciphertext using the Vigenere cipher\n        :param ciphertext: The ciphertext to decipher,str.\n        :return: The deciphered plaintext,str.\n        >>> d = DecryptionUtils('key')\n        >>> d.vigenere_decipher('ifmmp')\n        'ybocl'\n\n        \"\"\"\n\n    def rail_fence_decipher(self, encrypted_text, rails):\n        \"\"\"\n        Deciphers the given ciphertext using the Rail Fence cipher\n        :param encrypted_text: The ciphertext to decipher,str.\n        :param rails: The number of rails to use for decryption,int.\n        :return: The deciphered plaintext,str.\n        >>> d = DecryptionUtils('key')\n        >>> d.rail_fence_decipher('Hoo!el,Wrdl l', 3)\n        'Hello, World!'\n\n        \"\"\"", "input": "class DecryptionUtils:\n    \"\"\"\n    This is a class that provides methods for decryption, including the Caesar cipher, Vigenere cipher, and Rail Fence cipher.\n    \"\"\"\n\n    def __init__(self, key):\n        \"\"\"\n        Initializes the decryption utility with a key.\n        :param key: The key to use for decryption,str.\n        \"\"\"\n        self.key = key\n\n    def caesar_decipher(self, ciphertext, shift):\n        \"\"\"\n        Deciphers the given ciphertext using the Caesar cipher\n        :param ciphertext: The ciphertext to decipher,str.\n        :param shift: The shift to use for decryption,int.\n        :return: The deciphered plaintext,str.\n        >>> d = DecryptionUtils('key')\n        >>> d.caesar_decipher('ifmmp', 1)\n        'hello'\n\n        \"\"\"\n\n    def vigenere_decipher(self, ciphertext):\n        \"\"\"\n        Deciphers the given ciphertext using the Vigenere cipher\n        :param ciphertext: The ciphertext to decipher,str.\n        :return: The deciphered plaintext,str.\n        >>> d = DecryptionUtils('key')\n        >>> d.vigenere_decipher('ifmmp')\n        'ybocl'\n\n        \"\"\"\n\n    def rail_fence_decipher(self, encrypted_text, rails):\n        \"\"\"\n        Deciphers the given ciphertext using the Rail Fence cipher\n        :param encrypted_text: The ciphertext to decipher,str.\n        :param rails: The number of rails to use for decryption,int.\n        :return: The deciphered plaintext,str.\n        >>> d = DecryptionUtils('key')\n        >>> d.rail_fence_decipher('Hoo!el,Wrdl l', 3)\n        'Hello, World!'\n\n        \"\"\"", "method_info": [{"method_name": "caesar_decipher", "method_description": "def caesar_decipher(self, ciphertext, shift):\n        \"\"\"\n        Deciphers the given ciphertext using the Caesar cipher\n        :param ciphertext: The ciphertext to decipher,str.\n        :param shift: The shift to use for decryption,int.\n        :return: The deciphered plaintext,str.\n        >>> d = DecryptionUtils('key')\n        >>> d.caesar_decipher('ifmmp', 1)\n        'hello'\n\n        \"\"\"", "test_class": "DecryptionUtilsTestCaesarDecipher", "test_code": "class DecryptionUtilsTestCaesarDecipher(unittest.TestCase):\n    def test_caesar_decipher(self):\n        d = DecryptionUtils('key')\n        self.assertEqual(d.caesar_decipher('ifmmp', 1), 'hello')\n\n    def test_caesar_decipher_2(self):\n        d = DecryptionUtils('key')\n        self.assertEqual(d.caesar_decipher('bcdyza', 27), 'abcxyz')\n\n    def test_caesar_decipher_3(self):\n        d = DecryptionUtils('key')\n        self.assertEqual(d.caesar_decipher('bcd', 0), 'bcd')\n\n    def test_caesar_decipher_4(self):\n        d = DecryptionUtils('key')\n        self.assertEqual(d.caesar_decipher('bcd', 26), 'bcd')\n\n    def test_caesar_decipher_5(self):\n        d = DecryptionUtils('key')\n        self.assertEqual(d.caesar_decipher('bcd', -26), 'bcd')\n\n    def test_caesar_decipher_6(self):\n        d = DecryptionUtils('key')\n        self.assertEqual(d.caesar_decipher('IFMMP', 1), 'HELLO')\n\n    def test_caesar_decipher_7(self):\n        d = DecryptionUtils('key')\n        self.assertEqual(d.caesar_decipher('123', 1), '123')", "solution_code": "def caesar_decipher(self, ciphertext, shift):\n        plaintext = \"\"\n        for char in ciphertext:\n            if char.isalpha():\n                if char.isupper():\n                    ascii_offset = 65\n                else:\n                    ascii_offset = 97\n                shifted_char = chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n                plaintext += shifted_char\n            else:\n                plaintext += char\n        return plaintext", "dependencies": {"Standalone": true, "lib_dependencies": [], "field_dependencies": [], "method_dependencies": []}}, {"method_name": "vigenere_decipher", "method_description": "def vigenere_decipher(self, ciphertext):\n        \"\"\"\n        Deciphers the given ciphertext using the Vigenere cipher\n        :param ciphertext: The ciphertext to decipher,str.\n        :return: The deciphered plaintext,str.\n        >>> d = DecryptionUtils('key')\n        >>> d.vigenere_decipher('ifmmp')\n        'ybocl'\n\n        \"\"\"", "test_class": "DecryptionUtilsTestVigenereDecipher", "test_code": "class DecryptionUtilsTestVigenereDecipher(unittest.TestCase):\n    def test_vigenere_decipher(self):\n        d = DecryptionUtils('key')\n        self.assertEqual(d.vigenere_decipher('ifmmp'), 'ybocl')\n\n    def test_vigenere_decipher_2(self):\n        d = DecryptionUtils('key')\n        self.assertEqual(d.vigenere_decipher('rijvs'), 'hello')\n\n    def test_vigenere_decipher_3(self):\n        d = DecryptionUtils('longkey')\n        self.assertEqual(d.vigenere_decipher('LpPjOjE'), 'AbCdEfG')\n\n    def test_vigenere_decipher_4(self):\n        d = DecryptionUtils('key')\n        self.assertEqual(d.vigenere_decipher('bcd'), 'ryf')\n\n    def test_vigenere_decipher_5(self):\n        d = DecryptionUtils('key')\n        self.assertEqual(d.vigenere_decipher('bcdaa'), 'ryfqw')\n\n    def test_vigenere_decipher_6(self):\n        d = DecryptionUtils('key')\n        self.assertEqual(d.vigenere_decipher('123'), '123')", "solution_code": "def vigenere_decipher(self, ciphertext):\n        decrypted_text = \"\"\n        key_index = 0\n        for char in ciphertext:\n            if char.isalpha():\n                shift = ord(self.key[key_index % len(self.key)].lower()) - ord('a')\n                decrypted_char = chr((ord(char.lower()) - ord('a') - shift) % 26 + ord('a'))\n                decrypted_text += decrypted_char.upper() if char.isupper() else decrypted_char\n                key_index += 1\n            else:\n                decrypted_text += char\n        return decrypted_text", "dependencies": {"Standalone": false, "lib_dependencies": [], "field_dependencies": ["self.key"], "method_dependencies": []}}, {"method_name": "rail_fence_decipher", "method_description": "def rail_fence_decipher(self, encrypted_text, rails):\n        \"\"\"\n        Deciphers the given ciphertext using the Rail Fence cipher\n        :param encrypted_text: The ciphertext to decipher,str.\n        :param rails: The number of rails to use for decryption,int.\n        :return: The deciphered plaintext,str.\n        >>> d = DecryptionUtils('key')\n        >>> d.rail_fence_decipher('Hoo!el,Wrdl l', 3)\n        'Hello, World!'\n\n        \"\"\"", "test_class": "DecryptionUtilsTestRailFenceDecipher", "test_code": "class DecryptionUtilsTestRailFenceDecipher(unittest.TestCase):\n    def test_rail_fence_decipher(self):\n        d = DecryptionUtils('key')\n        self.assertEqual(d.rail_fence_decipher('Hoo!el,Wrdl l', 3), 'Hello, World!')\n\n    def test_rail_fence_decipher_2(self):\n        d = DecryptionUtils('key')\n        self.assertEqual(d.rail_fence_decipher('Hoo!el,Wrdl l', 4), 'H!W reoldll,o')\n\n    def test_rail_fence_decipher_3(self):\n        d = DecryptionUtils('key')\n        self.assertEqual(d.rail_fence_decipher('Hoo!el,Wrdl l', 5), 'Holr d,!oeWll')\n\n    def test_rail_fence_decipher_4(self):\n        d = DecryptionUtils('key')\n        self.assertEqual(d.rail_fence_decipher('Hoo!el,Wrdl l', 6), 'Holrll d,!oeW')\n\n    def test_rail_fence_decipher_5(self):\n        d = DecryptionUtils('key')\n        self.assertEqual(d.rail_fence_decipher('Hoo!el,Wrdl l', 7), 'Hoe,rll dWl!o')", "solution_code": "def rail_fence_decipher(self, encrypted_text, rails):\n        fence = [['\\n' for _ in range(len(encrypted_text))] for _ in range(rails)]\n        direction = -1\n        row, col = 0, 0\n\n        for _ in range(len(encrypted_text)):\n            if row == 0 or row == rails - 1:\n                direction = -direction\n\n            fence[row][col] = ''\n            col += 1\n            row += direction\n\n        index = 0\n        for i in range(rails):\n            for j in range(len(encrypted_text)):\n                if fence[i][j] == '':\n                    fence[i][j] = encrypted_text[index]\n                    index += 1\n\n        plain_text = ''\n        direction = -1\n        row, col = 0, 0\n        for _ in range(len(encrypted_text)):\n            if row == 0 or row == rails - 1:\n                direction = -direction\n\n            plain_text += fence[row][col]\n            col += 1\n            row += direction\n\n        return plain_text", "dependencies": {"Standalone": true, "lib_dependencies": [], "field_dependencies": [], "method_dependencies": []}}], "test_cases": "import unittest\n\n\nclass DecryptionUtilsTestCaesarDecipher(unittest.TestCase):\n    def test_caesar_decipher(self):\n        d = DecryptionUtils('key')\n        self.assertEqual(d.caesar_decipher('ifmmp', 1), 'hello')\n\n    def test_caesar_decipher_2(self):\n        d = DecryptionUtils('key')\n        self.assertEqual(d.caesar_decipher('bcdyza', 27), 'abcxyz')\n\n    def test_caesar_decipher_3(self):\n        d = DecryptionUtils('key')\n        self.assertEqual(d.caesar_decipher('bcd', 0), 'bcd')\n\n    def test_caesar_decipher_4(self):\n        d = DecryptionUtils('key')\n        self.assertEqual(d.caesar_decipher('bcd', 26), 'bcd')\n\n    def test_caesar_decipher_5(self):\n        d = DecryptionUtils('key')\n        self.assertEqual(d.caesar_decipher('bcd', -26), 'bcd')\n\n    def test_caesar_decipher_6(self):\n        d = DecryptionUtils('key')\n        self.assertEqual(d.caesar_decipher('IFMMP', 1), 'HELLO')\n\n    def test_caesar_decipher_7(self):\n        d = DecryptionUtils('key')\n        self.assertEqual(d.caesar_decipher('123', 1), '123')\n\n\nclass DecryptionUtilsTestVigenereDecipher(unittest.TestCase):\n    def test_vigenere_decipher(self):\n        d = DecryptionUtils('key')\n        self.assertEqual(d.vigenere_decipher('ifmmp'), 'ybocl')\n\n    def test_vigenere_decipher_2(self):\n        d = DecryptionUtils('key')\n        self.assertEqual(d.vigenere_decipher('rijvs'), 'hello')\n\n    def test_vigenere_decipher_3(self):\n        d = DecryptionUtils('longkey')\n        self.assertEqual(d.vigenere_decipher('LpPjOjE'), 'AbCdEfG')\n\n    def test_vigenere_decipher_4(self):\n        d = DecryptionUtils('key')\n        self.assertEqual(d.vigenere_decipher('bcd'), 'ryf')\n\n    def test_vigenere_decipher_5(self):\n        d = DecryptionUtils('key')\n        self.assertEqual(d.vigenere_decipher('bcdaa'), 'ryfqw')\n\n    def test_vigenere_decipher_6(self):\n        d = DecryptionUtils('key')\n        self.assertEqual(d.vigenere_decipher('123'), '123')\n\n\nclass DecryptionUtilsTestRailFenceDecipher(unittest.TestCase):\n    def test_rail_fence_decipher(self):\n        d = DecryptionUtils('key')\n        self.assertEqual(d.rail_fence_decipher('Hoo!el,Wrdl l', 3), 'Hello, World!')\n\n    def test_rail_fence_decipher_2(self):\n        d = DecryptionUtils('key')\n        self.assertEqual(d.rail_fence_decipher('Hoo!el,Wrdl l', 4), 'H!W reoldll,o')\n\n    def test_rail_fence_decipher_3(self):\n        d = DecryptionUtils('key')\n        self.assertEqual(d.rail_fence_decipher('Hoo!el,Wrdl l', 5), 'Holr d,!oeWll')\n\n    def test_rail_fence_decipher_4(self):\n        d = DecryptionUtils('key')\n        self.assertEqual(d.rail_fence_decipher('Hoo!el,Wrdl l', 6), 'Holrll d,!oeW')\n\n    def test_rail_fence_decipher_5(self):\n        d = DecryptionUtils('key')\n        self.assertEqual(d.rail_fence_decipher('Hoo!el,Wrdl l', 7), 'Hoe,rll dWl!o')\n\n\nclass DecryptionUtilsTestMain(unittest.TestCase):\n    def test_main(self):\n        d = DecryptionUtils('key')\n        self.assertEqual(d.caesar_decipher('ifmmp', 1), 'hello')\n        self.assertEqual(d.vigenere_decipher('ifmmp'), 'ybocl')\n        self.assertEqual(d.rail_fence_decipher('Hoo!el,Wrdl l', 3), 'Hello, World!')", "solutions": ["class DecryptionUtils:\n    def __init__(self, key):\n        self.key = key\n    \n    def caesar_decipher(self, ciphertext, shift):\n        plaintext = \"\"\n        for char in ciphertext:\n            if char.isalpha():\n                if char.isupper():\n                    ascii_offset = 65\n                else:\n                    ascii_offset = 97\n                shifted_char = chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n                plaintext += shifted_char\n            else:\n                plaintext += char\n        return plaintext\n    \n    def vigenere_decipher(self, ciphertext):\n        decrypted_text = \"\"\n        key_index = 0\n        for char in ciphertext:\n            if char.isalpha():\n                shift = ord(self.key[key_index % len(self.key)].lower()) - ord('a')\n                decrypted_char = chr((ord(char.lower()) - ord('a') - shift) % 26 + ord('a'))\n                decrypted_text += decrypted_char.upper() if char.isupper() else decrypted_char\n                key_index += 1\n            else:\n                decrypted_text += char\n        return decrypted_text\n    \n    def rail_fence_decipher(self, encrypted_text, rails):\n        fence = [['\\n' for _ in range(len(encrypted_text))] for _ in range(rails)]\n        direction = -1\n        row, col = 0, 0\n\n        for _ in range(len(encrypted_text)):\n            if row == 0 or row == rails - 1:\n                direction = -direction\n\n            fence[row][col] = ''\n            col += 1\n            row += direction\n\n        index = 0\n        for i in range(rails):\n            for j in range(len(encrypted_text)):\n                if fence[i][j] == '':\n                    fence[i][j] = encrypted_text[index]\n                    index += 1\n\n        plain_text = ''\n        direction = -1\n        row, col = 0, 0\n        for _ in range(len(encrypted_text)):\n            if row == 0 or row == rails - 1:\n                direction = -direction\n\n            plain_text += fence[row][col]\n            col += 1\n            row += direction\n\n        return plain_text"], "task": "class_eval", "split": "test", "transformation_type": "vanilla", "import_statement": [], "test_classes": ["DecryptionUtilsTestCaesarDecipher", "DecryptionUtilsTestVigenereDecipher", "DecryptionUtilsTestRailFenceDecipher", "DecryptionUtilsTestMain"]}