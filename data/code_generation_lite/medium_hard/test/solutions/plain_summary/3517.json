{"qid": "3517", "split": "test", "solutions": "class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        # Initialize the graph with the initial roads\n        graph = {i: [i + 1] for i in range(n - 1)}\n        \n        # Initialize the distance dictionary\n        distances = {i: float('inf') for i in range(n)}\n        distances[0] = 0\n        \n        # Function to find the shortest distance using BFS\n        def bfs(start, end):\n            queue = deque([(start, 0)])\n            visited = set()\n            \n            while queue:\n                node, dist = queue.popleft()\n                \n                if node == end:\n                    return dist\n                \n                if node in visited:\n                    continue\n                \n                visited.add(node)\n                \n                for neighbor in graph.get(node, []):\n                    queue.append((neighbor, dist + 1))\n            \n            return float('inf')\n        \n        answer = []\n        \n        # Process each query\n        for u, v in queries:\n            # Add the new road\n            if u in graph:\n                graph[u].append(v)\n            else:\n                graph[u] = [v]\n            \n            # Update the distance from 0 to n - 1\n            distances[n - 1] = bfs(0, n - 1)\n            \n            answer.append(distances[n - 1])\n        \n        return answer", "starter": "class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        "}