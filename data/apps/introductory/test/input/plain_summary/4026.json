{"qid": 4026, "orig_input": "Masha has $n$ types of tiles of size $2 \\times 2$. Each cell of the tile contains one integer. Masha has an infinite number of tiles of each type.\n\nMasha decides to construct the square of size $m \\times m$ consisting of the given tiles. This square also has to be a symmetric with respect to the main diagonal matrix, and each cell of this square has to be covered with exactly one tile cell, and also sides of tiles should be parallel to the sides of the square. All placed tiles cannot intersect with each other. Also, each tile should lie inside the square. See the picture in Notes section for better understanding.\n\nSymmetric with respect to the main diagonal matrix is such a square $s$ that for each pair $(i, j)$ the condition $s[i][j] = s[j][i]$ holds. I.e. it is true that the element written in the $i$-row and $j$-th column equals to the element written in the $j$-th row and $i$-th column.\n\nYour task is to determine if Masha can construct a square of size $m \\times m$ which is a symmetric matrix and consists of tiles she has. Masha can use any number of tiles of each type she has to construct the square. Note that she can not rotate tiles, she can only place them in the orientation they have in the input.\n\nYou have to answer $t$ independent test cases.\n\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 100$) \u2014 the number of test cases. Then $t$ test cases follow.\n\nThe first line of the test case contains two integers $n$ and $m$ ($1 \\le n \\le 100$, $1 \\le m \\le 100$) \u2014 the number of types of tiles and the size of the square Masha wants to construct.\n\nThe next $2n$ lines of the test case contain descriptions of tiles types. Types of tiles are written one after another, each type is written on two lines. \n\nThe first line of the description contains two positive (greater than zero) integers not exceeding $100$ \u2014 the number written in the top left corner of the tile and the number written in the top right corner of the tile of the current type. The second line of the description contains two positive (greater than zero) integers not exceeding $100$ \u2014 the number written in the bottom left corner of the tile and the number written in the bottom right corner of the tile of the current type.\n\nIt is forbidden to rotate tiles, it is only allowed to place them in the orientation they have in the input.\n\n\n-----Output-----\n\nFor each test case print the answer: \"YES\" (without quotes) if Masha can construct the square of size $m \\times m$ which is a symmetric matrix. Otherwise, print \"NO\" (withtout quotes).\n\n\n-----Example-----\nInput\n6\n3 4\n1 2\n5 6\n5 7\n7 4\n8 9\n9 8\n2 5\n1 1\n1 1\n2 2\n2 2\n1 100\n10 10\n10 10\n1 2\n4 5\n8 4\n2 2\n1 1\n1 1\n1 2\n3 4\n1 2\n1 1\n1 1\n\nOutput\nYES\nNO\nYES\nNO\nYES\nYES\n\n\n\n-----Note-----\n\nThe first test case of the input has three types of tiles, they are shown on the picture below. [Image] \n\nMasha can construct, for example, the following square of size $4 \\times 4$ which is a symmetric matrix: $\\left. \\begin{array}{|c|c|c|c|} \\hline 5 & {7} & {8} & {9} \\\\ \\hline 7 & {4} & {9} & {8} \\\\ \\hline 8 & {9} & {5} & {7} \\\\ \\hline 9 & {8} & {7} & {4} \\\\ \\hline \\end{array} \\right.$", "input": "Determine if a symmetric square matrix can be constructed from given 2x2 tiles without rotation.", "test_cases": {"inputs": ["6\n3 4\n1 2\n5 6\n5 7\n7 4\n8 9\n9 8\n2 5\n1 1\n1 1\n2 2\n2 2\n1 100\n10 10\n10 10\n1 2\n4 5\n8 4\n2 2\n1 1\n1 1\n1 2\n3 4\n1 2\n1 1\n1 1\n", "1\n2 2\n1 2\n3 4\n1 3\n2 4\n", "1\n2 10\n1 2\n3 4\n1 3\n2 4\n", "1\n1 2\n2 5\n5 3\n", "1\n1 2\n1 2\n2 2\n", "1\n1 2\n7 8\n8 9\n", "1\n2 2\n1 4\n3 2\n1 3\n4 2\n", "2\n1 2\n2 4\n4 3\n1 2\n2 3\n4 5\n", "1\n1 2\n4 7\n7 5\n", "1\n1 2\n1 2\n2 1\n", "1\n1 2\n2 69\n69 3\n", "1\n1 2\n1 3\n3 2\n", "1\n1 2\n4 2\n2 3\n", "1\n1 3\n1 1\n1 1\n", "1\n8 2\n3 5\n10 7\n3 3\n7 9\n5 9\n7 4\n6 8\n3 8\n7 6\n1 6\n5 7\n9 5\n3 8\n1 9\n3 1\n1 10\n", "1\n2 4\n1 2\n3 4\n1 3\n2 4\n", "1\n1 2\n4 1\n1 2\n", "1\n1 2\n1 2\n2 3\n", "1\n2 2\n1 2\n3 4\n1 2\n2 3\n", "1\n2 4\n1 5\n3 1\n1 3\n5 1\n", "1\n1 2\n3 2\n2 5\n", "1\n1 2\n7 8\n8 6\n", "1\n2 2\n3 5\n6 3\n3 6\n5 3\n", "1\n2 4\n3 2\n4 3\n3 4\n2 3\n", "1\n1 1\n1 2\n1 1\n", "1\n1 2\n1 2\n2 4\n", "1\n2 2\n3 5\n6 4\n3 6\n5 4\n", "1\n1 2\n1 2\n1 2\n", "1\n1 2\n1 5\n5 7\n", "1\n2 2\n2 5\n6 8\n2 6\n5 8\n", "1\n1 2\n2 1\n1 3\n", "1\n3 6\n3 3\n4 3\n3 4\n3 3\n3 3\n1 3\n", "1\n2 2\n1 2\n1 1\n1 1\n2 1\n", "1\n2 4\n1 2\n3 1\n1 3\n2 1\n", "1\n1 2\n5 3\n4 8\n", "1\n2 2\n9 1\n2 3\n9 2\n1 3\n", "1\n2 18\n1 2\n3 4\n1 3\n2 4\n", "1\n3 4\n1 2\n3 4\n1 3\n2 4\n9 10\n11 12\n", "1\n1 2\n99 3\n99 3\n", "1\n2 2\n1 1\n1 2\n1 2\n3 4\n", "1\n1 2\n2 1\n1 5\n", "1\n2 6\n1 2\n3 4\n1 3\n2 4\n", "1\n1 2\n5 7\n7 4\n", "1\n2 2\n1 2\n3 1\n1 3\n2 1\n", "1\n1 2\n2 6\n6 7\n", "1\n1 2\n1 1\n1 2\n", "1\n2 2\n1 2\n3 4\n1 2\n3 4\n", "1\n1 4\n6 6\n6 5\n", "1\n1 1\n1 1\n1 1\n", "1\n1 2\n4 6\n6 5\n", "1\n2 2\n3 6\n5 4\n3 5\n6 4\n", "1\n2 8\n1 2\n3 4\n1 2\n2 1\n", "1\n2 2\n1 2\n3 4\n1 4\n3 2\n", "1\n1 8\n1 1\n3 3\n", "1\n2 8\n1 2\n3 4\n1 3\n2 4\n", "1\n2 4\n1 3\n2 1\n1 2\n3 1\n"], "outputs": ["YES\nNO\nYES\nNO\nYES\nYES\n", "NO\n", "NO\n", "YES\n", "YES\n", "YES\n", "NO\n", "YES\nNO\n", "YES\n", "YES\n", "YES\n", "YES\n", "YES\n", "NO\n", "YES\n", "NO\n", "YES\n", "YES\n", "YES\n", "NO\n", "YES\n", "YES\n", "NO\n", "NO\n", "NO\n", "YES\n", "NO\n", "NO\n", "YES\n", "NO\n", "YES\n", "NO\n", "NO\n", "NO\n", "NO\n", "NO\n", "NO\n", "NO\n", "NO\n", "YES\n", "YES\n", "NO\n", "YES\n", "NO\n", "YES\n", "YES\n", "NO\n", "YES\n", "NO\n", "YES\n", "NO\n", "YES\n", "NO\n", "NO\n", "NO\n", "NO\n"]}, "solutions": "[\"def is_symmetric(a):\\n\\treturn a[0][1]==a[1][0]\\nfor _ in range(int(input())):\\n\\tdef two_ints():\\n\\t\\treturn list(map(int,input().split()))\\n\\tn, m = map(int,input().split())\\n\\ttiles = [[two_ints(),two_ints()] for i in range(n)]\\n\\tprint(\\\"YES\\\" if m%2==0 and any([is_symmetric(tile) for tile in tiles]) else \\\"NO\\\")\", \"import sys\\n\\n    \\ndef main():\\n    #n = iinput()\\n    #k = iinput() \\n    #m = iinput() \\n    #n = int(sys.stdin.readline().strip()) \\n    #n, k = rinput()\\n    #n, m = rinput()\\n    #m, k = rinput()\\n    #n, k, m = rinput()\\n    #n, m, k = rinput()\\n    #k, n, m = rinput()\\n    #k, m, n = rinput() \\n    #m, k, n = rinput()\\n    #m, n, k = rinput()\\n    #n, t = map(int, sys.stdin.readline().split())\\n    #q = list(map(int, sys.stdin.readline().split()))\\n    #q = linput()\\n    n, m = list(map(int, sys.stdin.readline().split()))\\n    q = []\\n    for i in range(n):\\n        q.append([list(map(int, sys.stdin.readline().split())), list(map(int, sys.stdin.readline().split()))])\\n    if m % 2:\\n        print(\\\"NO\\\")\\n    else:\\n        fl = 0\\n        for i in range(n):\\n            if q[i][0][1] == q[i][1][0]:\\n                fl = 1\\n                break\\n        if fl:\\n            print(\\\"YES\\\")\\n        else:\\n            print(\\\"NO\\\")\\n    \\n    \\n           \\n        \\n            \\n    \\n    \\n    \\n    \\n    \\n    \\n            \\n                \\n        \\n    \\n            \\n        \\n\\n            \\n        \\n    \\n                \\n    \\n    \\n    \\n            \\n    \\n        \\n    \\n\\nfor i in range(int(sys.stdin.readline().strip()) ):\\n    main()\\n    \\n\", \"def solve():\\n    n, m = list(map(int, input().split()))\\n    \\n    found = False\\n    for _ in range(n):\\n        a, b = list(map(int, input().split()))\\n        c, d = list(map(int, input().split()))\\n        if b==c:\\n            found = True\\n    \\n    if m%2==1:\\n        return False\\n    if found:\\n        return True\\n    return False\\n    \\n\\nt = int(input())\\n\\nfor _ in range(t):\\n    if solve():\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n\", \"def solve():\\n    n, m = list(map(int, input().split()))\\n    sym = False\\n    for i in range(n):\\n        x, y = list(map(int, input().split()))\\n        z, w = list(map(int, input().split()))\\n        if y == z:\\n            sym = True\\n    if m % 2 == 0 and sym:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n    return\\n\\n\\ndef main():\\n    T = int(input())\\n    for i in range(T):\\n        solve()\\n    return\\n\\n\\ndef __starting_point():\\n    main()\\n\\n\\n__starting_point()\", \"from collections import *\\nfrom heapq import *\\nfrom math import *\\n\\n\\nt = int(input())\\nwhile t:\\n    t -= 1\\n    # n = int(input())\\n    flag= False\\n    n,m =[int(x) for x in input().split()]\\n    for i in range(n):\\n        a,b = [int(x) for x in input().split()]\\n        c,d = [int(x) for x in input().split()]\\n        if b == c:\\n            flag = True\\n    if m%2:\\n        print(\\\"NO\\\")\\n    elif flag:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\", \"# for _ in range(1):\\nfor _ in range(int(input())):\\n    n, m = map(int, input().split())\\n    flag = 0\\n\\n    for i in range(n):\\n        a, b = map(int, input().split())\\n        c, d = map(int, input().split())\\n        if b == c:\\n            flag = 1\\n    if m % 2 == 1:\\n        flag = 0\\n    if flag:\\n        print('YES')\\n    else:\\n        print('NO')\", \"for _ in range(int(input())):\\n    n, m = tuple(map(int, input().split()))\\n    res = False\\n    for i in range(n):\\n        a, b = tuple(map(int, input().split()))\\n        c, d = tuple(map(int, input().split()))\\n        if b == c:\\n            res = True\\n\\n    if m % 2 == 0 and res:\\n        print('YES')\\n    else:\\n        print('NO')\\n\", \"t = int(input())\\nfor j in range(t):\\n    n, m = list(map(int, input().split()))\\n    bol = False\\n    for i in range(n):\\n        a, b = list(map(int, input().split()))\\n        c, d = list(map(int, input().split()))\\n        if b == c:\\n            bol = True\\n    if m % 2 == 0 and bol:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n\", \"for i in ' '*int(input()):\\n    n,m=map(int,input().split())\\n    L=[]\\n    state=False\\n    for i in ' '*n:\\n        a,b=map(int,input().split())\\n        c,d=map(int,input().split())\\n        if b==c:state=True\\n    if m%2:state=False\\n    print(['NO','YES'][state])\", \"import sys\\nreadline = sys.stdin.readline\\n\\nT = int(readline())\\nAns = [None]*T\\n\\nfor qu in range(T):\\n    N, M = map(int, readline().split())\\n    ans = 'NO'\\n    for _ in range(N):\\n        a, b = map(int, readline().split())\\n        c, d = map(int, readline().split())\\n        if b == c:\\n            ans = 'YES'\\n    \\n    if M&1:\\n        Ans[qu] = 'NO'\\n        continue\\n    Ans[qu] = ans\\n    \\nprint('\\\\n'.join(Ans))\", \"from bisect import bisect_left as bl\\nfrom bisect import bisect_right as br\\nfrom heapq import heappush,heappop,heapify\\nimport math\\nfrom collections import *\\nfrom functools import reduce,cmp_to_key\\nimport sys\\ninput = sys.stdin.readline\\n\\nfrom itertools import accumulate\\nfrom functools import lru_cache\\n\\nM = mod = 998244353\\ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\\ndef inv_mod(n):return pow(n, mod - 2, mod)\\n \\ndef li():return [int(i) for i in input().rstrip('\\\\n').split()]\\ndef st():return input().rstrip('\\\\n')\\ndef val():return int(input().rstrip('\\\\n'))\\ndef li2():return [i for i in input().rstrip('\\\\n')]\\ndef li3():return [int(i) for i in input().rstrip('\\\\n')]\\n\\n\\nfor _ in range(val()):\\n    n, m = li()\\n    l = []\\n    middle = 0\\n    for i in range(n):\\n        a, b = li()\\n        c, d = li()\\n        l.append([a, b, c, d])\\n        if b == c:middle = 1\\n    \\n    if m & 1 or not middle:\\n        print('NO')\\n        continue\\n    \\n    done = 0\\n    for i in range(len(l)):\\n        for j in range(len(l)):\\n            if l[i][1] == l[j][2] and l[j][1] == l[i][2]:\\n                done = 1\\n    print('YES' if done else 'NO')\", \"from sys import stdin, stdout\\ninput = stdin.readline\\nfrom collections import defaultdict as dd\\nimport math\\ndef geti(): return list(map(int, input().strip().split()))\\ndef getl(): return list(map(int, input().strip().split()))\\ndef gets(): return input()\\ndef geta(): return int(input())\\ndef print_s(s): stdout.write(s+'\\\\n')\\n\\ndef solve():\\n    for _ in range(geta()):\\n        n,m=geti()\\n        ok=False\\n        for i in range(n):\\n            a,b=geti()\\n            c,d=geti()\\n            if b==c:\\n                ok=True\\n        if ok and m&1==0:\\n            print(\\\"YES\\\")\\n        else:\\n            print(\\\"NO\\\")\\n\\n\\n\\ndef __starting_point():\\n    solve()\\n\\n__starting_point()\", \"\\nfrom sys import stdin\\n\\ntt = int(stdin.readline())\\n\\nfor loop in range(tt):\\n\\n    n,m = map(int,stdin.readline().split())\\n    ans = \\\"NO\\\"\\n\\n    for i in range(n):\\n\\n        a,b = map(int,stdin.readline().split())\\n        c,d = map(int,stdin.readline().split())\\n\\n        \\n        if b == c and m % 2 == 0:\\n            ans = \\\"YES\\\"\\n\\n    print (ans)\", \"t = int(input())\\nfor _ in range(t):\\n    n, m = map(int, input().split())\\n    diag = False\\n    for _ in range(n):\\n        a, b = map(int, input().split())\\n        c, d = map(int, input().split())\\n        if b == c:\\n            diag = True\\n    if m % 2 == 1:\\n        print(\\\"NO\\\")\\n    else:\\n        print(\\\"YES\\\" if diag else \\\"NO\\\")\", \"import sys, math\\n\\n\\ninput = lambda: sys.stdin.readline().rstrip()\\n\\n\\ndef gcd(n, f):\\n    if n == 0 or f == 0:\\n        return max(n, f)\\n    if n > f:\\n        return gcd(n % f, f)\\n    else:\\n        return gcd(f % n, n)\\n\\n\\ndef division_with_remainder_up(pp, ppp):\\n    return (pp + ppp - 1) // ppp\\n\\n\\nfor _ in range(int(input())):\\n    n, m = list(map(int, input().split()))\\n    mas = []\\n    ans = \\\"NO\\\"\\n    for i in range(n):\\n        a, b = list(map(int, input().split()))\\n        v, c = list(map(int, input().split()))\\n        if  b == v:\\n            ans = \\\"YES\\\"\\n    if m % 2 == 0:\\n        print(ans)\\n    else:\\n        print(\\\"NO\\\")\\n\", \"for tc in range(int(input())):\\n    mainFlag = False\\n    pairFlag = False\\n    n, m = map(int, input().split())\\n    tiles = set()\\n    for _ in range(n):\\n        a, b = map(int, input().split())\\n        c, d = map(int, input().split())\\n        tile = (a, b, c, d)\\n        tiles.add(tile)\\n        if b == c:\\n            mainFlag = True\\n            pairFlag = True\\n        if (a, c, b, d) in tiles:\\n            pairFlag = True\\n    if mainFlag and pairFlag and m % 2 == 0:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\", \"from math import *\\nfor _ in range(int(input())):\\n    n, m = list(map(int, input().split()))\\n    yes = 0\\n    for i in range(n):\\n        b = [list(map(int, input().split())), list(map(int, input().split()))]\\n        if b[0][1] == b[1][0]:\\n            yes = 1\\n    if m % 2 == 1:\\n        print('NO')\\n    elif yes == 0:\\n        print('NO')\\n    else:\\n        print('YES')\\n\\n\", \"for _ in range(int(input())):\\n    n, m = list(map(int, input().split()))\\n    sim = False\\n    for i in range(n):\\n        a, b = list(map(int, input().split()))\\n        c, d = list(map(int, input().split()))\\n        if c == b:\\n            sim = True\\n    if m % 2 == 1:\\n        print('NO')\\n    else:\\n        if sim:\\n            print('YES')\\n        else:\\n            print('NO')\\n\", \"for _ in range (int(input())):\\n    n,m=map(int,input().split())\\n    arr=[]\\n    for i in range(n):\\n        a,b=map(int,input().split())\\n        c,d=map(int,input().split())\\n        arr.append((a,b,c,d))\\n    if(m%2==1):print(\\\"NO\\\")\\n    else:\\n        b,x=0,1\\n        for i in range(n):\\n            if(arr[i][1]==arr[i][2]):b=1\\n        if(b==0):x=0\\n        b=0\\n        if(m>=4):\\n            for i in range(n):\\n                for j in range(n):\\n                    if(arr[i][1]==arr[j][2] and arr[i][2]==arr[j][1] and arr[i][0]==arr[j][0] and arr[i][3]==arr[j][3]):b=1\\n            if(b==0):x=0\\n        if(x==0):print(\\\"NO\\\")\\n        else:print(\\\"YES\\\")\", \"# cook your dish here\\n# code\\n#    ___________________________________\\n#   |                                   |\\n#   |                                   |\\n#   |        _,     _   _     ,_        |\\n#   |    .-'` /     \\\\'-'/     \\\\ `'-.    |\\n#   |   /    |      |   |      |    \\\\   |\\n#   |  ;      \\\\_  _/     \\\\_  _/      ;  |\\n#   | |         ``         ``         | |\\n#   | |                               | |\\n#   |  ;    .-.   .-.   .-.   .-.    ;  |\\n#   |   \\\\  (   '.'   \\\\ /   '.'   )  /   |\\n#   |    '-.;         V         ;.-'    |\\n#   |        `                 `        |\\n#   |                                   |\\n#   |___________________________________|\\n#   |                                   |\\n#   |  Author      :   Ramzz            |\\n#   |  Created On  :   21-07-2020       |\\n#   |___________________________________|\\n#\\n#    _ __ __ _ _ __ ___  ________\\n#   | '__/ _` | '_ ` _ \\\\|_  /_  /\\n#   | | | (_| | | | | | |/ / / / \\n#   |_|  \\\\__,_|_| |_| |_/___/___|\\n#\\n\\nimport math\\nimport collections\\nfrom sys import stdin,stdout,setrecursionlimit\\nfrom bisect import bisect_left as bsl\\nfrom bisect import bisect_right as bsr\\nimport heapq as hq\\nsetrecursionlimit(2**20)\\n\\nt = 1\\nt = int(stdin.readline())\\n\\nfor _ in range(t):\\n    #n = int(stdin.readline())\\n    #s = stdin.readline().strip('\\\\n')\\n    n,m = list(map(int, stdin.readline().rstrip().split()))\\n    chk = False\\n    for i in range(n):\\n        r1 = list(map(int, stdin.readline().rstrip().split()))\\n        r2 = list(map(int, stdin.readline().rstrip().split()))\\n        \\n        if(r1[1]==r2[0]):\\n            chk = True\\n        \\n    if(m%2==1):\\n        print('NO')\\n        continue\\n    if(chk):\\n        print('YES')\\n    else:\\n        print('NO')\\n    \\n    \\n\", \"t = int(input())\\nfor test in range(1, t+1):\\n    n, m = [int(i) for i in input().split()]\\n    flag = False\\n    for i in range(n):\\n        a, b = [int(j) for j in input().split()]\\n        c, d = [int(j) for j in input().split()]\\n        if b == c:\\n            flag = True\\n    if flag and m%2 == 0:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\", \"3\\nimport sys\\ninput = lambda: sys.stdin.readline().strip()\\nfor _ in range(int(input())):\\n    n, m = [int(x) for x in input().split()]\\n    tiles = [[[int(x) for x in input().split()] for _ in range(2)] for i in range(n)]\\n    print('YES' if m % 2 == 0 and any(tile[0][1] == tile[1][0] for tile in tiles) else 'NO')\\n\", \"t=int(input())\\nfor you in range(t):\\n    l=input().split()\\n    n=int(l[0])\\n    m=int(l[1])\\n    l=[]\\n    col=dict()\\n    row=dict()\\n    found=0\\n    done=0\\n    for i in range(n):\\n        lo=input().split()\\n        a=int(lo[0])\\n        b=int(lo[1])\\n        lo=input().split()\\n        c=int(lo[0])\\n        d=int(lo[1])\\n        if(b==c):\\n            found=1\\n    if(found==1 and m%2==0):\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n\", \"from functools import lru_cache\\nfrom sys import stdin, stdout\\nimport sys\\nfrom math import *\\n\\n# from collections import deque\\n# sys.setrecursionlimit(int(2e5+10))\\ninput = stdin.readline\\n# print = stdout.write\\n# dp=[-1]*100000\\n\\nfor __ in range(int(input())):\\n\\tn,m=list(map(int,input().split()))\\n\\tans=\\\"NO\\\"\\n\\tfor i in range(n):\\n\\t\\ta,b=list(map(int,input().split()))\\n\\t\\tx,y=list(map(int,input().split()))\\n\\t\\tif(x==b):\\n\\t\\t\\tans=\\\"YES\\\"\\n\\tif(m%2==1):\\n\\t\\tprint(\\\"NO\\\")\\n\\telse:\\n\\t\\tprint(ans)\\n\"]", "task": "apps", "difficulty": "introductory", "split": "test", "transformation_type": "plain_summary"}