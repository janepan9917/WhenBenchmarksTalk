{"qid": 4016, "orig_input": "You are given a string $t$ consisting of $n$ lowercase Latin letters and an integer number $k$.\n\nLet's define a substring of some string $s$ with indices from $l$ to $r$ as $s[l \\dots r]$.\n\nYour task is to construct such string $s$ of minimum possible length that there are exactly $k$ positions $i$ such that $s[i \\dots i + n - 1] = t$. In other words, your task is to construct such string $s$ of minimum possible length that there are exactly $k$ substrings of $s$ equal to $t$.\n\nIt is guaranteed that the answer is always unique.\n\n\n-----Input-----\n\nThe first line of the input contains two integers $n$ and $k$ ($1 \\le n, k \\le 50$) \u2014 the length of the string $t$ and the number of substrings.\n\nThe second line of the input contains the string $t$ consisting of exactly $n$ lowercase Latin letters.\n\n\n-----Output-----\n\nPrint such string $s$ of minimum possible length that there are exactly $k$ substrings of $s$ equal to $t$.\n\nIt is guaranteed that the answer is always unique.\n\n\n-----Examples-----\nInput\n3 4\naba\n\nOutput\nababababa\n\nInput\n3 2\ncat\n\nOutput\ncatcat", "input": "Construct the shortest string containing exactly k occurrences of a given substring.", "test_cases": {"inputs": ["3 4\naba\n", "3 2\ncat\n", "1 1\na\n", "1 50\nq\n", "20 3\nsfrpmsfrpmsfrpmsfrpm\n", "47 1\njjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj\n", "25 24\nkyzdckyzdckyzdckyzdckyzdc\n", "4 25\nlclc\n", "5 34\nabcab\n", "8 3\nabcaabca\n", "4 4\naaaa\n", "9 2\ncccababbc\n", "3 6\naaa\n", "3 5\naaa\n", "24 20\nbaacaabccacbcbccccbbcabb\n", "6 2\nabcaba\n", "6 3\naabbaa\n", "6 3\nabaaba\n", "3 4\naaa\n", "4 3\nabaa\n", "8 2\ncaacdcaa\n", "6 3\nabcaba\n", "8 4\ncababbcc\n", "4 2\nabac\n", "4 2\nabaa\n", "11 2\naaabaacdaaa\n", "7 2\nabcabca\n", "18 9\naabaabcbbabaaccbac\n", "9 2\nababbaaba\n", "5 4\naabaa\n", "4 5\nadaa\n", "19 22\ncabacbbbaabccabaaca\n", "2 4\naa\n", "5 2\nzxxzz\n", "2 2\noo\n", "10 2\nababaababa\n", "2 2\naa\n", "6 2\nabbaba\n", "11 2\ncaaacddcaaa\n", "4 2\nabba\n", "5 3\naaaba\n", "4 3\naaaa\n", "5 2\nabaca\n", "5 4\naaaaa\n", "4 2\nxxxb\n", "4 5\nabaa\n", "5 3\naaaaa\n", "7 2\nabcabcc\n", "8 4\nbabbabab\n", "4 2\naaab\n", "3 1\naab\n", "3 2\naab\n", "7 4\naaaabba\n", "9 2\naabaaaaba\n", "4 2\naaba\n", "3 2\nabb\n", "3 2\naaa\n", "9 2\nbaabbaabb\n", "9 4\nbbaaabbab\n", "11 3\nabracadabra\n", "2 1\naa\n", "6 4\ncccacc\n", "6 12\nhmkkhh\n", "3 1\nabb\n", "2 2\nab\n", "15 27\nzteltxyxqqwgztz\n", "9 3\naaaabcaaa\n", "3 1\naba\n", "4 2\naabb\n", "9 2\nbabbabbab\n", "5 3\nbbcbb\n", "3 3\naaa\n", "4 2\nakaa\n", "5 2\naaaba\n", "5 5\nabbab\n"], "outputs": ["ababababa\n", "catcat\n", "a\n", "qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\n", "sfrpmsfrpmsfrpmsfrpmsfrpmsfrpm\n", "jjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj\n", "kyzdckyzdckyzdckyzdckyzdckyzdckyzdckyzdckyzdckyzdckyzdckyzdckyzdckyzdckyzdckyzdckyzdckyzdckyzdckyzdckyzdckyzdckyzdckyzdckyzdckyzdckyzdckyzdc\n", "lclclclclclclclclclclclclclclclclclclclclclclclclclc\n", "abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcab\n", "abcaabcaabcaabca\n", "aaaaaaa\n", "cccababbcccababbc\n", "aaaaaaaa\n", "aaaaaaa\n", "baacaabccacbcbccccbbcabbaacaabccacbcbccccbbcabbaacaabccacbcbccccbbcabbaacaabccacbcbccccbbcabbaacaabccacbcbccccbbcabbaacaabccacbcbccccbbcabbaacaabccacbcbccccbbcabbaacaabccacbcbccccbbcabbaacaabccacbcbccccbbcabbaacaabccacbcbccccbbcabbaacaabccacbcbccccbbcabbaacaabccacbcbccccbbcabbaacaabccacbcbccccbbcabbaacaabccacbcbccccbbcabbaacaabccacbcbccccbbcabbaacaabccacbcbccccbbcabbaacaabccacbcbccccbbcabbaacaabccacbcbccccbbcabbaacaabccacbcbccccbbcabbaacaabccacbcbccccbbcabb\n", "abcababcaba\n", "aabbaabbaabbaa\n", "abaabaabaaba\n", "aaaaaa\n", "abaabaabaa\n", "caacdcaacdcaa\n", "abcababcababcaba\n", "cababbccababbccababbccababbcc\n", "abacabac\n", "abaabaa\n", "aaabaacdaaabaacdaaa\n", "abcabcabca\n", "aabaabcbbabaaccbacaabaabcbbabaaccbacaabaabcbbabaaccbacaabaabcbbabaaccbacaabaabcbbabaaccbacaabaabcbbabaaccbacaabaabcbbabaaccbacaabaabcbbabaaccbacaabaabcbbabaaccbac\n", "ababbaababbaaba\n", "aabaabaabaabaa\n", "adaadaadaadaadaa\n", "cabacbbbaabccabaacabacbbbaabccabaacabacbbbaabccabaacabacbbbaabccabaacabacbbbaabccabaacabacbbbaabccabaacabacbbbaabccabaacabacbbbaabccabaacabacbbbaabccabaacabacbbbaabccabaacabacbbbaabccabaacabacbbbaabccabaacabacbbbaabccabaacabacbbbaabccabaacabacbbbaabccabaacabacbbbaabccabaacabacbbbaabccabaacabacbbbaabccabaacabacbbbaabccabaacabacbbbaabccabaacabacbbbaabccabaacabacbbbaabccabaaca\n", "aaaaa\n", "zxxzzxxzz\n", "ooo\n", "ababaababaababa\n", "aaa\n", "abbababbaba\n", "caaacddcaaacddcaaa\n", "abbabba\n", "aaabaaabaaaba\n", "aaaaaa\n", "abacabaca\n", "aaaaaaaa\n", "xxxbxxxb\n", "abaabaabaabaabaa\n", "aaaaaaa\n", "abcabccabcabcc\n", "babbababbababbababbabab\n", "aaabaaab\n", "aab\n", "aabaab\n", "aaaabbaaaabbaaaabbaaaabba\n", "aabaaaabaaaaba\n", "aabaaba\n", "abbabb\n", "aaaa\n", "baabbaabbaabb\n", "bbaaabbabbaaabbabbaaabbabbaaabbab\n", "abracadabracadabracadabra\n", "aa\n", "cccacccacccacccacc\n", "hmkkhhmkkhhmkkhhmkkhhmkkhhmkkhhmkkhhmkkhhmkkhhmkkhhmkkhhmkkhh\n", "abb\n", "abab\n", "zteltxyxqqwgztzteltxyxqqwgztzteltxyxqqwgztzteltxyxqqwgztzteltxyxqqwgztzteltxyxqqwgztzteltxyxqqwgztzteltxyxqqwgztzteltxyxqqwgztzteltxyxqqwgztzteltxyxqqwgztzteltxyxqqwgztzteltxyxqqwgztzteltxyxqqwgztzteltxyxqqwgztzteltxyxqqwgztzteltxyxqqwgztzteltxyxqqwgztzteltxyxqqwgztzteltxyxqqwgztzteltxyxqqwgztzteltxyxqqwgztzteltxyxqqwgztzteltxyxqqwgztzteltxyxqqwgztzteltxyxqqwgztzteltxyxqqwgztz\n", "aaaabcaaaabcaaaabcaaa\n", "aba\n", "aabbaabb\n", "babbabbabbab\n", "bbcbbcbbcbb\n", "aaaaa\n", "akaakaa\n", "aaabaaaba\n", "abbabbabbabbabbab\n"]}, "solutions": "[\"'''input\\n3 4\\naba\\n'''\\nn, k = map(int, input().split())\\nt = input()\\nfor i in range(1, n):\\n\\tif t[i:] == t[:n-i]:\\n\\t\\tprint(t[:i] * k + t[i:])\\n\\t\\tbreak\\nelse:\\n\\tprint(t * k)\", \"n, k = map(int, input().split())\\nt = input()\\n\\ndouble = 0\\nfor i in range(1, n):\\n\\tif t[-i:] == t[:i]:\\n\\t\\tdouble = i\\n\\nprint(t + t[double:] * (k - 1))\", \"n, k = list(map(int,input().split()))\\ns = input()\\ni = 1\\nwhile i < len(s) and s[i:] != s[:n-i]:\\n    i += 1\\nt = s[:i]*k + s[i:]\\nprint(t)\\n\", \"n, k = map(int, input().split())\\ns = input()\\np = [0] * len(s)\\n\\nfor i in range(1, len(s)):\\n    p[i] = p[i - 1]\\n    while p[i] > 0 and s[p[i]] != s[i]:\\n        p[i] = p[p[i] - 1]\\n    if s[p[i]] == s[i]:\\n        p[i] += 1\\n\\nprint(s, end = '')\\nfor i in range(1, k):\\n    for j in range(p[-1], len(s)):\\n        print(s[j], end='')\\nprint()\\n\", \"n, k = map(int, input().split())\\ns = input()\\nmax_pref = 0\\n\\nfor i in range(1, n):\\n  if s[:i] == s[-i:]:\\n    max_pref = i\\n\\nans = s\\nfor i in range(k - 1):\\n  ans += s[max_pref:]\\n\\nprint(ans)\", \"n, k = list(map(int, input().split()))\\nt = input()\\n\\na = -1\\nfor i in range(1, n + 1):\\n    if t.startswith(t[i:]):\\n        a = i\\n        break\\n\\npre = t[:a]\\nans = pre * (k - 1) + t\\n\\nprint(ans)\\n\", \"n, k = list(map(int, input().strip().split()))\\nst = [i for i in input()]\\n\\np = n\\nfor i in range(1, n):\\n    if st[i:] == st[:n - i]:\\n        p = i\\n        break\\n\\nprint(''.join(st) + (''.join(st[n - p:])) * (k - 1))\\n\", \"n,m=list(map(int,input().split()))\\ns=input()\\nx=0\\nfor i in range(1,n):\\n    if s[i::]==s[0:n-i]:\\n        x=n-i\\n        break\\nans=s+s[x::]*(m-1)\\nprint(ans)\\n\", \"\\n\\ninp1 = input().split()\\nn = int(inp1[0])\\nk = int(inp1[1])\\n\\ns = input()\\n\\ndef isGood(l):\\n    if(l==0):\\n        return True\\n    s1 = s[0:l]\\n    s2 = s[n-l:n]\\n    return s1==s2\\n\\nmaxMatch = 0\\n\\nfor i in range(n-1,0,-1):\\n    if isGood(i):\\n        maxMatch = i\\n        break\\n\\nans = \\\"\\\"\\nfor i in range(k):\\n    if(i==0):\\n        ans+=s\\n    else:\\n        ans+=s[maxMatch:n]\\n\\nprint(ans)\\n\", \"s=input().split()\\nn=int(s[0])\\nk=int(s[1])\\ns=input()\\nif n==1:\\n    print(s*k)\\nelif k==1:\\n    print(s)\\nelse:\\n    flag=True\\n    for i in range(1,n):\\n        if s[:-i]==s[i:]:\\n            print(s+s[-i:]*(k-1))\\n            flag=False\\n            break\\n    if flag:\\n        print(s*k)\\n\", \"n,k=map(int,input().split())\\nt=input()\\nfor i in range(n-1):\\n    if t[i+1:n]==t[0:n-i-1]:\\n        print(t+(k-1)*t[n-i-1:n])\\n        break\\nelse:\\n    print(k*t)\", \"n, k = list(map(int, input().split()))\\nt = input()\\na = 0\\nfor i in range(1, n):\\n    if t[i:] == t[:-i]:\\n        a = i\\n        break\\n\\nif not a:\\n    print(t * k)\\nelse:\\n    print(t + t[n-a:]*(k-1))\\n\", \"n,k=list(map(int,input().split()))\\nt=input()\\n\\nfor i in range(n-1,-1,-1):\\n    if t[:i]==t[n-i:]:\\n        #print(t[:i],t[n-i:])\\n        break\\n\\n\\nx=t[i:]\\n\\nfor j in range(k-1):\\n    t=t+x\\n\\n#print(i)\\nprint(t)\\n\", \"n, k = list(map(int,input().split()))\\ns = input()\\n\\nres = n\\nfor i in range(1, n):\\n    if s.startswith(s[i:]):\\n        res = i\\n        break\\noverlap = n - res\\n\\nprint(s + (k-1) * s[overlap:])\", \"n, k = list(map(int, input().split()))\\nt = list(input())\\nfor i in range(1, n + 1):\\n    if t[i:] == t[:n - i]:\\n        s = t[:i] * k\\n        s += t[i:]\\n        break\\nprint(''.join(s))\\n\", \"\\nn, k = list(map(int, input().split()))\\nstring = input()\\n\\nres = None\\nfor i in range(1, n):\\n    if string.startswith(string[i:]):\\n        res = string[:i] * k + string[i:]\\n        break\\n\\nif not res:\\n    print(string * k)\\nelse:\\n    print(res)\\n\\n\", \"n, k = map(int, input().split())\\nt = input()\\nP = [0] * n\\nfor i in range(1, n):\\n    j = P[i - 1]\\n    while t[j] != t[i] and j > 0:\\n        j = P[j - 1]\\n    if t[i] == t[j]:\\n        j += 1\\n    P[i] = j\\n\\nans = t[:(n - P[n - 1])] * k\\nif P[n - 1] > 0:\\n    ans += t[(n - P[n - 1]):]\\nprint(ans)\", \"n,m=map(int,input().strip().split())\\nr=input()\\nans=\\\"\\\"\\nans1=\\\"\\\"\\nfor i in range(n-1):\\n    if r[:i+1]==r[n-1-i:]:\\n        ans=r[:i+1]\\nj=len(ans)\\nans1=r+(m-1)*r[j:]\\nprint(ans1)\", \"from collections import defaultdict,deque\\nimport sys,heapq,bisect,math,itertools,string,queue,datetime\\nsys.setrecursionlimit(10**8)\\nINF = float('inf')\\nmod = 10**9+7\\neps = 10**-7\\ndef inpl(): return list(map(int, input().split()))\\ndef inpl_s(): return list(input().split())\\n\\nn,k = inpl()\\nS = input()\\n\\nfor i in reversed(list(range(n))):\\n\\tif S[:i] == S[n-i:]:\\n\\t\\tbreak\\n\\nans = S\\nfor _ in range(k-1):\\n\\tans += S[i:]\\n\\nprint(ans)\\n\", \"3\\n\\nn, k = [int(x) for x in input().split()]\\n\\nt = input()\\nmax_prefix = ''\\n\\nfor i in range(1, len(t)):\\n    l = t[-i:]\\n    # print(str(i) + \\\" : \\\" + l)\\n    if(t.startswith(l)):\\n        max_prefix = l\\n\\n# print(\\\"Max prefix :- \\\" + max_prefix)\\n\\ns = ''\\n\\nif len(max_prefix) == 0:\\n    for i in range(k):\\n        s = s + t\\nelse:\\n    p = t[:n-len(max_prefix)]\\n    for i in range(k-1):\\n        s = s + p\\n    s = s + t\\n\\nprint(s)\\n\", \"n, k = map(int, input().split())\\ns = input()\\nx = n\\nfor i in range(1, n):\\n\\n    if s[:n - i] == s[i:]:\\n        x = i\\n        break\\nans = s\\nfor i in range(k - 1):\\n    ans += s[n - x:]\\nprint(ans)\", \"\\nN, K = list(map(int, input().split()))\\nT = input()\\n\\ndef findAns(N, T):\\n    for i in range(N-1):\\n        if T[i+1:] == T[:N-1-i]:\\n            return T[N-1-i:]\\n    return T\\n\\nans = findAns(N, T)\\n\\nprint(T + ans*(K-1))\\n    \\n\", \"n, k = map(int, input().split())\\nt = input()\\ncycle = n\\nfor i in range(1, n):\\n    if t[i:] == t[:n - i]:\\n        cycle = i\\n        break\\nans = t[:cycle] * k + t[cycle:]\\nprint(ans)\", \"def counter(s, t): ## O(n**2) potentially oops\\n\\n    how_many = 0\\n\\n    for i in range(0, len(s)-len(t)+1):\\n\\n        ## print(i, i+len(t))\\n\\n        if s[i:i+len(t)] == t:\\n            how_many += 1\\n\\n    return how_many\\n\\nwhile True:\\n    \\n    inp = input().split()\\n\\n    n = int(inp[0])\\n    k = int(inp[1])\\n\\n    s = input()\\n\\n    returning = s\\n\\n    for i in range(1, n+1):\\n        if counter(returning+s[-i:], s) > counter(returning, s): ## (returning + s[-i:]).count(s) > returning.count(s):\\n            addition = s[-i:]\\n            break\\n\\n    returning = s + (k-1)*addition\\n\\n##    while counter(returning, s) < k: ## returning.count(s) < n:\\n##\\n##        for i in range(1, n+1):\\n##\\n##            if counter(returning+s[-i:], s) > counter(returning, s): ## (returning + s[-i:]).count(s) > returning.count(s):\\n##\\n##                returning += s[-i:]\\n##                break\\n\\n    print(returning)\\n\\n    break\\n\", \"n, k = map(int, input().split())\\nt = input()\\ni = n - 1\\nwhile i > 0 and t[:i] != t[-i:]:\\n    i -= 1\\nans = t\\nfor g in range(k - 1):\\n    ans += t[-n+i:]\\nprint(ans)\"]", "task": "apps", "difficulty": "introductory", "split": "test", "transformation_type": "plain_summary"}