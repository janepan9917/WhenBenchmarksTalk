{"qid": 4040, "orig_input": "There is a river of width $n$. The left bank of the river is cell $0$ and the right bank is cell $n + 1$ (more formally, the river can be represented as a sequence of $n + 2$ cells numbered from $0$ to $n + 1$). There are also $m$ wooden platforms on a river, the $i$-th platform has length $c_i$ (so the $i$-th platform takes $c_i$ consecutive cells of the river). It is guaranteed that the sum of lengths of platforms does not exceed $n$.\n\nYou are standing at $0$ and want to reach $n+1$ somehow. If you are standing at the position $x$, you can jump to any position in the range $[x + 1; x + d]$. However you don't really like the water so you can jump only to such cells that belong to some wooden platform. For example, if $d=1$, you can jump only to the next position (if it belongs to the wooden platform). You can assume that cells $0$ and $n+1$ belong to wooden platforms.\n\nYou want to know if it is possible to reach $n+1$ from $0$ if you can move any platform to the left or to the right arbitrary number of times (possibly, zero) as long as they do not intersect each other (but two platforms can touch each other). It also means that you cannot change the relative order of platforms.\n\nNote that you should move platforms until you start jumping (in other words, you first move the platforms and then start jumping).\n\nFor example, if $n=7$, $m=3$, $d=2$ and $c = [1, 2, 1]$, then one of the ways to reach $8$ from $0$ is follow:\n\n [Image] The first example: $n=7$. \n\n\n-----Input-----\n\nThe first line of the input contains three integers $n$, $m$ and $d$ ($1 \\le n, m, d \\le 1000, m \\le n$) \u2014 the width of the river, the number of platforms and the maximum distance of your jump, correspondingly.\n\nThe second line of the input contains $m$ integers $c_1, c_2, \\dots, c_m$ ($1 \\le c_i \\le n, \\sum\\limits_{i=1}^{m} c_i \\le n$), where $c_i$ is the length of the $i$-th platform.\n\n\n-----Output-----\n\nIf it is impossible to reach $n+1$ from $0$, print NO in the first line. Otherwise, print YES in the first line and the array $a$ of length $n$ in the second line \u2014 the sequence of river cells (excluding cell $0$ and cell $n + 1$).\n\nIf the cell $i$ does not belong to any platform, $a_i$ should be $0$. Otherwise, it should be equal to the index of the platform ($1$-indexed, platforms are numbered from $1$ to $m$ in order of input) to which the cell $i$ belongs.\n\nNote that all $a_i$ equal to $1$ should form a contiguous subsegment of the array $a$ of length $c_1$, all $a_i$ equal to $2$ should form a contiguous subsegment of the array $a$ of length $c_2$, ..., all $a_i$ equal to $m$ should form a contiguous subsegment of the array $a$ of length $c_m$. The leftmost position of $2$ in $a$ should be greater than the rightmost position of $1$, the leftmost position of $3$ in $a$ should be greater than the rightmost position of $2$, ..., the leftmost position of $m$ in $a$ should be greater than the rightmost position of $m-1$.\n\nSee example outputs for better understanding.\n\n\n-----Examples-----\nInput\n7 3 2\n1 2 1\n\nOutput\nYES\n0 1 0 2 2 0 3 \n\nInput\n10 1 11\n1\n\nOutput\nYES\n0 0 0 0 0 0 0 0 0 1 \n\nInput\n10 1 5\n2\n\nOutput\nYES\n0 0 0 0 1 1 0 0 0 0 \n\n\n\n-----Note-----\n\nConsider the first example: the answer is $[0, 1, 0, 2, 2, 0, 3]$. The sequence of jumps you perform is $0 \\rightarrow 2 \\rightarrow 4 \\rightarrow 5 \\rightarrow 7 \\rightarrow 8$.\n\nConsider the second example: it does not matter how to place the platform because you always can jump from $0$ to $11$.\n\nConsider the third example: the answer is $[0, 0, 0, 0, 1, 1, 0, 0, 0, 0]$. The sequence of jumps you perform is $0 \\rightarrow 5 \\rightarrow 6 \\rightarrow 11$.", "input": "Determine if it's possible to cross a river by jumping between movable platforms, given the river width, number of platforms, platform lengths, and maximum jump distance.", "test_cases": {"inputs": ["7 3 2\n1 2 1\n", "10 1 11\n1\n", "10 1 5\n2\n", "1000 3 9\n106 118 99\n", "1000 20 8\n3 6 3 4 3 5 3 5 5 5 3 1 3 8 2 4 4 5 3 2\n", "1000 16 2\n20 13 16 13 22 10 18 21 18 20 20 16 19 9 11 22\n", "5 1 2\n1\n", "1 1 1\n1\n", "2 1 1\n1\n", "4 1 2\n1\n", "15 2 5\n1 1\n", "10 10 1\n1 1 1 1 1 1 1 1 1 1\n", "5 2 1\n1 1\n", "7 1 1\n6\n", "2 2 1\n1 1\n", "100 1 49\n100\n", "10 9 1\n1 1 1 1 1 1 1 1 1\n", "50 4 7\n4 7 10 3\n", "10 1 5\n1\n", "8 1 4\n1\n", "100 1 49\n3\n", "6 3 1\n1 2 3\n", "1000 11 33\n2 1 5 1 3 1 3 1 3 2 1\n", "1000 6 25\n24 19 21 18 28 16\n", "1000 77 3\n2 3 2 1 3 3 3 3 4 5 4 3 3 1 3 5 1 4 3 2 5 3 2 2 1 4 4 3 1 2 3 2 1 4 1 3 3 2 4 3 1 5 1 3 4 4 2 3 2 4 3 4 3 1 6 5 2 3 4 3 3 5 5 2 1 2 2 3 2 2 5 1 3 5 5 4 2\n", "6 1 2\n2\n", "7 1 2\n4\n", "93 66 2\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 6 3 21\n", "8 4 1\n1 1 4 1\n", "12 3 2\n1 2 1\n", "3 1 1\n2\n", "5 1 2\n2\n", "5 4 1\n1 1 1 1\n", "4 4 1\n1 1 1 1\n", "8 3 2\n1 1 1\n", "12 1 4\n5\n", "9 3 2\n1 2 1\n", "4 2 1\n2 1\n", "11 1 5\n2\n", "10 1 4\n10\n", "8 2 2\n2 2\n", "20 20 20\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n", "13 1 4\n6\n", "5 2 1\n2 3\n", "7 2 2\n1 2\n"], "outputs": ["YES\n0 1 0 2 2 0 3 \n", "YES\n0 0 0 0 0 0 0 0 0 1 \n", "YES\n0 0 0 0 1 1 0 0 0 0 \n", "NO\n", "NO\n", "NO\n", "NO\n", "YES\n1 \n", "NO\n", "NO\n", "NO\n", "YES\n1 2 3 4 5 6 7 8 9 10 \n", "NO\n", "NO\n", "YES\n1 2 \n", "YES\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n", "NO\n", "YES\n0 0 0 0 0 0 1 1 1 1 0 0 0 0 0 0 2 2 2 2 2 2 2 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0 4 4 4 0 0 \n", "NO\n", "NO\n", "NO\n", "YES\n1 2 2 3 3 3 \n", "NO\n", "NO\n", "NO\n", "NO\n", "NO\n", "YES\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 64 64 64 64 64 65 65 65 66 66 66 66 66 66 66 66 66 66 66 66 66 66 66 66 66 66 66 66 66 \n", "NO\n", "NO\n", "NO\n", "NO\n", "NO\n", "YES\n1 2 3 4 \n", "NO\n", "NO\n", "NO\n", "NO\n", "NO\n", "YES\n1 1 1 1 1 1 1 1 1 1 \n", "NO\n", "YES\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \n", "NO\n", "YES\n1 1 2 2 2 \n", "NO\n"]}, "solutions": "[\"\\nfrom collections import defaultdict,deque\\nimport sys,heapq,bisect,math,itertools,string,queue,copy,time\\nsys.setrecursionlimit(10**8)\\nINF = float('inf')\\nmod = 10**9+7\\neps = 10**-7\\ndef inp(): return int(sys.stdin.readline())\\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\\ndef inpl_str(): return list(sys.stdin.readline().split())\\n\\nN,M,d = inpl()\\nCC = inpl()\\n\\nif sum(CC) + (d-1)*(M+1) < N:\\n    print(\\\"NO\\\")\\nelse:\\n    x = 0\\n    ans = [0]*(d-1)\\n    i = 0\\n    for i in range(M):\\n        ans += [i+1] * CC[i]\\n        ans += [0] * (d-1)\\n\\n    L = len(ans) - N\\n    ans2 = []\\n    for a in ans:\\n        if a == 0 and L > 0:\\n            L -= 1\\n        else:\\n            ans2.append(a)\\n\\n    print(\\\"YES\\\")\\n    print(\\\" \\\".join(map(str,ans2)))\\n\", \"import sys\\nn, m, d = list(map(int, input().split()))\\nc = list(map(int, input().split()))\\n\\ncur = 0\\nfor p in range(m):\\n    cur += d\\n    cur += c[p] - 1\\nif cur < n + 1 - d:\\n    print('NO')\\n    return\\nres = [0] * n\\ncur = n - 1\\nfor p in range(m - 1, -1, -1):\\n    for j in range(c[p]):\\n        res[cur] = p + 1\\n        cur -= 1\\ncur = 0\\nwhile cur < n + 1:\\n    cur += d\\n    if cur >= n + 1:\\n        break\\n    if res[cur - 1] == 0:\\n        idx = -1\\n        for j in range(cur, len(res)):\\n            if res[j] != 0:\\n                idx = j\\n                break\\n        cnt = 1\\n        for j in range(idx + 1, len(res)):\\n            if res[j] == res[idx]:\\n                cnt += 1\\n        num = res[idx]\\n        for j in range(cnt):\\n            res[cur + j - 1] = num\\n            res[idx + j] = 0\\n    while cur < len(res) and res[cur] > 0:\\n        cur += 1\\nprint(\\\"YES\\\")\\nprint(' '.join(str(x) for x in res))\\n        \\n\", \"arr = [int (i) for i in filter(None, input().split(\\\" \\\"))]\\ns = arr[0]\\nk = arr[1]\\nmx = arr[2]\\narr = [int (i) for i in filter(None, input().split(\\\" \\\"))]\\nsum = 0\\nfor i in range(k):\\n    sum+=arr[i]\\nsum+=(mx-1)*(k+1)\\nif sum<s:\\n    wer = \\\"NO\\\"\\n    print(wer)\\nelse:\\n    wer = \\\"YES\\\"\\n    ans = [0]*(mx-1)\\n    for i in range(k):\\n        ans+=[i+1]*arr[i]\\n        ans+=[0]*(mx-1)\\n    max = len(ans)\\n    for i in range(len(ans)):\\n        if max<=s:\\n            break\\n        else:\\n            if ans[i] ==0:\\n                ans[i]=-1\\n                max-=1\\n    answer = []\\n    for i in range(len(ans)):\\n        if ans[i]!=-1:\\n            answer.append(ans[i])\\n    print(wer)\\n    for i in range(len(answer)):\\n        print(answer[i], end=' ')\\n\\n\\n\", \"n,m,d=map(int,input().split())\\nc=list(map(int,input().split()))\\nans=[]\\ns=sum(c)\\nind=[]\\nj=-1\\nfor i in range(len(c)):\\n    v=min(j+d,n-s)\\n    ind.append(v)\\n    j=v+c[i]-1\\n    s-=c[i]\\nans=[]\\nif n-j>d:\\n    print(\\\"NO\\\")\\n    return\\ni=0\\nj=0\\nv=1\\nwhile i<n:\\n    if j<len(ind) and i==ind[j]:\\n        for l in range(c[j]):\\n            ans.append(v)\\n        v+=1\\n        i+=c[j]\\n        j+=1\\n    else:\\n        i+=1\\n        ans.append(0)\\nprint(\\\"YES\\\")\\nprint(*ans)\", \"n,m,d = list(map(int, input().split()))\\nplank = list(map(int, input().split()))\\nsumm = sum(plank)\\nj = 0\\nans = [0]*n\\ncurr = -1\\ni = 0\\nflag = 0\\nwhile(i<n):\\n    if(summ == n-i): # use all planks\\n        if(j==m):\\n            print(\\\"NO\\\")\\n            flag = 1\\n            break\\n        for _ in range(plank[j]):\\n            ans[i] = j+1\\n            i = i + 1\\n        summ = summ - plank[j]\\n        j = j + 1\\n        curr = i - 1\\n    elif(i-curr==d):\\n        if(j==m):\\n            flag = 1\\n            print(\\\"NO\\\")\\n            break\\n        for _ in range(plank[j]):\\n            ans[i] = j+1\\n            i = i + 1\\n        summ = summ - plank[j]\\n        j = j + 1\\n        curr = i - 1\\n    else:\\n        i = i + 1\\nif(flag==0):\\n    print(\\\"YES\\\")\\n    print(*ans)\\n\", \"import sys\\ninput=sys.stdin.readline\\n\\nn,m,d=list(map(int,input().split())) \\narr=list(map(int,input().split())) \\ntot=sum(arr)\\nres=[0]*n\\ngap=1\\nptr=0\\nj=0\\nbool1=True\\nwhile(j<n):\\n\\tif(gap<d and n-(j+1)>=tot):\\n\\t\\tj+=1\\n\\t\\tgap+=1\\n\\t\\tcontinue\\n\\telse:\\n\\t\\tif(ptr<m):\\n\\t\\t\\tfor k in range(j,j+arr[ptr]):\\n\\t\\t\\t\\tres[k]=(ptr+1)\\n\\t\\t\\tgap=1\\n\\t\\t\\ttot-=arr[ptr]\\n\\t\\t\\tj+=arr[ptr]\\n\\t\\t\\t# print(j-1)\\n\\t\\t\\tptr+=1\\n\\t\\telse:\\n\\t\\t\\tj+=1\\n\\t\\t\\tbool1=False\\n\\t# print(j)\\n# print(res,bool1)\\nif(bool1==False):\\n\\tprint(\\\"NO\\\")\\t\\nelse:\\n\\tprint(\\\"YES\\\")\\n\\ts=\\\"\\\"\\n\\tfor i in res:\\n\\t\\ts=s+str(i)+\\\" \\\"\\n\\ts=s[:-1]\\n\\tprint(s)\\n\\n\\n\", \"n,m,d=[int(x) for x in input().split(' ')]\\nlist1=[int(x) for x in input().split(' ')]\\nx=(m+1)*(d-1)+sum(list1)\\nlist2=[]\\na=0\\nb=0\\nif x < n:\\n    print('NO')\\nelse:\\n    print('YES')\\n    n0=n-sum(list1)\\n    while b <= m:\\n        if a == 0:\\n            if n0 >= d-1:\\n                list2.extend(['0']*(d-1))\\n                a+=1\\n                b+=1\\n                n0-=(d-1)\\n            elif 0 < n0 < (d-1):\\n                list2.extend(['0']*n0)\\n                a+=1\\n                b+=1\\n                n0=0\\n            else:\\n                a+=1\\n                b+=1\\n        else:\\n            list2.extend([str(b)]*list1[b-1])\\n            a-=1\\n    print(' '.join(list2)) \\n        \\n    \\n\", \"data = (list(map(int, input().split())))\\n\\nc = (list(map(int, input().split())))\\n\\ncsum = sum(c)\\n\\nif (data[2] == 0):\\n    print(\\\"NO\\\")\\nelse:\\n    if (csum+(data[2]-1)*(data[1]+1)>= data[0]):\\n        print(\\\"YES\\\")\\n        \\n        empt = data[0] - csum\\n        \\n        allempt = 0\\n        \\n        sol = []\\n        \\n        for i in range(data[1]):\\n            \\n            if(allempt < empt):\\n                for z in range(data[2]-1):\\n                    if(allempt >= empt):\\n                        break\\n                    sol.append(0)\\n                    allempt+=1\\n                    \\n            for j in range(c[i]):\\n                sol.append((i+1))\\n            \\n            q = data[0] - len(sol)\\n            \\n        if (q != 0):\\n            for i in range(q):\\n                sol.append(0)\\n            \\n        print (*sol)\\n        \\n    else:\\n        print(\\\"NO\\\")\", \"n,m,d = list(map(int, input().split()))\\nc = list(map(int, input().split()))\\nsumc = 0\\nfor elem in c:\\n    sumc += elem\\nif sumc + (m+1)*(d-1) < n:\\n    print('NO')\\nelse:\\n    print('YES')\\n    ans = []\\n    x = n - sumc\\n    for i in range(m):\\n        if x > d-1:\\n            for j in range(d-1):\\n                ans.append(0)\\n            for j in range(c[i]):\\n                ans.append(i+1)\\n            x -= (d-1)\\n        elif x > 0:\\n            for j in range(x):\\n                ans.append(0)\\n            for j in range(c[i]):\\n                ans.append(i+1)\\n            x = 0\\n        else:\\n            for j in range(c[i]):\\n                ans.append(i+1)\\n    for j in range(x):\\n        ans.append(0)\\n    print(*ans)\\n\\n\", \"import sys\\n\\ndef minp():\\n\\treturn sys.stdin.readline().strip()\\n\\ndef mint():\\n\\treturn int(minp())\\n\\ndef mints():\\n\\treturn list(map(int,minp().split()))\\n\\ndef solve():\\n\\tn, m, d = mints()\\n\\n\\ta = list(mints())\\n\\tb = [0]*m\\n\\ts = sum(a)\\n\\tp = 0\\n\\tfor i in range(m):\\n\\t\\tb[i] = p + d\\n\\t\\tp = p + d + a[i] - 1\\n\\tif b[-1] + a[-1] - 1 + d < n + 1:\\n\\t\\tprint(\\\"NO\\\")\\n\\t\\treturn\\n\\tp = n + 1\\n\\tc = [0]*n\\n\\tfor i in range(m-1,-1,-1):\\n\\t\\tif b[i] + a[i] - 1 >= p:\\n\\t\\t\\tb[i] = p - a[i]\\n\\t\\tp = b[i]\\n\\t\\t#print(i, b[i], a[i], b[i]+a[i])\\n\\t\\tfor j in range(b[i], b[i] + a[i]):\\n\\t\\t\\tc[j-1] = i + 1\\n\\tprint(\\\"YES\\\")\\n\\tprint(*c)\\n\\nsolve()\\n\", \"line = input().split()\\n\\nn = int(line[0])\\nm = int(line[1])\\nd = int(line[2])\\n\\nline = input().split()\\n\\nc = [int(x) for x in line]\\n\\n# print(c[0])\\n\\nif sum(c) + (len(c) + 1) * (d - 1) < n:\\n\\tprint('NO')\\n\\nelse:\\n\\tcnt = n - sum(c)\\n\\n\\tans = []\\n\\n\\tcnt2 = 0\\n\\n\\twhile cnt != 0:\\n\\n\\t\\t# print('counter is ' + str(cnt))\\n\\n\\t\\tfor i in range(d-1):\\n\\n\\t\\t\\tif cnt == 0:\\n\\t\\t\\t\\tbreak\\n\\n\\t\\t\\tans.append(0)\\n\\t\\t\\tcnt -= 1\\n\\n\\t\\tif cnt2 >= len(c):\\n\\t\\t\\tbreak\\n\\n\\t\\tfor i in range(c[cnt2]):\\n\\t\\t\\tans.append(cnt2+1)\\n\\n\\t\\tcnt2 += 1\\n\\n\\twhile cnt2 != m:\\n\\t\\tfor i in range(c[cnt2]):\\n\\t\\t\\tans.append(cnt2+1)\\n\\n\\t\\tcnt2 += 1\\n\\n\\tprint('YES')\\n\\n\\tfor ch in ans:\\n\\t\\tprint(str(ch), end=' ')\\n\\n\\tprint()\", \"def gcd(a, b):\\n    if a == 0:\\n        return b\\n    else:\\n        return gcd(b % a, a)\\n \\n \\nn, m, d = list(map(int, input().split()))\\n \\na = list(map(int, input().split()))\\nj = 0\\np = m - 1\\nk = [0] * n\\nfor i in range(n - 1, -1, -1):\\n    k[i] = p + 1\\n    j += 1\\n    if a[p] <= j:\\n        j = 0\\n        p -= 1\\n        if p == -1:\\n            break\\n    \\nz = 0\\n\\nlast = -1\\nfor i in range(n):\\n    if k[i] == 1:\\n        last = i\\n    if i - last >= d and k[i] == 0:\\n        #print(i, last, k, z, a[z] + i, a[z])\\n        for j in range(0, n):\\n            if k[j] == z + 1:\\n                k[j] = 0\\n        for j in range(i, a[z] + i):\\n            k[j] = z + 1\\n            last = j\\n        z += 1\\n        #print(z, k)\\n        if z == m and n - last > d:\\n            print('NO')\\n            return\\nif d > n:\\n    print('YES')\\n    print('1 ' * a[z] + '0 ' * (n - a[z]))\\n    return\\nprint('YES')\\nprint(*k)\\n           \\n            \\n            \\n\", \"import sys\\n# input = sys.stdin.buffer.readline\\ninput = sys.stdin.readline\\n\\n\\nn,m,d = list(map(int, input().split()))\\nli = list(map(int, input().split()))\\nx=0\\nl=0\\nmaxx = sum(li)+(d-1)*(m+1)\\n\\noff = maxx - n\\n# print(maxx,off)\\noutlist=[]\\nfor i in range(m):\\n    # print(off,d)\\n    if (off)>=d:\\n        \\n        off-=(d-1)\\n    else:\\n        outlist.extend([0]*(d-off-1))\\n        off=0\\n    outlist.extend([i+1]*li[i])\\n\\nif (off)>d:\\n        off-=(d-1)\\nelse:\\n    outlist.extend([0]*(d-off-1))\\n    off=0\\n\\nif maxx>=n:\\n    print(\\\"YES\\\")\\n    print(\\\" \\\".join([str(a) for a in outlist]))\\nelse:\\n    print(\\\"NO\\\")\\n# print(l)\\n\", \"n,m,d = map(int,input().split())\\nc = list(map(int,input().split()))\\nsc = sum(c)\\nif sc + (len(c)+ 1) * (d - 1) < n:\\n    print(\\\"NO\\\")\\nelse:\\n    print(\\\"YES\\\")\\n    ko = n - sc\\n    for i in range(m):\\n        if ko != 0:\\n            if ko >= d - 1:\\n                print(\\\"0 \\\" * (d -1 ), end = \\\"\\\")\\n                ko -= d -1\\n            else:\\n                print(\\\"0 \\\" * (ko ), end = \\\"\\\")\\n                ko = 0\\n        print((str(i + 1) + \\\" \\\") * c[i], end = \\\"\\\")\\n    print(\\\"0 \\\" * (ko ), end = \\\"\\\")\\n\", \"n, m, d = map(int, input().split())\\nc = list(map(int, input().split()))\\nsum_c = sum(c)\\ntmp_ans = sum_c + (m+1)*(d-1)\\nif tmp_ans < n:\\n    print(\\\"NO\\\")\\n    return\\nnokori = tmp_ans - n\\n\\nans = [0] * n\\nj = 1\\nfor i in range(m):\\n    j -= 1\\n    if nokori >= d - 1:\\n        nokori -= d - 1\\n    else:\\n        j += (d - 1 - nokori)\\n        nokori = 0\\n    for _ in range(c[i]):\\n        ans[i+j] = i+1\\n        j += 1\\nprint(\\\"YES\\\")\\nprint(*ans)\", \"n, m, d = list(map(int, input().split()))\\nc = list(map(int, input().split()))\\nr = sum(c)\\ncur = 0\\nci = 0\\nmmap = [0] * n\\nwhile cur < n+1 and ci < len(c):\\n    #print(\\\"pi =min \\\", cur + d,\\\" \\\",  n - r + 1)\\n\\n    pi = min(cur + d, n - r + 1)\\n    #print(\\\"pi = \\\", pi)\\n    for j in range(pi, pi+c[ci]):\\n        mmap[j-1] = ci+1\\n    cur = pi + c[ci]-1\\n    r -= c[ci]\\n    ci += 1\\n    \\nif cur + d >= n+1:\\n    print(\\\"YES\\\")\\n    print(\\\" \\\".join(map(str, mmap)))\\nelse:\\n    print(\\\"NO\\\")\\n\", \"import sys\\n\\n\\nn, m, d = list(map(int, input().split()))\\nM = list(map(int, sys.stdin.readline().split())) \\nsumM = sum(M)\\nA = [0] * n\\nposit = -1\\nfor platf in range(m):\\n    for ii in range(posit + min(d, n - sumM - posit), posit + min(d, n - sumM - posit) + M[platf]):\\n        A[ii] = platf + 1\\n    posit = ii\\n    sumM -= M[platf]    \\nif n - posit > d:\\n    print(\\\"NO\\\")\\nelse:\\n    print(\\\"YES\\\")\\n    print(*A)\\n\", \"n, m, d = map(int, input().split())\\np = list(map(int, input().split()))\\n\\npositions = [0] * len(p)\\npositions[-1] = n + 1 - p[-1]\\nfor i in reversed(range(len(p)-1)):\\n    positions[i] = positions[i+1] - p[i]\\n\\ndef feasible(p, positions, d):\\n    if positions[0] > d:\\n        return False\\n    for i in range(1, len(p)):\\n        if positions[i] - (positions[i-1] + p[i-1] - 1) > d:\\n            return False\\n    if n+1 - (positions[-1] + p[-1] - 1) > d:\\n        return False\\n    return True\\n\\ng = [0] * m\\ng[0] = d\\nfor i in range(1, m):\\n    g[i] = g[i-1] + p[i-1] - 1 + d\\n\\ni = 0\\nwhile not feasible(p, positions, d) and i < len(p):\\n    positions[i] = g[i]\\n    i += 1\\n\\nif feasible(p, positions, d):\\n    print(\\\"YES\\\")\\n    board = [0] * n\\n    for i in range(m):\\n        for j in range(p[i]):\\n            board[positions[i]-1+j] = i+1\\n    for e in board:\\n        print(e, end=' ')\\n    print()\\nelse:\\n    print(\\\"NO\\\")\", \"def move(rightmost, d, seq, current):\\n\\tplankno = seq[rightmost]\\n\\t# print(*seq)\\n\\t# while seq[rightmost] == plankno:\\n\\tmoving = rightmost\\n\\n\\trem = rightmost-current-d\\n\\trightmost += 1\\n\\t# print(rem)\\n\\tfor i in range(rem):\\n\\t\\ttemp = seq[moving]\\n\\t\\tseq[moving] = seq[moving-1]\\n\\t\\tseq[moving-1] = temp\\n\\t\\tmoving -= 1\\n\\n\\n\\t# print(*seq, rightmost, moving)\\n\\n\\twhile rightmost != len(seq) and seq[rightmost] == plankno:\\n\\t\\tseq[rightmost] = 0\\n\\t\\trightmost += 1\\n\\n\\t\\tseq[moving+1] = plankno\\n\\t\\tmoving += 1\\n\\n\\t# print(*seq, moving, rightmost)\\n\\treturn moving, rightmost\\n\\n\\n\\t\\t# break\\n\\n\\n\\n\\nn, m, d = list(map(int, input().split()))\\narr = [int(j) for j in input().split()]\\n\\nplanks = []\\nfor i in range(m):\\n\\tplanks += [i+1]*arr[i]\\n\\nrem = [0]*(n-len(planks))\\nseq = rem + planks\\n# print(seq)\\n# print(rem, planks)\\n\\nrightmost = n-1\\nwhile seq[rightmost] != 0 and rightmost != -1:\\n\\trightmost -= 1\\n\\nrightmost += 1\\ncurrent = -1\\n# print(rightmost, current)\\n\\nfor i in range(m):\\n\\tif rightmost - current <= d:\\n\\t\\tcurrent = n-1\\n\\t\\tbreak\\n\\telse:\\n\\t\\tcurrent, rightmost = move(rightmost, d, seq, current)\\n\\n\\n# print(n-current)\\nif n-current > d:\\n\\tprint(\\\"NO\\\")\\nelse:\\n\\tprint(\\\"YES\\\")\\n\\tprint(*seq)\\n\\n\\n\\n\", \"'''\\nhttps://codeforces.com/contest/1256/problem/C\\n'''\\n\\n\\nn, m, d = list(map(int, input().split()))\\ncs = list(map(int, input().split()))\\n\\n\\nls = [0] * m\\nls[m - 1] = cs[m - 1]\\nfor i in range(m - 1):\\n    ls[m - i - 2] = ls[m - i - 1] + cs[m - i - 2]\\n\\n\\nif ls[0] + (d - 1) * (m + 1) < n:\\n    print('NO')\\nelse:\\n    ns = [0] * n\\n    ci = 0\\n    jump = 1\\n    i = 0\\n    while i < n and ci < m:\\n        # print(i)\\n        # print(n - i)\\n        if ls[ci] < n - i:\\n            if jump < d:\\n                jump += 1\\n                ns[i] = 0\\n            else:\\n                for i in range(i, i + cs[ci]):\\n                    ns[i] = ci + 1\\n                    jump = 1\\n                ci += 1\\n        else:\\n            # print(list(range(i, i + cs[ci])))\\n            for i in range(i, i + cs[ci]):\\n                ns[i] = ci + 1\\n                jump = 1\\n            ci += 1\\n        i += 1\\n    print('YES')\\n    print(' '.join(list(map(str, ns))))\\n\", \"from itertools import accumulate\\n\\nn, m, dmax = list(map(int, input().split()))\\nc = list(map(int, input().split()))\\n\\nif sum(c) - m + dmax * (m+1) < n+1:\\n    print('NO')\\n    return\\nelse:\\n    print('YES')\\n\\nd = (n - sum(c)) // (m+1)\\nmajor_num = (n - sum(c)) - d * (m+1)\\n\\nans = []\\nk = 1\\nfor i in range(major_num):\\n    ans.extend([0] * (d + 1))\\n    ans.extend([k] * c[k-1])\\n    k += 1\\nfor i in range(m + 1 - major_num - 1):\\n    ans.extend([0] * d)\\n    ans.extend(([k] * c[k-1]))\\n    k += 1\\nans.extend(([0] * d))\\nprint(*ans)\\n\", \"n, m, d = list(map(int, input().split()))\\n\\nlengths = list(map(int, input().split()))\\nposes = [n + 1] * (m + 1)\\nindex = m - 1\\nwhile index >= 0:\\n    poses[index] = poses[index + 1] - lengths[index]\\n    index -= 1\\n\\n#print(poses)\\n\\ncur = 0\\nind = 0\\nresult = True\\nwhile cur < n + 1:\\n    if cur + d >= n + 1:\\n        break\\n    if ind == m:\\n        result = False\\n        break\\n    if cur + d <= poses[ind]:\\n        poses[ind] = cur + d\\n        cur = cur + d + lengths[ind] - 1\\n        ind += 1\\n    else:\\n        cur = cur + d\\n\\nif result:\\n    print(\\\"YES\\\")\\n    poses.append(0)\\n    lengths.append(0)\\n    lengths.append(1)\\n    res = []\\n    for ind, it in enumerate(poses[:-1]):\\n        for _ in range(it - poses[ind - 1] - lengths[ind - 1]):\\n            res.append('0')\\n        for _ in range(lengths[ind]):\\n            res.append(str(ind + 1))\\n    print(\\\" \\\".join(res))\\nelse:\\n    print(\\\"NO\\\")\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\ndef main():\\n    n, m, d = [int(x) for x in input().split()]\\n    C = [int(x) for x in input().split()]\\n\\n    current = -1\\n    ans = [0] * (1000 * 1000)\\n    for i, c in enumerate(C):\\n        current += d - 1\\n        for j in range(c):\\n            current += 1\\n            ans[current] = i + 1\\n\\n    if current + d < n:\\n        print(\\\"NO\\\")\\n    else:\\n        print(\\\"YES\\\")\\n        amari = current - (n - 1)\\n        count = 0\\n        for a in ans:\\n            if a == 0 and amari > 0:\\n                amari -= 1\\n                continue\\n            count += 1\\n            print(a, end=\\\" \\\")\\n            if count == n:\\n                break\\n        print(\\\"\\\")\\n\\n\\n\\n\\n\\n\\n\\n\\n\\ndef __starting_point():\\n    main()\\n\\n\\n\\n__starting_point()\", \"n, m, d = map(int, input().split())\\nc = list(map(int, input().split()))\\n\\nboards = [None]*(m+1)\\nboards[-1] = [n+1, n+1]\\nfor i in range(m-1, -1, -1):\\n    boards[i] = [boards[i+1][0]-c[i], boards[i+1][0]-1]\\n\\npos = 0\\nfor i in range(m+1):\\n    if pos + 1 == boards[i][0]:\\n        pos = boards[i][1]\\n        continue\\n    if boards[i][0] <= pos + d <= n+1:\\n        if pos + d <= boards[i][1]:\\n            pos = boards[i][1]\\n        continue\\n    diff = boards[i][0] - (pos+d)\\n    boards[i][0] -= diff\\n    boards[i][1] -= diff\\n    pos = boards[i][1]\\n\\nif pos < n+1:\\n    print('NO')\\n    return\\nelse:\\n    ans = [0]*(n+1)\\n    for i in range(m):\\n        for j in range(boards[i][0], boards[i][1]+1):\\n            ans[j] = i+1\\n\\n    print('YES')\\n    print(*ans[1:])\", \"n, m, d = list(map(int, input().split()))\\n\\nlengths = list(map(int, input().split()))\\nposes = [n + 1] * (m + 1)\\nindex = m - 1\\nwhile index >= 0:\\n    poses[index] = poses[index + 1] - lengths[index]\\n    index -= 1\\n\\n#print(poses)\\n\\ncur = 0\\nind = 0\\nresult = True\\nwhile cur < n + 1:\\n    if cur + d >= n + 1:\\n        break\\n    if ind == m:\\n        result = False\\n        break\\n    if cur + d <= poses[ind]:\\n        poses[ind] = cur + d\\n        cur = cur + d + lengths[ind] - 1\\n        ind += 1\\n    else:\\n        break\\n\\nif result:\\n    print(\\\"YES\\\")\\n    poses.append(0)\\n    lengths.append(0)\\n    lengths.append(1)\\n    res = []\\n    for ind, it in enumerate(poses[:-1]):\\n        for _ in range(it - poses[ind - 1] - lengths[ind - 1]):\\n            res.append('0')\\n        for _ in range(lengths[ind]):\\n            res.append(str(ind + 1))\\n    print(\\\" \\\".join(res))\\nelse:\\n    print(\\\"NO\\\")\\n\"]", "task": "apps", "difficulty": "introductory", "split": "test", "transformation_type": "plain_summary"}