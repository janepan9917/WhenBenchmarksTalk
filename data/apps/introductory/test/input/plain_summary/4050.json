{"qid": 4050, "orig_input": "This problem is given in two editions, which differ exclusively in the constraints on the number $n$.\n\nYou are given an array of integers $a[1], a[2], \\dots, a[n].$ A block is a sequence of contiguous (consecutive) elements $a[l], a[l+1], \\dots, a[r]$ ($1 \\le l \\le r \\le n$). Thus, a block is defined by a pair of indices $(l, r)$.\n\nFind a set of blocks $(l_1, r_1), (l_2, r_2), \\dots, (l_k, r_k)$ such that:\n\n  They do not intersect (i.e. they are disjoint). Formally, for each pair of blocks $(l_i, r_i)$ and $(l_j, r_j$) where $i \\neq j$ either $r_i < l_j$ or $r_j < l_i$.  For each block the sum of its elements is the same. Formally, $$a[l_1]+a[l_1+1]+\\dots+a[r_1]=a[l_2]+a[l_2+1]+\\dots+a[r_2]=$$ $$\\dots =$$ $$a[l_k]+a[l_k+1]+\\dots+a[r_k].$$  The number of the blocks in the set is maximum. Formally, there does not exist a set of blocks $(l_1', r_1'), (l_2', r_2'), \\dots, (l_{k'}', r_{k'}')$ satisfying the above two requirements with $k' > k$. \n\n $\\left. \\begin{array}{|l|l|l|l|l|l|} \\hline 4 & {1} & {2} & {2} & {1} & {5} & {3} \\\\ \\hline \\end{array} \\right.$ The picture corresponds to the first example. Blue boxes illustrate blocks. \n\nWrite a program to find such a set of blocks.\n\n\n-----Input-----\n\nThe first line contains integer $n$ ($1 \\le n \\le 50$) \u2014 the length of the given array. The second line contains the sequence of elements $a[1], a[2], \\dots, a[n]$ ($-10^5 \\le a_i \\le 10^5$).\n\n\n-----Output-----\n\nIn the first line print the integer $k$ ($1 \\le k \\le n$). The following $k$ lines should contain blocks, one per line. In each line print a pair of indices $l_i, r_i$ ($1 \\le l_i \\le r_i \\le n$) \u2014 the bounds of the $i$-th block. You can print blocks in any order. If there are multiple answers, print any of them.\n\n\n-----Examples-----\nInput\n7\n4 1 2 2 1 5 3\n\nOutput\n3\n7 7\n2 3\n4 5\n\nInput\n11\n-5 -4 -3 -2 -1 0 1 2 3 4 5\n\nOutput\n2\n3 4\n1 1\n\nInput\n4\n1 1 1 1\n\nOutput\n4\n4 4\n1 1\n2 2\n3 3", "input": "Find the maximum number of non-overlapping blocks in an array where each block has the same sum.", "test_cases": {"inputs": ["7\n4 1 2 2 1 5 3\n", "11\n-5 -4 -3 -2 -1 0 1 2 3 4 5\n", "4\n1 1 1 1\n", "1\n100000\n", "2\n-100000 -100000\n", "2\n10000 99999\n", "3\n4 2 2\n", "3\n1 3 4\n", "3\n7 1 7\n", "3\n-2 -4 -4\n", "29\n-7 -8 -15 13 -5 -7 -4 -5 -8 29 -3 -2 7 -12 3 -2 -9 4 24 1 -11 14 -2 -13 -15 -3 18 -1 4\n", "7\n-1 -2 -1 2 -3 9 -8\n", "10\n2 10 9 1 10 4 7 8 5 4\n", "20\n1 2 1 4 1 4 3 5 5 4 3 2 4 5 2 3 4 4 3 5\n", "50\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50\n", "50\n1 8 15 22 29 36 43 50 57 64 71 78 85 92 99 106 113 120 127 134 141 148 155 162 169 176 183 190 197 204 211 218 225 232 239 246 253 260 267 274 281 288 295 302 309 316 323 330 337 344\n", "50\n10000 10001 10002 10003 10004 10005 10006 10007 10008 10009 10010 10011 10012 10013 10014 10015 10016 10017 10018 10019 10020 10021 10022 10023 10024 10025 10026 10027 10028 10029 10030 10031 10032 10033 10034 10035 10036 10037 10038 10039 10040 10041 10042 10043 10044 10045 10046 10047 10048 10049\n", "50\n10000 10004 10008 10012 10016 10020 10024 10028 10032 10036 10040 10044 10048 10052 10056 10060 10064 10068 10072 10076 10080 10084 10088 10092 10096 10100 10104 10108 10112 10116 10120 10124 10128 10132 10136 10140 10144 10148 10152 10156 10160 10164 10168 10172 10176 10180 10184 10188 10192 10196\n", "44\n48 52 20 28 21 18 13 34 41 25 25 23 26 26 18 24 22 16 20 18 19 24 20 14 5 15 11 33 12 29 13 10 12 14 14 16 21 22 7 15 17 21 14 4\n", "48\n282 245 230 243 156 139 176 147 181 201 244 256 227 273 327 330 343 334 350 316 227 233 221 319 246 179 192 209 174 544 456 234 265 243 258 503 497 196 293 275 236 501 499 444 556 321 341 338\n", "42\n3333 3344 3323 10000 3272 3442 3286 5048 4952 10000 5111 4889 3302 3311 3387 10000 3382 3213 3405 3499 3244 3257 5083 4917 4893 5107 4971 5029 10000 5070 4930 10000 4929 5071 3414 3271 3315 3372 3276 3352 5077 4923\n", "44\n945 985 1011 1021 1051 978 975 1060 1060 914 1203 1281 1334 1192 1175 1279 1257 1279 772 903 862 847 824 875 919 773 730 859 799 837 650 762 673 741 683 709 749 658 718 818 735 672 730 702\n", "33\n14146 14192 14362 14493 14299 14206 14302 9449 9297 9127 8843 9107 9148 8833 8883 9143 9080 9090 6782 6439 6721 6762 6963 6487 6682 6578 6631 6621 6674 6662 6769 6645 6584\n", "45\n3869 2339 2626 2485 2550 276 2300 1591 3980 2035 2017 2083 1888 1977 -914 3511 1247 731 813 3951 879 2607 2528 2423 2662 2387 -268 3480 1313 3789 2796 1302 3883 3349 3262 3389 2097 3075 3063 2100 1959 2015 2035 1891 1757\n", "44\n3156 874 2193 3041 2021 1967 2058 1950 2004 2766 1660 3310 2431 3269 2770 2144 901 2443 1638 1630 1746 1635 1712 1639 1214 2632 2379 2695 3116 2397 2403 2613 2587 2075 2429 2508 2616 2447 2463 1950 1917 2064 2016 2053\n", "50\n100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000 100000\n", "50\n-100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000 -100000\n", "50\n77072 41221 -28246 -62815 -16005 65693 81042 78803 77427 -71053 -20151 42316 32696 -62603 26921 17488 -39480 -52358 -27307 67396 -82510 1113 8681 55228 -43708 -16777 27265 -52350 -59810 -68216 74492 -27843 -6602 -88703 14976 -57753 21273 948 -26476 -44959 94840 -39252 -28959 -12246 -77288 8040 -29355 17103 -81996 34836\n", "50\n1734 -644 -3800 6167 -1751 8598 1506 -2709 1203 -4312 -1696 3257 -4052 4283 1218 8654 5593 -6074 223 7155 876 -4640 3895 -5527 8860 -2428 -781 3128 -5702 7355 -718 136 -5459 -1722 -8157 1659 1170 -8275 2254 5352 -1239 -2584 4582 8844 -3754 -9170 7003 -7348 -7061 1924\n", "50\n-966 999 -629 776 -799 -756 272 -249 473 332 257 -429 -725 -478 -641 -52 735 51 -256 -290 314 79 -762 954 987 580 170 -860 710 -358 289 -487 519 677 -139 -771 -671 -120 790 115 922 948 783 -789 299 -751 389 -732 701 423\n", "50\n-62 81 -95 -44 -9 7 15 -84 -16 2 52 79 -91 -79 46 83 -48 58 -48 -39 73 -15 -84 76 -42 24 -77 37 -16 64 46 19 -59 6 -32 -39 -2 37 98 -96 10 25 24 32 21 -24 97 20 -26 56\n", "50\n69445 81184 56002 47776 -40706 75446 52618 67584 73790 -34133 52570 95836 99854 -12443 -30693 -21051 63507 39263 16359 73641 93907 10572 96846 -12229 -45171 -52229 22899 79901 32893 4364 -81068 -41755 71021 81855 12741 -32126 -60225 83649 51388 90632 89135 47676 51155 89692 93059 23888 991 62350 84665 84297\n", "50\n61818 60378 89660 -10359 40748 72848 69893 96042 43415 27463 44710 92483 56604 32550 72936 58563 -8346 -56371 -29213 11702 62317 36268 -13687 59381 70369 42686 82597 39550 30823 80435 96378 24516 51809 -29947 38941 42359 95856 85208 50649 64610 70930 90848 18510 91630 40003 24813 -29469 33021 97112 14853\n", "50\n46565 -991 64900 70963 3448 84886 96022 76131 93383 65304 84743 61117 46178 87562 95718 54705 98186 96553 85285 91254 94207 86127 67249 81094 80438 89790 70248 83435 94476 63668 77369 99503 80340 40121 84272 56094 85570 67333 51830 62271 75709 14140 76136 99669 37362 71210 93136 80773 72983 36943\n", "50\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n", "50\n-1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1\n", "12\n1 1 1 1 1 1 1 1 1 1 1 1\n", "5\n2 2 -2 -1 3\n", "12\n1 2 3 4 5 6 7 8 9 10 11 12\n", "12\n1 1 1 1 1 1 1 1 11 1 1 1\n"], "outputs": ["3\n7 7\n2 3\n4 5\n", "2\n3 4\n1 1\n", "4\n4 4\n1 1\n2 2\n3 3\n", "1\n1 1\n", "2\n2 2\n1 1\n", "1\n1 1\n", "2\n3 3\n2 2\n", "2\n3 3\n1 2\n", "2\n3 3\n1 1\n", "2\n3 3\n2 2\n", "6\n13 14\n5 5\n8 8\n11 12\n17 18\n19 26\n", "3\n4 5\n1 1\n3 3\n", "3\n5 5\n2 2\n3 4\n", "8\n9 9\n3 4\n20 20\n8 8\n11 12\n15 16\n14 14\n5 6\n", "4\n27 27\n2 7\n8 10\n13 14\n", "2\n30 30\n1 8\n", "1\n1 1\n", "1\n1 1\n", "9\n11 14\n1 2\n31 37\n8 10\n38 44\n26 30\n20 25\n3 7\n15 19\n", "14\n15 17\n1 4\n42 43\n11 14\n32 35\n25 29\n46 48\n38 41\n36 37\n18 20\n5 10\n44 45\n30 31\n21 24\n", "20\n30 31\n1 3\n33 34\n5 7\n17 19\n13 15\n29 29\n23 24\n20 22\n10 10\n4 4\n32 32\n16 16\n35 37\n41 42\n27 28\n38 40\n11 12\n25 26\n8 9\n", "4\n31 44\n1 10\n11 18\n19 30\n", "3\n19 33\n1 7\n8 18\n", "5\n34 36\n2 5\n10 14\n23 26\n40 44\n", "5\n35 38\n5 9\n19 24\n30 33\n40 44\n", "50\n49 49\n1 1\n17 17\n3 3\n9 9\n48 48\n14 14\n23 23\n37 37\n21 21\n24 24\n28 28\n8 8\n31 31\n30 30\n45 45\n41 41\n40 40\n12 12\n4 4\n39 39\n50 50\n33 33\n2 2\n18 18\n20 20\n34 34\n16 16\n15 15\n44 44\n36 36\n29 29\n11 11\n46 46\n7 7\n25 25\n22 22\n35 35\n5 5\n6 6\n42 42\n19 19\n13 13\n27 27\n47 47\n26 26\n43 43\n38 38\n32 32\n10 10\n", "50\n49 49\n1 1\n17 17\n3 3\n9 9\n48 48\n14 14\n23 23\n37 37\n21 21\n24 24\n28 28\n8 8\n31 31\n30 30\n45 45\n41 41\n40 40\n12 12\n4 4\n39 39\n50 50\n33 33\n2 2\n18 18\n20 20\n34 34\n16 16\n15 15\n44 44\n36 36\n29 29\n11 11\n46 46\n7 7\n25 25\n22 22\n35 35\n5 5\n6 6\n42 42\n19 19\n13 13\n27 27\n47 47\n26 26\n43 43\n38 38\n32 32\n10 10\n", "2\n37 42\n9 10\n", "2\n20 41\n8 15\n", "3\n43 47\n7 13\n30 31\n", "4\n33 41\n4 11\n17 20\n27 27\n", "1\n31 32\n", "2\n34 50\n6 25\n", "2\n37 39\n33 35\n", "50\n49 49\n1 1\n17 17\n3 3\n9 9\n48 48\n14 14\n23 23\n37 37\n21 21\n24 24\n28 28\n8 8\n31 31\n30 30\n45 45\n41 41\n40 40\n12 12\n4 4\n39 39\n50 50\n33 33\n2 2\n18 18\n20 20\n34 34\n16 16\n15 15\n44 44\n36 36\n29 29\n11 11\n46 46\n7 7\n25 25\n22 22\n35 35\n5 5\n6 6\n42 42\n19 19\n13 13\n27 27\n47 47\n26 26\n43 43\n38 38\n32 32\n10 10\n", "25\n29 29\n1 1\n33 33\n5 5\n17 17\n13 13\n27 27\n45 45\n43 43\n41 41\n47 47\n31 31\n15 15\n49 49\n39 39\n25 25\n37 37\n11 11\n23 23\n7 7\n9 9\n19 19\n21 21\n3 3\n35 35\n", "12\n4 4\n1 1\n12 12\n3 3\n9 9\n7 7\n6 6\n11 11\n10 10\n5 5\n2 2\n8 8\n", "3\n4 5\n1 1\n2 2\n", "2\n3 3\n1 2\n", "11\n4 4\n1 1\n8 8\n3 3\n10 10\n7 7\n6 6\n12 12\n11 11\n5 5\n2 2\n"]}, "solutions": "[\"n = int(input())\\na = [int(x) for x in input().split()]\\n\\nres = {}\\n\\nfor i in range(n):\\n  sm = 0\\n  for j in range(i, n):\\n    sm += a[j]\\n    if sm in res:\\n      res[sm].append((i, j))\\n    else:\\n      res[sm] = [(i, j)]\\n\\nbest = 0\\nbestI = -1\\nfor key in res:\\n  r = -1\\n  cnt = 0\\n  for (a,b) in sorted(res[key]):\\n    if a > r:\\n      cnt += 1\\n      r = b\\n    elif b < r:\\n      r = b\\n  if cnt > best:\\n    best = cnt\\n    bestI = key\\n\\nx = []\\nr = -1\\nfor (a, b) in sorted(res[bestI]):\\n  if a > r:\\n    x.append(str(a+1) + \\\" \\\" + str(b+1))\\n    r = b\\n  elif b < r:\\n    r = b\\n    x.pop()\\n    x.append(str(a+1) + \\\" \\\" + str(b+1))\\n  \\nprint(best)\\nprint(\\\"\\\\n\\\".join(x))\\n\", \"from collections import defaultdict\\nn = int(input())\\na = list(map(int, input().split()))\\n\\nrec = defaultdict(list)\\nfor j in range(n):\\n    for k in range(j, n):\\n        rec[sum(a[j:k + 1])].append((j, k))\\n\\nans = []\\nfor k in rec.keys():\\n    tmp = []\\n    rec[k] = sorted(rec[k], key=lambda x: x[1])\\n    pre = -1\\n    for a, b in rec[k]:\\n        if pre >= a:\\n            continue\\n        else:\\n            tmp.append((a + 1, b + 1))\\n            pre = b\\n    if len(tmp) > len(ans):\\n        ans = tmp\\n\\nprint(len(ans))\\nfor a, b in ans:\\n    print(a, b)\", \"# alpha = \\\"abcdefghijklmnopqrstuvwxyz\\\"\\n# prime = 998244353 \\nINF = 100_000_000\\n# from heapq import heappush, heappop\\nfrom collections import defaultdict\\nt = 1#int(input())\\n# from math import sqrt\\n\\n\\nfor test in range(t):\\n    n = int(input())\\n    # H, n = (map(int, input().split()))\\n    # a = []\\n    # for i in range(n):\\n    # l = input()\\n    # r = input()\\n    a = (list((list(map(int, input().split())))))\\n    pre = [0 for i in range(n+1)]\\n\\n    for i in range(n):\\n        pre[i+1] = pre[i]+a[i]\\n    \\n    Sum = defaultdict(list)\\n\\n    for i in range(n):\\n        for j in range(i, n):\\n            tmp = pre[j+1]-pre[i]\\n            # print(i,j,tmp)\\n            Sum[tmp].append((i,j))\\n\\n    maxVal = 0\\n    maxSum = -1\\n    for key, val in list(Sum.items()):\\n        val.sort()\\n        tmp = 1\\n        cur = val[0][1]\\n        for i in range(1,len(val)):\\n            if val[i][0]>cur:\\n                tmp+=1\\n                cur = val[i][1]\\n            elif val[i][1]<=cur:\\n                cur = val[i][1]\\n        if maxVal < tmp:\\n            maxVal = tmp\\n            maxSum = key\\n\\n    print(maxVal)\\n    val = Sum[maxSum]\\n    val.sort()\\n    ans = []\\n    ans.append(val[0])\\n    cur = val[0][1]\\n    for i in range(1,len(val)):\\n        if val[i][0]>cur:\\n            ans.append(val[i])\\n            cur = val[i][1]\\n        elif val[i][1]<=cur:\\n            ans.pop()\\n            ans.append(val[i])\\n            cur = val[i][1]\\n    for i in ans:\\n        print(i[0]+1, i[1]+1)\\n\\n\\n\\n\", \"from collections import defaultdict as dd, deque\\nn = int(input())\\nA = [int(x) for x in input().split()]\\ncA = [0]\\nfor a in A:\\n    cA.append(cA[-1] + a)\\n\\nB = dd(list)\\n\\nfor l in range(1,n+1):\\n    for i in range(n-l+1):\\n        s = cA[i+l] - cA[i]\\n        B[s].append((i,i+l))\\n\\nbest = 0\\nbestb = None\\nfor b in sorted(B, key=lambda b: len(B[b]), reverse=True):\\n    if best > len(B[b]):\\n        break\\n    A = sorted(B[b], key=lambda x: x[1])\\n    res = 0\\n    lr = -1\\n    for l,r in A:\\n        if lr <= l:\\n            lr = r\\n            res += 1\\n\\n    if res > best:\\n        best = res\\n        bestb = b\\n\\nprint(best)\\nA = sorted(B[bestb], key=lambda x: x[1])\\nres = 0\\nlr = -1\\nfor l,r in A:\\n    if lr <= l:\\n        lr = r\\n        res += 1\\n        print(l+1,r)\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nn=int(input())\\nA=list(map(int,input().split()))\\n\\nfrom itertools import accumulate\\nSUM=list(accumulate(A))\\nSUM.append(0)\\n\\nBLIST=[[0]*n for i in range(n)]\\nB2=[]\\n\\nfor i in range(n):\\n    for j in range(i,n):\\n        BLIST[i][j]=SUM[j]-SUM[i-1]\\n        B2.append(SUM[j]-SUM[i-1])\\n\\nB2=set(B2)\\nANS=[]\\nANSLEN=0\\n\\nfor bsum in B2:\\n    i=0\\n    j=0\\n    CANDI=[]\\n    USED=-1\\n\\n    for i in range(n):\\n        for j in range(USED+1,i+1):\\n            if BLIST[j][i]==bsum:\\n                CANDI.append([j+1,i+1])\\n                USED=i\\n                break\\n\\n    if len(CANDI)>ANSLEN:\\n        ANS=CANDI\\n        ANSLEN=len(CANDI)\\n\\nprint(len(ANS))\\nfor ans in ANS:\\n    print(*ans)\\n        \\n        \\n\", \"n = int(input())\\nA = list(map(int, input().split()))\\nif n == 1:\\n    print(1)\\n    print(1, 1)\\n    return\\nprefA = [0]\\nhah = {}\\nfor i in A:\\n    prefA.append(prefA[-1] + i)\\nfor i in range(n):\\n    for j in range(i + 1, n + 1):\\n        s = prefA[j] - prefA[i]\\n        if s not in hah:\\n            hah[s] = []\\n        hah[s].append([i + 1, j])\\n\\n\\ndef lol(a):\\n    return a[1], a[0]\\n\\n\\nansq = 0\\nbm = []\\nfor s in hah:\\n    Q = hah[s]\\n    cnt = 0\\n    Q.sort(key=lol)\\n    ans = []\\n    for i in Q:\\n        if i[0] > cnt:\\n            cnt = i[1]\\n            ans.append(i)\\n    if ansq < len(ans):\\n        ansq = len(ans)\\n        bm = ans\\nprint(ansq)\\nfor i in bm:\\n    print(*i)\\n\", \"n = int(input())\\na = [int(t) for t in input().split(' ')]\\n\\np = [0] * (n+1)\\nfor i in range(n):\\n    p[i+1] = p[i] + a[i]\\n\\nsums = set()\\nfor i in range(n):\\n    for j in range(i+1, n+1):\\n        sums.add(p[j] - p[i])\\n\\nINF = n+100\\nbest_blocks = []\\nfor s in sums:\\n    blocks = []\\n    leftmost_p = 0\\n    while leftmost_p < INF:\\n        leftmost_j = INF\\n        according_i = -1\\n        for i in range(leftmost_p, n):\\n            if i >= leftmost_j: break\\n            for j in range(i+1, n+1):\\n                if j >= leftmost_j: break\\n                if p[j] - p[i] == s and j < leftmost_j:\\n                    leftmost_j = j\\n                    according_i = i\\n\\n        leftmost_p = leftmost_j\\n        if leftmost_j < INF:\\n            blocks.append((according_i+1, leftmost_j))\\n\\n    if len(blocks) > len(best_blocks):\\n        best_blocks = blocks\\n\\nprint(len(best_blocks))\\nfor b in best_blocks:\\n    print(*b)\\n\", \"def get(arr):\\n    r = 0\\n    c = 0\\n    for i in arr:\\n        if i[0] > r:\\n            c += 1\\n            r = i[1]\\n    return c        \\n    \\nn = int(input())\\na = [int(x) for x in input().split()]\\np = [0]\\nd = {}\\nfor i in a:\\n    p.append(p[-1] + i)\\nfor i in range(len(p)):\\n    for j in range(i, len(p)):\\n        if i != j:\\n            r = p[j] - p[i]\\n            d[r] = d.get(r, []) + [(i + 1, j)]\\ns = 0\\nfor i in d:\\n    k = sorted(d[i], key=lambda x: x[1])\\n    if get(k) > s:\\n        s = get(k)\\n        ind = k\\nr = 0\\nprint(s)\\nfor i in ind:\\n    if i[0] > r:\\n        print(i[0], i[1])\\n        r = i[1]\", \"def main():\\n    n = int(input())\\n    A = list(map(int, input().split()))\\n    if n == 1:\\n        print(1)\\n        print(1, 1)\\n        return\\n    prefA = [0]\\n    hah = {}\\n    for i in A:\\n        prefA.append(prefA[-1] + i)\\n    for i in range(n):\\n        for j in range(i + 1, n + 1):\\n            s = prefA[j] - prefA[i]\\n            if s not in hah:\\n                hah[s] = []\\n            hah[s].append([i + 1, j])\\n\\n\\n    def lol(a):\\n        return a[1], a[0]\\n\\n\\n    ansq = 0\\n    bm = []\\n    for s in hah:\\n        Q = hah[s]\\n        cnt = 0\\n        Q.sort(key=lol)\\n        ans = []\\n        for i in Q:\\n            if i[0] > cnt:\\n                cnt = i[1]\\n                ans.append(i)\\n        if ansq < len(ans):\\n            ansq = len(ans)\\n            bm = ans\\n    print(ansq)\\n    for i in bm:\\n        print(i[0], i[1])\\n\\n\\nmain()\", \"n=int(input())\\narr=list(map(int,input().split()))\\ndict1={}\\nfor i in range(n):\\n\\tval=0\\n\\tfor j in range(i,n):\\n\\t\\tval+=arr[j]\\n\\t\\ttry:\\n\\t\\t\\tdict1[val].append((i,j))\\n\\t\\texcept:\\n\\t\\t\\tKeyError\\n\\t\\t\\tdict1[val]=[(i,j)]\\nans=0\\nansarr=[]\\nfor i in dict1.keys():\\n\\tif(len(dict1[i])>ans):\\n\\t\\tarr2=[]\\n\\t\\tfor j in range(len(dict1[i])):\\n\\t\\t\\tarr2.append((dict1[i][j][1]-dict1[i][j][0],j))\\n\\t\\tarr2.sort()\\n\\t\\ttemp=[]\\n\\t\\tfor j in range(len(arr2)):\\n\\t\\t\\tflag=0\\n\\t\\t\\tindexi=dict1[i][arr2[j][1]][0]\\n\\t\\t\\tindexj=dict1[i][arr2[j][1]][1]\\n\\t\\t\\tfor k in range(len(temp)):\\n\\t\\t\\t\\tif(temp[k][0]<=indexi<=temp[k][1] or temp[k][0]<=indexj<=temp[k][1] or indexi<=temp[k][0]<=indexj or indexi<=temp[k][1]<=indexj):\\n\\t\\t\\t\\t\\tflag=1\\n\\t\\t\\tif(flag==0):\\n\\t\\t\\t\\ttemp.append((indexi,indexj))\\n\\t\\tif(len(temp)>ans):\\n\\t\\t\\tans=len(temp)\\n\\t\\t\\tansarr=temp\\nprint(ans)\\nfinalans=[]\\nfor i in range(len(ansarr)):\\n\\tfinalans.append(ansarr[i][0]+1)\\n\\tfinalans.append(ansarr[i][1]+1)\\nprint(*finalans)\", \"n=int(input())\\narr=list(map(int,input().split()))\\ndict1={}\\nfor i in range(n):\\n\\tval=0\\n\\tfor j in range(i,n):\\n\\t\\tval+=arr[j]\\n\\t\\ttry:\\n\\t\\t\\tdict1[val].append((i,j))\\n\\t\\texcept:\\n\\t\\t\\tKeyError\\n\\t\\t\\tdict1[val]=[(i,j)]\\nans=0\\nansarr=[]\\nfor i in list(dict1.keys()):\\n\\t#print(i,len(dict1[i]))\\n\\tif(len(dict1[i])>ans):\\n\\t\\tarr2=[]\\n\\t\\tfor j in range(len(dict1[i])):\\n\\t\\t\\tcount=0\\n\\t\\t\\tfor k in range(len(dict1[i])):\\n\\t\\t\\t\\tif(dict1[i][k][0]<=dict1[i][j][0]<=dict1[i][k][1] or dict1[i][k][0]<=dict1[i][j][1]<=dict1[i][k][1]  or dict1[i][j][0]<=dict1[i][k][0]<=dict1[i][j][1]  or dict1[i][j][0]<=dict1[i][k][1]<=dict1[i][j][1]):\\n\\t\\t\\t\\t\\tcount+=1\\n\\t\\t\\tarr2.append((count,j))\\n\\t\\tarr2.sort()\\n\\t\\ttemp=[]\\n\\t\\tfor j in range(len(arr2)):\\n\\t\\t\\tflag=0\\n\\t\\t\\tindexi=dict1[i][arr2[j][1]][0]\\n\\t\\t\\tindexj=dict1[i][arr2[j][1]][1]\\n\\t\\t\\tfor k in range(len(temp)):\\n\\t\\t\\t\\tif(temp[k][0]<=indexi<=temp[k][1] or temp[k][0]<=indexj<=temp[k][1] or indexi<=temp[k][0]<=indexj or indexi<=temp[k][1]<=indexj):\\n\\t\\t\\t\\t\\tflag=1\\n\\t\\t\\tif(flag==0):\\n\\t\\t\\t\\ttemp.append((indexi,indexj))\\n\\t\\tif(len(temp)>ans):\\n\\t\\t\\tans=len(temp)\\n\\t\\t\\tansarr=temp\\nprint(ans)\\nfinalans=[]\\nfor i in range(len(ansarr)):\\n\\tfinalans.append(ansarr[i][0]+1)\\n\\tfinalans.append(ansarr[i][1]+1)\\nprint(*finalans)\\n\\n\\n\", \"n=int(input())\\narr=list(map(int,input().split()))\\ndict1={}\\nfor i in range(n):\\n\\tval=0\\n\\tfor j in range(i,n):\\n\\t\\tval+=arr[j]\\n\\t\\ttry:\\n\\t\\t\\tdict1[val].append((i,j))\\n\\t\\texcept:\\n\\t\\t\\tKeyError\\n\\t\\t\\tdict1[val]=[(i,j)]\\nans=0\\nansarr=[]\\nfor i in list(dict1.keys()):\\n\\t#print(i,len(dict1[i]))\\n\\tif(len(dict1[i])>ans):\\n\\t\\tarr2=[]\\n\\t\\tfor j in range(len(dict1[i])):\\n\\t\\t\\tcount=0\\n\\t\\t\\tfor k in range(len(dict1[i])):\\n\\t\\t\\t\\tif(dict1[i][k][0]<=dict1[i][j][0]<=dict1[i][k][1] or dict1[i][k][0]<=dict1[i][j][1]<=dict1[i][k][1]  or dict1[i][j][0]<=dict1[i][k][0]<=dict1[i][j][1]  or dict1[i][j][0]<=dict1[i][k][1]<=dict1[i][j][1]):\\n\\t\\t\\t\\t\\tcount+=1\\n\\t\\t\\tarr2.append((count,j))\\n\\t\\tarr2.sort()\\n\\t\\ttemp=[]\\n\\t\\tfor j in range(len(arr2)):\\n\\t\\t\\tflag=0\\n\\t\\t\\tindexi=dict1[i][arr2[j][1]][0]\\n\\t\\t\\tindexj=dict1[i][arr2[j][1]][1]\\n\\t\\t\\tfor k in range(len(temp)):\\n\\t\\t\\t\\tif(temp[k][0]<=indexi<=temp[k][1] or temp[k][0]<=indexj<=temp[k][1] or indexi<=temp[k][0]<=indexj or indexi<=temp[k][1]<=indexj):\\n\\t\\t\\t\\t\\tflag=1\\n\\t\\t\\tif(flag==0):\\n\\t\\t\\t\\ttemp.append((indexi,indexj))\\n\\t\\tif(len(temp)>ans):\\n\\t\\t\\tans=len(temp)\\n\\t\\t\\tansarr=temp\\nprint(ans)\\nfinalans=[]\\nfor i in range(len(ansarr)):\\n\\tfinalans.append(ansarr[i][0]+1)\\n\\tfinalans.append(ansarr[i][1]+1)\\nprint(*finalans)\\n\\n\\n\", \"from collections import defaultdict\\nn = int(input())\\nnums = [int(x) for x in input().split()]\\nmapas = [defaultdict(list) for _ in range(n)]\\nfor i, nu in enumerate(nums):\\n\\tif i:\\n\\t\\tmapas[i] = defaultdict(list, mapas[i-1])\\n\\t# print(mapas[i])\\n\\tmapas[i][nu] = mapas[i][nu] + [(i+1,i+1)]\\n\\tsu = nu\\n\\tfor j in reversed(range(1, i)):\\n\\t\\tsu += nums[j]\\n\\t\\t# if su == -2:\\n\\t\\t# \\tprint(nu, 1+j, i+1, mapas[j-1][su])\\n\\t\\tif len(mapas[j-1][su])+1 > len(mapas[i][su]):\\n\\t\\t\\tmapas[i][su] = mapas[j-1][su] + [(j+1, i+1)]\\n\\t# print(su)\\n\\tif i:\\n\\t\\tsu += nums[0]\\n\\t\\t# print(su, mapas[i])\\n\\t\\tif len(mapas[i][su]) == 0:\\n\\t\\t\\tmapas[i][su] = [(1, i+1)]\\n\\t# print(mapas[i])\\n\\t# print()\\n\\t# mapas[i][su] = max(1, mapas[i][su])\\nmx, my = -1,-1\\n# print(mapas[-1])\\nfor x, y in mapas[-1].items():\\n\\tif len(y)> my:\\n\\t\\tmx, my = x, len(y)\\n# print(mx, my)\\nprint(my)\\n# print(mapas[-1][mx])\\nfor a, b in mapas[-1][mx]:\\n\\tprint(a, b)\", \"from collections import defaultdict\\nn = int(input())\\nnums = [int(x) for x in input().split()]\\nmapas = [defaultdict(list) for _ in range(n)]\\nfor i, nu in enumerate(nums):\\n\\tif i:\\n\\t\\tmapas[i] = defaultdict(list, mapas[i-1])\\n\\t# print(mapas[i])\\n\\tmapas[i][nu] = mapas[i][nu] + [(i+1,i+1)]\\n\\tsu = nu\\n\\tfor j in reversed(range(1, i)):\\n\\t\\tsu += nums[j]\\n\\t\\t# if su == -2:\\n\\t\\t# \\tprint(nu, 1+j, i+1, mapas[j-1][su])\\n\\t\\tif len(mapas[j-1][su])+1 > len(mapas[i][su]):\\n\\t\\t\\tmapas[i][su] = mapas[j-1][su] + [(j+1, i+1)]\\n\\t# print(su)\\n\\tif i:\\n\\t\\tsu += nums[0]\\n\\t\\t# print(su, mapas[i])\\n\\t\\tif len(mapas[i][su]) == 0:\\n\\t\\t\\tmapas[i][su] = [(1, i+1)]\\n\\t# print(mapas[i])\\n\\t# print()\\n\\t# mapas[i][su] = max(1, mapas[i][su])\\nmx, my = -1,-1\\n# print(mapas[-1])\\nfor x, y in mapas[-1].items():\\n\\tif len(y)> my:\\n\\t\\tmx, my = x, len(y)\\n# print(mx, my)\\nprint(my)\\n# print(mapas[-1][mx])\\nfor a, b in mapas[-1][mx]:\\n\\tprint(a, b)\", \"n=int(input())\\na=list(map(int,input().split()))\\ndic={}\\nfor i in range(n):\\n    sm=0\\n    for j in range(i,n):\\n        sm+=a[j]\\n        if sm in dic:\\n            dic[sm].append((i,j))\\n        else:\\n            dic[sm]=[(i,j)]\\nans=0\\nanskey=-1\\nfor key in dic:\\n    cnt=0\\n    last=-1\\n    for a,b in sorted(dic[key]):\\n        if a>last:\\n            cnt+=1\\n            last=b\\n        elif b<last:\\n            last=b\\n    if cnt>ans:\\n        ans=cnt\\n        anskey=key\\nlast=-1\\ntmp=[]\\nfor a,b in sorted(dic[anskey]):\\n    if a>last:\\n        last=b\\n        tmp.append(str(a+1)+\\\" \\\"+str(b+1))\\n    elif b<last:\\n        last=b\\n        tmp.pop()\\n        tmp.append(str(a+1)+\\\" \\\"+str(b+1))\\nprint(ans,'\\\\n'.join(tmp),sep='\\\\n')\", \"# import time\\ndef index(key, item, index):\\n    if key in index:\\n        index[key].add(item)\\n    else:\\n        index[key] = set([item])\\n\\ndef schedule(times):\\n    index_by_a = {}\\n    index_by_b = {}\\n    result_indexs = []\\n    for i in range(len(times)):\\n        a, b = times[i]\\n        index(a, i, index_by_a)\\n        index(b, i, index_by_b)\\n    b_keys = sorted(list(index_by_b.keys()))\\n    # a_keys = sorted(list(index_by_a.keys()))\\n    a_min = 0\\n    while 1:\\n        # collect pool\\n        pool = set()\\n        for k, v in index_by_a.items():\\n            if k >= a_min:\\n                pool |= v\\n        if not pool:\\n            break\\n        # greedy select.\\n        for k in (ele for ele in b_keys if ele > a_min):\\n            candidates = pool & index_by_b[k]\\n            if candidates:\\n                chosen = candidates.pop()\\n                result_indexs.append(chosen)\\n                a, b = times[chosen]\\n                a_min = b\\n                break\\n    return [times[i] for i in result_indexs]\\n                \\ndef test_schedule():\\n    i = ((0, 4), (2, 4), (0, 2), (0, 1), (1, 2), (2, 3), (3, 4))\\n    result = schedule(i)\\n    print('len:', len(result))\\n    for ele in result:\\n        print(ele)\\n\\ndef solve(n, a_l):\\n    index_by_sum = {}\\n    for i in range(n):\\n        sum_ = 0\\n        for j in range(i + 1, n + 1):\\n            sum_ += a_l[j - 1]\\n            if sum_ in index_by_sum:\\n                index_by_sum[sum_].append((i, j))\\n            else:\\n                index_by_sum[sum_] = [(i, j)]\\n    result = []\\n    for sum_, times in index_by_sum.items():\\n        sub_result = schedule(times)\\n        if len(sub_result) > len(result):\\n            result = sub_result\\n    return result\\n\\ndef main():\\n    n = int(input())\\n    a_l = list(map(int, input().split()))\\n    # tick = time.time()\\n    result = solve(n, a_l)\\n    print(len(result))\\n    for a, b in result:\\n        print(a + 1, b)\\n    # tock = time.time()\\n    # print('T:', round(tock - tick, 5))\\n\\ndef __starting_point():\\n    main()\\n__starting_point()\", \"from bisect import insort\\nn = int(input())\\na = list(map(int,input().split()))\\ncm=[0]*(n+1)\\nfor i in range(n):\\n    cm[i+1] = cm[i]+a[i]\\nd = dict()\\nfor i in range(n):\\n    for j in range(i,n):\\n        sm = cm[j+1]-cm[i]\\n        if sm in d:\\n           insort(d[sm],(j,i))\\n        else:\\n           d[sm]=[(j,i)]\\nans = 0\\narr=list()\\ntmparr=[None]*n\\nfor sm in d:\\n    ct=0\\n    end=-1\\n    for el in d[sm]:\\n        if el[1]>end:\\n           #print(ct,el)\\n           tmparr[ct]=el\\n           ct+=1\\n           end=el[0]\\n    if ct>ans:\\n       #print(sm)\\n       ans=ct\\n       #print(tmparr[:ans])\\n       arr=tmparr[:ans]\\n#print(d)\\nprint(ans)\\nfor el in arr:\\n    print(el[1]+1,el[0]+1)\", \"def func(arr):\\n  count=0\\n  biggest=-1\\n  store=[]\\n  for x in range(len(arr)):\\n    if arr[x][0]>biggest:\\n      store.append(arr[x])\\n      biggest=arr[x][1]\\n      count+=1\\n  return count,store\\ndef main():\\n  n=int(input())\\n  arr=input().split()\\n  store=[]\\n  for x in range(n):\\n    arr[x]=int(arr[x])\\n    total=0\\n    for y in range(x,-1,-1):\\n      total+=arr[y]\\n      bo=True\\n      for z in range(len(store)):\\n        if total==store[z][0]:\\n          bo=False\\n          store[z][1].append((y,x))\\n      if bo:\\n        store.append([total,[(y,x)]])\\n  #print(store)\\n  biggest=0\\n  big_val=[]\\n  for  x in range(len(store)):\\n    test,test_s=func(store[x][1])\\n    if test>biggest:\\n      biggest=test\\n      big_val=test_s\\n  print(biggest)\\n  for x in range(len(big_val)):\\n    print(big_val[x][0]+1,big_val[x][1]+1)\\n  \\nmain()\\n\", \"from collections import defaultdict\\nfrom itertools import accumulate\\n\\nN = int(input())\\nH = defaultdict(lambda: [])\\nA = list(map(int, input().split()))\\nAA = [0] + list(accumulate(A))\\nfor i in range(1, N+1):\\n    for j in range(i):\\n        H[AA[i] - AA[j]].append((i, j)) \\nctr = 0\\nans = []\\nfor L in list(H.values()):\\n    if ctr >= len(L):\\n        continue\\n    L.sort()\\n    ansc = []\\n    pi = -1\\n    for i, j in L:\\n        if j >= pi:\\n            ansc.append((j+1, i))\\n            pi = i\\n    if ctr < len(ansc):\\n        ans = ansc.copy()\\n        ctr = len(ans)\\nprint(ctr)\\nfor j, i in ans:\\n    print(j, i)\\n\", \"franxx = int(input())\\n\\nlife = input()\\nlife = life.split()\\n\\ndarling = {}\\n\\nfor i in range(0, franxx):\\n\\ttmp = 0\\n\\tfor j in range(i, franxx):\\n\\t\\ttmp += int(life[j])\\n\\t\\tdarling[tmp] = (franxx, 0)\\n\\nfor i in range(franxx, 0, -1):\\n\\ttmp = 0\\n\\tfor j in range(i - 1, franxx):\\n\\t\\ttmp += int(life[j])\\n\\t\\tif (darling[tmp][0] > j):\\n\\t\\t\\tdarling[tmp] = (i - 1, 1 + darling[tmp][1])\\n\\n\\noh_pay = \\\"I love my darling\\\"\\n\\nfor i in range(0, franxx):\\n\\ttmp = 0\\n\\tfor j in range(i, franxx):\\n\\t\\ttmp += int(life[j])\\n\\t\\tif (oh_pay == \\\"I love my darling\\\" or darling[tmp][1] > darling[oh_pay][1]):\\n\\t\\t\\toh_pay = tmp\\n\\n\\nprint(darling[oh_pay][1])\\ndarling[oh_pay] = (franxx, 0)\\n\\nfor i in range(franxx, 0, -1):\\n\\ttmp = 0\\n\\tfor j in range(i - 1, franxx):\\n\\t\\ttmp += int(life[j])\\n\\t\\tif (tmp != oh_pay):\\n\\t\\t\\tcontinue;\\n\\t\\tif (darling[oh_pay][0] > j):\\n\\t\\t\\tprint(i, j + 1)\\n\\t\\t\\tdarling[oh_pay] = (i - 1, 1 + darling[oh_pay][1])\", \"franxx = int(input())\\n\\nlife = input()\\nlife = life.split()\\n\\ndarling = {}\\n\\nfor i in range(0, franxx):\\n\\ttmp = 0\\n\\tfor j in range(i, franxx):\\n\\t\\ttmp += int(life[j])\\n\\t\\tdarling[tmp] = (franxx, 0)\\n\\t\\t\\noh_pay = \\\"I love my darling\\\"\\n\\nfor i in range(franxx, 0, -1):\\n\\ttmp = 0\\n\\tfor j in range(i - 1, franxx):\\n\\t\\ttmp += int(life[j])\\n\\t\\tif (darling[tmp][0] > j):\\n\\t\\t\\tdarling[tmp] = (i - 1, 1 + darling[tmp][1])\\n\\t\\t\\tif (oh_pay == \\\"I love my darling\\\" or darling[tmp][1] > darling[oh_pay][1]):\\n\\t\\t\\t\\toh_pay = tmp\\n\\nprint(darling[oh_pay][1])\\ndarling[oh_pay] = (franxx, 0)\\n\\nfor i in range(franxx, 0, -1):\\n\\ttmp = 0\\n\\tfor j in range(i - 1, franxx):\\n\\t\\ttmp += int(life[j])\\n\\t\\tif (tmp != oh_pay):\\n\\t\\t\\tcontinue;\\n\\t\\tif (darling[oh_pay][0] > j):\\n\\t\\t\\tprint(i, j + 1)\\n\\t\\t\\tdarling[oh_pay] = (i - 1, 1 + darling[oh_pay][1])\", \"#!/bin/python3\\n\\nimport math\\nimport os\\nimport random\\nimport re\\nimport sys\\nfrom collections import defaultdict\\n\\n\\ndef find_max_non_intersecting(segments):\\n    n = len(segments)\\n\\n    r = -1\\n    result = []\\n    for i in range(n):\\n        a, b = segments[i]\\n        if a > r:\\n            result.append((a, b))\\n            r = b\\n\\n    return result\\n\\n\\ndef __starting_point():\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n\\n    s = []\\n    for ai in a:\\n        s.append((s[-1] if s else 0) + ai)\\n\\n    d = defaultdict(list)\\n    for j in range(n):\\n        for i in range(j + 1):\\n            d[s[j] - (s[i - 1] if i - 1 >= 0 else 0)].append((i, j))\\n\\n    vals = []\\n    for v in d.values():\\n        non_inters = find_max_non_intersecting(v)\\n        if len(non_inters) > len(vals):\\n            vals = non_inters\\n\\n    print(len(vals))\\n    for l, r in vals:\\n        print(l + 1, r + 1)\\n__starting_point()\", \"# -*- coding: utf-8 -*-\\n# @Time    : 2019/3/19 23:30\\n# @Author  : LunaFire\\n# @Email   : gilgemesh2012@gmail.com\\n# @File    : F1. Same Sum Blocks (Easy).py\\n\\nfrom collections import defaultdict\\n\\n\\ndef main():\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n\\n    sum_dict = defaultdict(list)\\n    for r in range(n):\\n        tmp = 0\\n        for l in range(r, -1, -1):\\n            tmp += a[l]\\n            sum_dict[tmp].append((l + 1, r + 1))\\n\\n    ret, blocks = 0, []\\n    for k, v in list(sum_dict.items()):\\n        right, tmp = -1, 0\\n        curr_list = []\\n        for s in v:\\n            if s[0] > right:\\n                tmp += 1\\n                curr_list.append(s)\\n                right = s[1]\\n        if tmp > ret:\\n            ret = tmp\\n            blocks = curr_list\\n\\n    print(ret)\\n    for s in blocks:\\n        print(*s)\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"n=int(input())\\n\\na=[int(i) for i in input().split()]\\n\\npref=[0]\\n\\nd={}\\n\\nfor x in range(len(a)):\\n\\tpref.append(pref[x]+a[x])\\n\\nfor r in range(n):\\n\\tfor l in range(0,r+1):\\n\\t\\tv=pref[r+1]-pref[l]\\n\\n\\t\\tif(v in d):\\n\\t\\t\\td[v].append([l,r])\\n\\t\\telse:\\n\\t\\t\\td[v]=[[l,r]]\\n\\nmaxi=-2\\n\\nmax_set=[]\\n\\nfor key in d:\\n\\n\\tstart=-1\\n\\n\\ttmp_set=[]\\n\\n\\tctr=0\\n\\n\\tfor e in range(len(d[key])):\\n\\n\\t\\tif(d[key][e][0]>start):\\n\\t\\t\\ttmp_set.append(d[key][e])\\n\\t\\t\\tstart=d[key][e][1]\\n\\t\\t\\tctr+=1\\n\\n\\tif(ctr>maxi):\\n\\t\\tmaxi=ctr\\n\\t\\tmax_set=tmp_set\\n\\nprint(maxi)\\nfor w in range(maxi):\\n\\tprint(max_set[w][0]+1,max_set[w][1]+1)\\n\\n\\n\", \"from itertools import accumulate\\n\\nn = int(input())\\narr = list(map(int, input().split()))\\narr_sums = [0] + list(accumulate(arr))\\n\\nblocks = {}\\nfor i in range(1, n+1):\\n    for j in range(i):\\n        total = arr_sums[i] - arr_sums[j]\\n        if total not in blocks:\\n            blocks[total] = [(j+1, i)]\\n        else:\\n            if blocks[total][-1][1] < j+1:\\n                blocks[total].append((j+1, i))\\n\\nmax_block = sorted([(i, len(x)) for i, x in list(blocks.items())], key=lambda y: (-y[1], y[0]))\\nprint(max_block[0][1])\\nfor item in blocks[max_block[0][0]]:\\n    print(item[0], item[1])\\n\\n\"]", "task": "apps", "difficulty": "introductory", "split": "test", "transformation_type": "plain_summary"}