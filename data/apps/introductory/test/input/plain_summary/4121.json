{"qid": 4121, "orig_input": "Vova's family is building the Great Vova Wall (named by Vova himself). Vova's parents, grandparents, grand-grandparents contributed to it. Now it's totally up to Vova to put the finishing touches.\n\nThe current state of the wall can be respresented by a sequence $a$ of $n$ integers, with $a_i$ being the height of the $i$-th part of the wall.\n\nVova can only use $2 \\times 1$ bricks to put in the wall (he has infinite supply of them, however).\n\nVova can put bricks horizontally on the neighboring parts of the wall of equal height. It means that if for some $i$ the current height of part $i$ is the same as for part $i + 1$, then Vova can put a brick there and thus increase both heights by 1. Obviously, Vova can't put bricks in such a way that its parts turn out to be off the borders (to the left of part $1$ of the wall or to the right of part $n$ of it).\n\nThe next paragraph is specific to the version 1 of the problem.\n\nVova can also put bricks vertically. That means increasing height of any part of the wall by 2.\n\nVova is a perfectionist, so he considers the wall completed when:\n\n  all parts of the wall has the same height;  the wall has no empty spaces inside it. \n\nCan Vova complete the wall using any amount of bricks (possibly zero)?\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the number of parts in the wall.\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^9$) \u2014 the initial heights of the parts of the wall.\n\n\n-----Output-----\n\nPrint \"YES\" if Vova can complete the wall using any amount of bricks (possibly zero).\n\nPrint \"NO\" otherwise.\n\n\n-----Examples-----\nInput\n5\n2 1 1 2 5\n\nOutput\nYES\n\nInput\n3\n4 5 3\n\nOutput\nYES\n\nInput\n2\n10 10\n\nOutput\nYES\n\nInput\n3\n1 2 3\n\nOutput\nNO\n\n\n\n-----Note-----\n\nIn the first example Vova can put a brick on parts 2 and 3 to make the wall $[2, 2, 2, 2, 5]$ and then put 3 bricks on parts 1 and 2 and 3 bricks on parts 3 and 4 to make it $[5, 5, 5, 5, 5]$.\n\nIn the second example Vova can put a brick vertically on part 3 to make the wall $[4, 5, 5]$, then horizontally on parts 2 and 3 to make it $[4, 6, 6]$ and then vertically on part 1 to make it $[6, 6, 6]$.\n\nIn the third example the wall is already complete.", "input": "Determine if a wall can be completed using 2x1 bricks, placed horizontally or vertically, to make all parts equal height without gaps.", "test_cases": {"inputs": ["5\n2 1 1 2 5\n", "3\n4 5 3\n", "2\n10 10\n", "3\n1 2 3\n", "10\n1 9 7 6 2 4 7 8 1 3\n", "1\n1\n", "1\n2\n", "3\n2 1 2\n", "2\n1 2\n", "5\n1 2 2 1 2\n", "5\n5 2 5 2 6\n", "4\n3 3 3 4\n", "3\n1 1 1\n", "5\n2 1 1 2 1\n", "2\n99999999 99999998\n", "5\n1 1 2 1 2\n", "4\n1 2 2 2\n", "5\n1 2 2 2 2\n", "6\n3 3 4 4 3 4\n", "5\n2 10 6 9 4\n", "7\n10 2 3 4 2 8 8\n", "9\n2 5 1 9 6 5 7 3 1\n"], "outputs": ["YES\n", "YES\n", "YES\n", "NO\n", "NO\n", "YES\n", "YES\n", "NO\n", "NO\n", "YES\n", "NO\n", "NO\n", "YES\n", "YES\n", "NO\n", "NO\n", "NO\n", "YES\n", "NO\n", "NO\n", "YES\n", "NO\n"]}, "solutions": "[\"n = int(input())\\na = list(map(int, input().split()))\\nq = (10 ** 6) * [-1]\\npnt = -1\\nans = \\\"YES\\\"\\nfor i in range(n):\\n    if pnt == -1:\\n        pnt += 1\\n        q[pnt] = a[i]\\n    else :\\n        if q[pnt] == a[i] or abs(q[pnt] - a[i]) % 2 == 0:\\n            q[pnt] = -1\\n            pnt -= 1\\n        else:\\n            pnt += 1\\n            q[pnt] = a[i]\\nif pnt > 0 :\\n    ans = \\\"NO\\\"\\nprint(ans)\\n        \\n\", \"n=int(input())\\na=list(map(int,input().split()))\\nb=0\\nfor i in range(n):\\n    if a[i]%2==1:\\n        if i%2==0:\\n            b+=1\\n        else:\\n            b-=1\\nif n%2==0:\\n    if b==0:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\nelse:\\n    if b==0 or b==1:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\", \"#!/usr/bin/env python\\n# coding: utf-8\\n\\n# In[4]:\\n\\n\\nimport math\\nn=int(input())\\ncolumns=list(map(int, input().rstrip().split()))\\n\\n\\n# In[5]:\\n\\n\\nmodcolumns=[i%2 for i in columns]\\n\\n\\n# In[6]:\\n\\n\\ntest=0\\n\\n\\n# In[7]:\\n\\n\\npreviouslist=[]\\n\\n\\nfor i in range(0,n):\\n    if len(previouslist)==0:\\n        previouslist.append(modcolumns[i])\\n        \\n    elif modcolumns[i]==previouslist[-1]:\\n        previouslist.pop()\\n        \\n    else:\\n        previouslist.append(modcolumns[i])\\n    \\n    \\n    \\n    \\n        \\nif len(previouslist)<=1:\\n    print(\\\"YES\\\")\\nelse:\\n    print(\\\"NO\\\")\\n\\n\\n# In[ ]:\\n\\n\\n\", \"n = int(input())\\na = list(map(int, input().split()))\\nb = []\\nfor i in range(n):\\n    a[i] %= 2\\n    if len(b) != 0:\\n        if b[-1] == a[i]:\\n            b.pop()\\n        else:\\n            b.append(a[i])\\n    else:\\n        b.append(a[i])\\nif len(b) > 1:\\n    print(\\\"NO\\\")\\nelse:\\n    print(\\\"YES\\\")\\n\", \"n = int(input())\\na = [int(_) & 1 for _ in input().split()]\\nv = [a[0]]\\nfor i in range(1, n):\\n    if v and v[-1] == a[i]:\\n        v.pop()\\n    else:\\n        v.append(a[i])\\nprint(\\\"NO\\\" if len(v) > 1 else \\\"YES\\\")\\n\", \"i = int(input())\\ns = input().split()\\n\\nl = []\\nfor j in s:\\n    if not l or  int(j)%2 != l[-1]:\\n        l.append(int(j)%2)\\n    else:\\n        l.pop()\\n\\nif len(l) < 2:\\n    print('YES')\\nelse:\\n    print('NO')\\n\\n\\n\", \"i,p=input,print;n,b,q=int(i()),[int(x)&1 for x in i().split()],[];f=q.append;f(b[0])\\nfor a in b[1:]:q.pop() if q and q[-1] == a else f(a)\\np('NO'if len(q)>1 else'YES')\", \"i = int(input())\\ns = input().split()\\n\\nl = []\\nfor j in s:\\n    if not l or  int(j)%2 != l[-1]:\\n        l.append(int(j)%2)\\n    else:\\n        l.pop()\\n\\nif len(l) < 2:\\n    print('YES')\\nelse:\\n    print('NO')\\n\", \"def f():\\n    b = [a[0]]\\n    for e in a[1:]:\\n        if b != []:\\n            if e == b[-1] or abs(e-b[-1])%2==0:\\n                b.pop()\\n\\n            else:\\n                b.append(e)\\n        else:\\n            b.append(e)\\n\\n    for i in range(1,len(b)):\\n        if abs(b[i]-b[i-1])%2:\\n            print('NO')\\n            return\\n\\n    print('YES')\\n\\nn=int(input())\\na=[int(i) for i in input().split()]\\n\\n\\nf()\", \"n=int(input())\\na=list(map(int,input().split()))\\nst=[a[0]]\\nfor i in range(1,n):\\n    if len(st)>0 and st[-1]%2==a[i]%2:\\n        st.pop()\\n    else:\\n        st.append(a[i])\\nif len(st)<=1:\\n    print(\\\"YES\\\")\\nelse:\\n    print(\\\"NO\\\")\\n\", \"n=int(input())\\nl=[int(x) for x in  input().split()]\\nst=[]\\nfor i in l:\\n    d=i%2\\n    if len(st) and st[-1]==d:\\n        st.pop()\\n    else:\\n        st.append(d)\\nif len(st)<2:\\n    print(\\\"YES\\\")\\nelse:\\n    print(\\\"NO\\\")\", \"# cook your dish here\\nn = int(input())\\n\\narr = list(map(int, input().split()))\\narr = list([x%2 for x in arr])\\n\\nstack = []\\n\\nfor i in range(n):\\n    if len(stack):\\n        if stack[-1] == arr[i]:\\n            stack.pop()\\n        else:\\n            stack.append(arr[i])\\n    else:\\n        stack.append(arr[i])\\n\\nif len(stack) == 0 or len(stack) == 1:\\n    print(\\\"YES\\\")\\n\\nelse:\\n    print(\\\"NO\\\")\\n\", \"n=int(input())\\na=list(map(int,input().split()))\\nst=[a[0]]\\nfor i in range(1,n):\\n    if len(st)>0 and st[-1]%2==a[i]%2:\\n        st.pop()\\n    else:\\n        st.append(a[i])\\nif len(st)<=1:\\n    print(\\\"YES\\\")\\nelse:\\n    print(\\\"NO\\\")\", \"n=int(input())\\nl=[]\\nfor i in input().split():\\n    tmp=1&int(i)\\n    if l==[] or l[-1]!=tmp: l.append(tmp)\\n    else: l.pop()\\n\\nprint(\\\"YES\\\" if len(l)<2 else \\\"NO\\\")\", \"n = int(input())\\nwall = list(map(int, input().split()))\\n\\n\\n#try from left\\n#try from right\\nif n == 1:\\n    print(\\\"YES\\\")\\nelse:\\n    # update all to parity\\n    in1 = []\\n    for i in range(n):\\n        wall[i] = wall[i]%2\\n        if(wall[i] == 1):\\n            in1.append(i)\\n        \\n    if len(in1) == 0 or len(in1) == n:\\n        print(\\\"YES\\\")\\n        \\n    # fix differences in parity\\n    else:\\n        if len(in1) == 1:\\n            if (n-1) % 2 == 0 and in1[0]%2 == 0 and (n-in1[0]-1)%2 == 0:\\n                print(\\\"YES\\\")\\n            else:\\n                print(\\\"NO\\\")\\n        else:\\n            i = 0\\n            while(i+1 < len(in1)):\\n                if i >= 0 and i+1 < len(in1) and (in1[i+1]-in1[i]-1)%2 == 0:\\n                    del in1[i+1]\\n                    del in1[i]\\n                    i-=1\\n                else:\\n                    i+=1\\n            if len(in1) == 0:\\n                print(\\\"YES\\\")\\n            elif len(in1) == 1:\\n                if (n-1) % 2 == 0 and in1[0]%2 == 0 and (n-in1[0]-1)%2 == 0:\\n                    print(\\\"YES\\\")\\n                else:\\n                    print(\\\"NO\\\")\\n            else: \\n                print(\\\"NO\\\")\", \"n_input = int(input())\\nl_input = list(map(int, str(input()).split()))\\n\\nl_binary = []\\nfor _ in range(n_input):\\n    pop = l_input.pop() % 2\\n    if l_binary == []:\\n        l_binary.append(pop)\\n    elif pop == l_binary[-1]:\\n        l_binary.pop()\\n    else:\\n        l_binary.append(pop)\\ndef solve(n, l_binary):\\n    if n <= 1:\\n        return 1\\n    elif n == 2:\\n        sum_l = sum(l_binary) % 2 # if sum_l = 0 return YES else return NO\\n        return sum_l - 1\\n    else:\\n        for k in range(n-2):\\n            l_sequence = [l_binary[k], l_binary[k+1], l_binary[k+2]]\\n            if l_sequence == [0, 1, 0] or l_sequence == [1, 0, 1]:\\n                return 0\\n        return 1\\n\\nif solve(len(l_binary), l_binary):\\n    print(\\\"YES\\\")\\nelse:\\n    print(\\\"NO\\\")\\n\", \"import sys\\ninput = sys.stdin.readline\\nfrom collections import deque\\n\\nn=int(input())\\nA=list(map(int,input().split()))\\n\\nA2=[A[i]%2 for i in range(n)]\\n\\nif n==1:\\n    print(\\\"YES\\\")\\n    return\\n\\nif n==2:\\n    if A2[0]!=A2[1]:\\n        print(\\\"NO\\\")\\n        return\\n    else:\\n        print(\\\"YES\\\")\\n        return\\n\\nQUE = deque()\\n\\nfor i in range(n):\\n    QUE.append(A2[i])\\n\\n    while len(QUE)>=2 and QUE[-1]==QUE[-2]:\\n        QUE.pop()\\n        QUE.pop()\\n\\nif len(QUE)>=2:\\n    print(\\\"NO\\\")\\nelse:\\n    print(\\\"YES\\\")\\n\", \"#!/usr/bin/env python3                            \\nimport sys                                        \\n                                                  \\ndef rint():                                       \\n    return map(int, sys.stdin.readline().split()) \\n#lines = stdin.readlines()                        \\n# ae : [h, l], height, length                     \\nh = 0                                             \\nl = 1                                             \\nn = int(input())                                  \\n                                                  \\na = rint()                                        \\n                                                  \\na = [i%2 for i in a]                              \\n                                                  \\ncnt = 0                                           \\ncur = -1                                          \\nae = []                                           \\nfor i in range(n):                                \\n    if a[i] == 0:                                 \\n        if cur == 0 or cur == -1:                 \\n            cur = 0                               \\n            cnt += 1                              \\n        else:                                     \\n            ae.append([cur, cnt%2])               \\n            cnt = 1                               \\n            cur = 0                               \\n    else:                                         \\n        if cur == 1 or cur == -1:                 \\n            cur = 1                               \\n            cnt += 1                              \\n        else:                                     \\n            ae.append([cur, cnt%2])               \\n            cnt = 1                               \\n            cur = 1                               \\nae.append([cur, cnt%2])                           \\nstack = []                                        \\nfor e in ae:                                      \\n    if e[l] == 1:                                 \\n        if len(stack) == 0:                       \\n            stack.append(e[h])                    \\n        else:                                     \\n            if e[h] == stack[-1]:                 \\n                stack.pop()                       \\n            else:                                 \\n                stack.append(e[h])                \\nif len(stack) > 1:                                \\n    print(\\\"NO\\\")                                   \\nelse:                                             \\n    print(\\\"YES\\\")                                  \", \"n=int(input())\\na=list(map(int,input().split()))\\nst=[]\\nfor i in a:\\n    if len(st)>0 and st[-1]==(i&1):\\n        st.pop()\\n    else:\\n        st.append(i&1)\\nif len(st)<=1:\\n    print(\\\"YES\\\");return\\nprint(\\\"NO\\\")\", \"n=int(input())\\na=list(map(int,input().split()))\\nb=[0]*1000000\\nsp=-1\\n\\n      \\nfor i in range(n):\\n    sp=sp+1\\n    b[sp]=a[i]\\n    if sp>0:\\n        \\n        if ((b[sp]+b[sp-1])%2)==0:\\n            sp=sp-2\\n\\n    \\n\\n        \\nif sp<=0:\\n    print(\\\"YES\\\")\\nelse:\\n    print(\\\"NO\\\")\\n    \\n\\n             \\n             \\n             \\n\", \"n = int(input())\\na = [i for i in map(int, input().split(' '))]\\nmx = max(a)\\nstack = [a[0]]\\nfor i in range(1, n):\\n    if len(stack) != 0:\\n        if a[i] % 2 == stack[-1] % 2:\\n            stack.pop()\\n        else:\\n            stack.append(a[i])\\n    else:\\n        stack.append(a[i])\\nif len(stack) > 1:\\n    print('NO')\\nelse:\\n    print('YES')\\n\", \"n = int(input())\\na = list(map(int,input().split()))\\ns = []\\nfor i in range(n):\\n    a[i] = a[i] & 1\\nfor i in range(n):\\n    if len(s) == 0 or s[-1] != a[i]:\\n        s.append(a[i])\\n    else:\\n        s.pop()\\nif len(s) <= 1:\\n    print(\\\"YES\\\")\\nelse:\\n    print(\\\"NO\\\")\\n\", \"n = int(input())\\nL = [int(x)%2 for x in input().split()]\\nS = []\\ntemp = 1\\nLW = []\\nRW = []\\nClose = []\\nfor i in range(1,n):\\n    if L[i] == L[i-1]:\\n        temp +=1\\n    else:\\n        S.append(temp)\\n        temp = 1\\nS.append(temp)\\nz = 0\\nfor i in range(0,len(S)):\\n    S[i] = S[i]%2\\n    if S[i] == 0:\\n        z +=1\\n        LW.append(i)\\n        RW.append(len(S)-i-1)\\n        if len(LW) > 1:\\n            Close.append(LW[-1]-LW[-2])\\n        \\n\\nindex = 0\\nremoved = 0\\nwhile index < z-1:\\n    if Close[index] <= LW[index] - removed:\\n        removed += 2*Close[index]\\n        index += 2\\n    else:\\n        removed += 2*(LW[index]-removed)+1\\n        index += 1\\n\\nif index == z-1:\\n    if abs(LW[z-1]-removed- RW[z-1]) <= 1:\\n        print('YES')\\n    else:\\n        print('NO')\\nelse:\\n    if removed >= len(S)-1:\\n        print('YES')\\n    else:\\n        print('NO')\", \"n_input = int(input())\\nl_input = list(map(int, str(input()).split()))\\n\\nl_binary = []\\nfor _ in range(n_input):\\n    pop = l_input.pop() % 2\\n    if l_binary == []:\\n        l_binary.append(pop)\\n    elif pop == l_binary[-1]:\\n        l_binary.pop()\\n    else:\\n        l_binary.append(pop)\\n\\nn = len(l_binary)\\nif n <= 1:\\n    print(\\\"YES\\\")\\nelse:\\n    print(\\\"NO\\\")\\n\"]", "task": "apps", "difficulty": "introductory", "split": "test", "transformation_type": "plain_summary"}