{"qid": 4014, "orig_input": "Petya studies at university. The current academic year finishes with $n$ special days. Petya needs to pass $m$ exams in those special days. The special days in this problem are numbered from $1$ to $n$.\n\nThere are three values about each exam:  $s_i$ \u2014 the day, when questions for the $i$-th exam will be published,  $d_i$ \u2014 the day of the $i$-th exam ($s_i < d_i$),  $c_i$ \u2014 number of days Petya needs to prepare for the $i$-th exam. For the $i$-th exam Petya should prepare in days between $s_i$ and $d_i-1$, inclusive. \n\nThere are three types of activities for Petya in each day: to spend a day doing nothing (taking a rest), to spend a day passing exactly one exam or to spend a day preparing for exactly one exam. So he can't pass/prepare for multiple exams in a day. He can't mix his activities in a day. If he is preparing for the $i$-th exam in day $j$, then $s_i \\le j < d_i$.\n\nIt is allowed to have breaks in a preparation to an exam and to alternate preparations for different exams in consecutive days. So preparation for an exam is not required to be done in consecutive days.\n\nFind the schedule for Petya to prepare for all exams and pass them, or report that it is impossible.\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $m$ $(2 \\le n \\le 100, 1 \\le m \\le n)$ \u2014 the number of days and the number of exams.\n\nEach of the following $m$ lines contains three integers $s_i$, $d_i$, $c_i$ $(1 \\le s_i < d_i \\le n, 1 \\le c_i \\le n)$ \u2014 the day, when questions for the $i$-th exam will be given, the day of the $i$-th exam, number of days Petya needs to prepare for the $i$-th exam. \n\nGuaranteed, that all the exams will be in different days. Questions for different exams can be given in the same day. It is possible that, in the day of some exam, the questions for other exams are given.\n\n\n-----Output-----\n\nIf Petya can not prepare and pass all the exams, print -1. In case of positive answer, print $n$ integers, where the $j$-th number is:  $(m + 1)$, if the $j$-th day is a day of some exam (recall that in each day no more than one exam is conducted),  zero, if in the $j$-th day Petya will have a rest,  $i$ ($1 \\le i \\le m$), if Petya will prepare for the $i$-th exam in the day $j$ (the total number of days Petya prepares for each exam should be strictly equal to the number of days needed to prepare for it).\n\nAssume that the exams are numbered in order of appearing in the input, starting from $1$.\n\nIf there are multiple schedules, print any of them.\n\n\n-----Examples-----\nInput\n5 2\n1 3 1\n1 5 1\n\nOutput\n1 2 3 0 3 \n\nInput\n3 2\n1 3 1\n1 2 1\n\nOutput\n-1\n\nInput\n10 3\n4 7 2\n1 10 3\n8 9 1\n\nOutput\n2 2 2 1 1 0 4 3 4 4 \n\n\n\n-----Note-----\n\nIn the first example Petya can, for example, prepare for exam $1$ in the first day, prepare for exam $2$ in the second day, pass exam $1$ in the third day, relax in the fourth day, and pass exam $2$ in the fifth day. So, he can prepare and pass all exams.\n\nIn the second example, there are three days and two exams. So, Petya can prepare in only one day (because in two other days he should pass exams). Then Petya can not prepare and pass all exams.", "input": "Given exam schedules and preparation requirements, determine if it's possible to create a daily schedule for studying and taking exams, and if so, output the schedule.", "test_cases": {"inputs": ["5 2\n1 3 1\n1 5 1\n", "3 2\n1 3 1\n1 2 1\n", "10 3\n4 7 2\n1 10 3\n8 9 1\n", "2 1\n1 2 1\n", "3 1\n1 2 2\n", "3 1\n1 3 2\n", "100 1\n1 100 99\n", "100 1\n1 100 100\n", "100 1\n1 100 98\n", "100 2\n1 100 49\n1 99 49\n", "10 2\n3 7 4\n6 10 1\n", "10 4\n2 5 1\n1 4 2\n4 7 1\n7 10 2\n", "20 5\n6 16 3\n4 14 4\n3 13 1\n1 11 1\n10 20 4\n", "30 7\n1 4 1\n22 25 1\n25 28 2\n9 12 1\n13 16 1\n11 14 1\n14 17 1\n", "50 14\n42 44 2\n38 40 1\n6 8 2\n37 39 1\n33 35 1\n17 19 2\n12 14 2\n2 4 1\n9 11 2\n1 3 1\n32 34 1\n24 26 1\n44 46 1\n48 50 1\n", "50 7\n45 50 4\n26 31 5\n35 40 3\n38 43 1\n39 44 3\n3 8 2\n1 6 1\n", "50 15\n41 46 5\n35 40 5\n27 32 3\n10 15 2\n1 6 3\n20 25 1\n11 16 1\n9 14 1\n13 18 2\n18 23 3\n2 7 2\n25 30 1\n29 34 1\n43 48 1\n45 50 1\n", "90 30\n1 5 1\n57 61 3\n13 17 1\n60 64 1\n73 77 2\n5 9 2\n16 20 3\n29 33 4\n83 87 3\n63 67 2\n35 39 4\n18 22 1\n42 46 4\n46 50 2\n48 52 2\n23 27 1\n82 86 1\n77 81 3\n67 71 2\n22 26 2\n37 41 1\n6 10 1\n50 54 1\n8 12 1\n86 90 1\n68 72 1\n11 15 1\n72 76 1\n62 66 1\n52 56 1\n", "100 38\n41 43 1\n53 55 2\n91 93 2\n47 49 2\n77 79 2\n5 7 2\n2 4 2\n28 30 1\n79 81 1\n42 44 1\n27 29 1\n95 97 2\n58 60 1\n57 59 1\n61 63 2\n33 35 2\n22 24 1\n44 46 1\n10 12 2\n13 15 1\n97 99 1\n37 39 2\n18 20 1\n50 52 2\n21 23 1\n68 70 2\n83 85 1\n71 73 2\n65 67 1\n64 66 1\n15 17 1\n7 9 1\n88 90 2\n30 32 1\n74 76 1\n24 26 1\n85 87 1\n82 84 1\n", "100 43\n76 77 1\n24 25 1\n2 3 1\n85 86 1\n49 50 1\n15 16 1\n30 31 1\n78 79 1\n54 55 1\n58 59 1\n17 18 1\n67 68 1\n21 22 1\n80 81 1\n35 36 1\n8 9 1\n83 84 1\n44 45 1\n62 63 1\n64 65 1\n72 73 1\n27 28 1\n56 57 1\n12 13 1\n40 41 1\n32 33 1\n52 53 1\n70 71 1\n97 98 1\n37 38 1\n87 88 1\n46 47 1\n89 90 1\n4 5 1\n94 95 1\n60 61 1\n99 100 1\n10 11 1\n74 75 1\n6 7 1\n91 92 1\n19 20 1\n42 43 1\n", "100 35\n52 55 1\n55 58 1\n69 72 1\n32 35 1\n9 12 3\n68 71 1\n78 81 3\n51 54 1\n56 59 1\n63 66 3\n4 7 2\n12 15 2\n74 77 1\n87 90 3\n72 75 1\n93 96 2\n39 42 2\n15 18 1\n92 95 1\n23 26 3\n83 86 2\n28 31 2\n58 61 1\n47 50 1\n46 49 2\n31 34 1\n82 85 1\n96 99 2\n38 41 1\n41 44 1\n5 8 1\n34 37 1\n19 22 3\n27 30 1\n67 70 1\n", "100 4\n73 83 4\n79 89 8\n12 22 6\n23 33 9\n", "100 2\n39 43 1\n82 86 3\n", "100 36\n2 5 2\n35 38 1\n55 58 2\n40 43 3\n73 76 2\n30 33 3\n87 90 3\n93 96 1\n97 100 1\n42 45 1\n44 47 1\n66 69 3\n95 98 1\n12 15 3\n47 50 1\n72 75 1\n57 60 2\n1 4 1\n8 11 3\n15 18 1\n22 25 2\n76 79 2\n82 85 1\n91 94 2\n83 86 2\n33 36 1\n62 65 3\n26 29 3\n18 21 1\n36 39 1\n68 71 1\n50 53 1\n51 54 1\n4 7 1\n17 20 1\n78 81 1\n", "100 37\n49 51 2\n79 81 2\n46 48 2\n71 73 2\n31 33 2\n42 44 1\n17 19 2\n64 66 2\n24 26 1\n8 10 2\n38 40 1\n1 3 2\n75 77 2\n52 54 2\n11 13 2\n87 89 1\n98 100 2\n60 62 1\n56 58 2\n39 41 1\n92 94 1\n13 15 1\n67 69 2\n4 6 2\n19 21 1\n91 93 1\n86 88 1\n43 45 1\n25 27 1\n94 96 1\n81 83 1\n35 37 1\n34 36 1\n61 63 1\n21 23 1\n83 85 1\n27 29 1\n", "50 16\n42 44 2\n18 20 2\n10 12 1\n9 11 2\n25 27 1\n45 47 1\n12 14 1\n29 31 2\n4 6 1\n46 48 1\n32 34 2\n34 36 1\n48 50 1\n21 23 1\n15 17 2\n24 26 1\n", "90 29\n1 5 1\n56 60 2\n31 35 4\n86 90 2\n25 29 4\n58 62 2\n73 77 2\n12 16 2\n65 69 1\n16 20 3\n42 46 4\n62 66 2\n2 6 2\n77 81 1\n80 84 1\n48 52 4\n81 85 2\n68 72 1\n57 61 1\n75 79 1\n35 39 2\n37 41 1\n18 22 1\n4 8 2\n67 71 1\n85 89 1\n20 24 1\n10 14 2\n51 55 2\n", "100 6\n3 43 40\n46 86 24\n38 78 5\n51 91 8\n59 99 12\n60 100 2\n", "100 36\n2 5 2\n35 38 1\n55 58 2\n40 43 3\n73 76 2\n30 33 3\n87 90 3\n93 96 1\n97 100 1\n42 45 1\n44 47 1\n66 69 3\n95 98 1\n12 15 3\n47 50 1\n72 75 1\n57 60 2\n1 4 1\n8 11 3\n15 18 1\n22 25 2\n76 79 2\n82 85 1\n91 94 2\n83 86 2\n33 36 1\n62 65 3\n26 29 3\n18 21 1\n36 39 1\n68 71 1\n50 53 2\n51 54 1\n4 7 1\n17 20 1\n78 81 1\n", "100 37\n49 51 2\n79 81 2\n46 48 2\n71 73 2\n31 33 3\n42 44 1\n17 19 2\n64 66 2\n24 26 1\n8 10 2\n38 40 1\n1 3 2\n75 77 2\n52 54 2\n11 13 2\n87 89 1\n98 100 2\n60 62 1\n56 58 2\n39 41 1\n92 94 1\n13 15 1\n67 69 2\n4 6 2\n19 21 1\n91 93 1\n86 88 1\n43 45 1\n25 27 1\n94 96 1\n81 83 1\n35 37 1\n34 36 1\n61 63 1\n21 23 1\n83 85 1\n27 29 1\n", "90 30\n1 5 1\n57 61 3\n13 17 1\n60 64 1\n73 77 2\n5 9 2\n16 20 3\n29 33 5\n83 87 3\n63 67 2\n35 39 4\n18 22 1\n42 46 4\n46 50 2\n48 52 2\n23 27 1\n82 86 1\n77 81 3\n67 71 2\n22 26 2\n37 41 1\n6 10 1\n50 54 1\n8 12 1\n86 90 1\n68 72 1\n11 15 1\n72 76 1\n62 66 1\n52 56 1\n", "100 38\n41 43 1\n53 55 2\n91 93 2\n47 49 2\n77 79 2\n5 7 2\n2 4 2\n28 30 1\n79 81 1\n42 44 1\n27 29 1\n95 97 2\n58 60 1\n57 59 1\n61 63 2\n33 35 2\n22 24 1\n44 46 1\n10 12 2\n13 15 1\n97 99 1\n37 39 3\n18 20 1\n50 52 2\n21 23 1\n68 70 2\n83 85 1\n71 73 2\n65 67 1\n64 66 1\n15 17 1\n7 9 1\n88 90 2\n30 32 1\n74 76 1\n24 26 1\n85 87 1\n82 84 1\n", "100 43\n76 77 1\n24 25 1\n2 3 1\n85 86 1\n49 50 1\n15 16 1\n30 31 1\n78 79 2\n54 55 1\n58 59 1\n17 18 1\n67 68 1\n21 22 1\n80 81 1\n35 36 1\n8 9 1\n83 84 1\n44 45 1\n62 63 1\n64 65 1\n72 73 1\n27 28 1\n56 57 1\n12 13 1\n40 41 1\n32 33 1\n52 53 1\n70 71 1\n97 98 1\n37 38 1\n87 88 1\n46 47 1\n89 90 1\n4 5 1\n94 95 1\n60 61 1\n99 100 1\n10 11 1\n74 75 1\n6 7 1\n91 92 1\n19 20 1\n42 43 1\n", "100 35\n52 55 1\n55 58 1\n69 72 1\n32 35 1\n9 12 3\n68 71 1\n78 81 3\n51 54 1\n56 59 1\n63 66 3\n4 7 2\n12 15 2\n74 77 1\n87 90 3\n72 75 1\n93 96 2\n39 42 2\n15 18 1\n92 95 1\n23 26 4\n83 86 2\n28 31 2\n58 61 1\n47 50 1\n46 49 2\n31 34 1\n82 85 1\n96 99 2\n38 41 1\n41 44 1\n5 8 1\n34 37 1\n19 22 3\n27 30 1\n67 70 1\n", "97 22\n10 17 6\n24 31 6\n79 86 7\n60 67 6\n42 49 5\n67 74 5\n34 41 4\n70 77 3\n51 58 5\n82 89 2\n89 96 5\n14 21 2\n40 47 1\n1 8 2\n23 30 1\n59 66 1\n50 57 2\n26 33 1\n15 22 2\n90 97 1\n32 39 1\n2 9 4\n", "12 11\n1 2 1\n2 3 2\n3 4 3\n4 5 4\n5 6 5\n6 7 6\n7 8 7\n8 9 8\n9 10 9\n10 11 10\n11 12 1\n", "6 2\n1 6 3\n1 2 1\n", "88 1\n1 2 1\n", "4 2\n1 4 1\n1 2 1\n", "100 2\n1 100 30\n1 20 1\n", "88 1\n1 3 1\n", "6 2\n1 5 2\n2 3 1\n", "7 2\n1 7 3\n2 3 1\n", "8 2\n3 8 2\n4 5 1\n", "10 2\n1 10 7\n2 3 1\n", "5 2\n1 5 2\n2 3 1\n", "10 2\n1 10 5\n2 3 1\n", "10 2\n1 10 4\n2 4 2\n", "10 2\n1 10 6\n3 7 1\n", "10 3\n4 8 2\n1 10 3\n5 6 1\n", "20 5\n4 14 4\n3 13 1\n1 11 1\n10 20 4\n6 16 3\n", "73 2\n33 35 2\n12 63 44\n", "86 5\n66 74 1\n29 33 3\n13 78 38\n20 34 2\n72 85 1\n", "9 4\n3 7 1\n6 9 1\n2 3 1\n1 8 2\n", "10 2\n1 10 5\n2 4 1\n", "10 4\n1 10 2\n1 4 2\n2 5 1\n7 8 1\n", "10 2\n1 10 7\n3 7 1\n", "96 37\n9 43 23\n60 66 4\n7 15 1\n3 86 4\n30 65 14\n36 38 1\n28 36 8\n68 80 4\n7 22 5\n17 68 1\n7 18 1\n12 47 2\n4 6 2\n5 11 3\n41 55 10\n7 45 22\n6 67 16\n12 50 18\n64 70 2\n21 48 26\n2 17 6\n14 44 10\n63 84 18\n14 19 5\n34 92 56\n51 56 2\n13 20 5\n62 74 2\n1 3 1\n6 46 17\n58 62 4\n10 27 16\n13 37 16\n21 23 1\n48 69 13\n67 82 13\n17 51 18\n", "31 3\n2 3 1\n1 12 4\n13 15 1\n", "7 2\n2 6 4\n3 4 1\n", "20 2\n3 4 1\n2 7 3\n", "100 5\n15 53 23\n16 85 32\n59 93 3\n54 57 1\n13 40 11\n", "100 5\n24 57 8\n28 72 15\n20 75 49\n27 67 7\n68 100 21\n", "11 2\n1 11 5\n4 8 4\n", "29 5\n5 10 3\n15 22 2\n18 27 4\n16 20 4\n7 11 1\n", "28 4\n4 23 11\n11 12 1\n2 4 1\n16 24 1\n", "90 8\n7 10 2\n27 28 1\n18 20 2\n12 48 2\n37 84 27\n29 32 2\n37 73 16\n3 40 14\n", "61 2\n12 41 24\n20 29 2\n", "27 8\n7 22 2\n3 5 1\n24 26 1\n1 14 1\n4 23 8\n10 12 1\n16 18 1\n5 6 1\n", "88 8\n1 5 2\n29 50 7\n36 42 6\n72 81 2\n12 19 4\n65 73 2\n15 80 29\n4 43 16\n", "34 17\n1 2 1\n6 12 4\n22 23 1\n5 6 1\n8 30 9\n2 7 2\n22 26 3\n3 34 31\n1 19 9\n4 11 7\n2 5 1\n4 9 3\n8 14 4\n2 22 14\n3 8 5\n32 33 1\n18 31 10\n", "9 2\n3 7 2\n1 9 5\n", "85 6\n4 63 17\n1 47 2\n25 26 1\n1 8 1\n24 78 44\n39 79 4\n", "85 5\n3 44 9\n77 85 7\n3 27 8\n5 42 4\n4 7 1\n", "50 5\n7 23 7\n4 12 4\n7 46 14\n15 32 8\n16 24 2\n", "6 3\n1 5 1\n1 6 1\n1 2 1\n", "100 3\n17 21 3\n1 66 38\n8 22 2\n"], "outputs": ["1 2 3 0 3 \n", "-1\n", "2 2 2 1 1 0 4 3 4 4 \n", "1 2 \n", "-1\n", "1 1 2 \n", "1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 \n", "-1\n", "1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 2 \n", "2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 3 \n", "0 0 1 1 1 1 3 2 0 3 \n", "2 2 1 5 5 3 5 4 4 5 \n", "4 0 3 2 2 2 2 1 1 1 6 5 6 6 5 6 5 5 0 6 \n", "1 0 0 8 0 0 0 0 4 0 6 8 5 8 7 8 8 0 0 0 0 2 0 0 8 3 3 8 0 0 \n", "10 8 15 15 0 3 3 15 9 9 15 7 7 15 0 0 6 6 15 0 0 0 0 12 0 15 0 0 0 0 0 11 5 15 15 0 4 2 15 15 0 1 1 15 13 15 0 14 0 15 \n", "7 0 6 6 0 8 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 2 2 8 0 0 0 3 3 3 4 5 8 5 5 8 8 1 1 1 1 0 8 \n", "5 5 5 11 11 16 16 0 8 4 4 7 9 16 16 16 9 16 10 10 10 6 16 0 16 12 3 3 3 16 13 16 0 16 2 2 2 2 2 16 1 1 1 1 1 16 14 16 15 16 \n", "1 0 0 0 31 6 6 22 31 31 24 31 27 3 31 7 31 7 7 31 12 31 20 20 16 31 31 0 8 8 8 8 31 0 11 11 11 11 31 21 31 13 13 13 13 31 14 14 15 31 15 31 23 31 30 31 2 2 2 4 31 29 10 31 10 31 31 19 19 26 31 31 28 5 5 31 31 18 18 18 31 17 9 9 9 31 31 25 0 31 \n", "0 7 7 39 6 6 39 32 39 19 19 39 20 0 39 31 39 23 0 39 25 17 39 39 36 39 11 8 39 39 34 39 16 16 39 0 22 22 39 0 1 10 39 39 18 39 4 4 39 24 24 39 2 2 39 0 14 13 39 39 15 15 39 30 29 39 39 26 26 39 28 28 39 35 0 39 5 5 39 9 39 38 27 39 39 37 39 33 33 39 3 3 39 0 12 12 39 21 39 0 \n", "0 3 44 34 44 40 44 16 44 38 44 24 44 0 6 44 11 44 42 44 13 44 0 2 44 0 22 44 0 7 44 26 44 0 15 44 30 44 0 25 44 43 44 18 44 32 44 0 5 44 0 27 44 9 44 23 44 10 44 36 44 19 44 20 44 0 12 44 0 28 44 21 44 39 44 1 44 8 44 14 44 0 17 44 4 44 31 44 33 44 41 44 0 35 44 0 29 44 37 44 \n", "0 0 0 11 11 31 36 36 5 5 5 36 12 12 36 18 0 36 33 33 33 36 20 20 20 36 34 22 22 36 36 26 4 36 36 32 36 29 17 17 36 36 30 36 0 25 25 24 36 36 8 1 0 36 36 2 9 36 36 23 36 0 10 10 10 36 35 6 3 36 36 36 15 13 36 0 36 7 7 7 36 27 21 21 36 36 14 14 14 36 0 19 16 16 36 36 28 28 36 0 \n", "0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 3 0 0 0 0 5 4 4 4 4 4 4 4 4 4 0 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 0 0 2 2 2 2 5 2 2 2 2 0 5 0 0 0 0 0 0 0 0 0 0 0 \n", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \n", "18 1 1 37 37 34 37 19 19 19 37 14 14 14 37 20 35 37 29 37 37 21 21 0 37 28 28 28 37 6 6 6 37 26 2 37 30 37 37 4 4 4 37 10 37 11 37 15 0 37 32 33 37 37 3 3 17 37 17 37 0 27 27 27 37 12 12 12 37 31 37 16 5 5 37 37 22 22 37 36 37 23 25 25 37 37 7 7 7 37 24 24 8 37 13 37 9 37 0 37 \n", "12 12 38 24 24 38 0 10 10 38 15 15 38 22 38 0 7 7 38 25 38 35 38 9 29 38 38 37 38 0 5 5 38 33 32 38 38 11 20 38 38 6 28 38 38 3 3 38 1 1 38 14 14 38 0 19 19 38 0 18 34 38 38 8 8 38 23 23 38 0 4 4 38 0 13 13 38 0 2 2 38 31 38 36 38 27 16 38 38 0 26 21 38 38 30 38 0 17 17 38 \n", "-1\n", "-1\n", "0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 7 3 3 3 3 3 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4 4 4 4 4 7 4 4 4 5 5 5 5 7 5 5 5 5 7 5 5 5 5 6 6 0 7 7 \n", "-1\n", "-1\n", "-1\n", "-1\n", "-1\n", "-1\n", "14 14 22 22 22 22 0 23 23 1 1 1 1 1 1 12 23 12 19 19 23 23 15 2 2 2 2 2 2 23 23 18 23 21 7 7 7 7 23 13 23 5 5 5 5 5 23 0 23 17 17 9 9 9 9 9 23 23 16 4 4 4 4 4 4 23 23 6 6 6 6 6 8 23 8 8 23 0 3 3 3 3 3 3 3 23 10 10 23 11 11 11 11 11 20 23 23 \n", "-1\n", "2 3 1 1 1 3 \n", "1 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \n", "2 3 1 3 \n", "2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 \n", "1 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \n", "1 2 3 1 3 0 \n", "1 2 3 1 1 0 3 \n", "0 0 1 2 3 1 0 3 \n", "1 2 3 1 1 1 1 1 1 3 \n", "1 2 3 1 3 \n", "1 2 3 1 1 1 1 0 0 3 \n", "1 2 2 3 1 1 1 0 0 3 \n", "1 1 2 1 1 1 3 1 0 3 \n", "2 2 2 1 3 4 1 4 0 4 \n", "3 0 2 1 1 1 1 5 5 5 6 4 6 6 4 6 4 4 0 6 \n", "0 0 0 0 0 0 0 0 0 0 0 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 1 1 3 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 \n", "0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 3 3 4 4 3 3 3 3 3 3 3 2 2 2 3 6 6 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0 0 1 0 0 0 0 0 5 0 6 0 0 0 6 0 0 0 0 0 0 6 0 \n", "4 3 5 1 4 2 5 5 5 \n", "1 2 1 3 1 1 1 0 0 3 \n", "2 2 3 5 5 1 4 5 1 5 \n", "1 1 2 1 1 1 3 1 1 3 \n", "-1\n", "2 1 4 2 2 2 0 0 0 0 0 4 3 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \n", "-1\n", "0 2 1 3 2 2 3 0 0 0 0 0 0 0 0 0 0 0 0 0 \n", "0 0 0 0 0 0 0 0 0 0 0 0 5 5 5 5 5 5 5 5 5 5 5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 6 1 1 1 1 1 1 1 2 2 2 2 2 6 4 2 2 6 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 6 3 0 0 0 0 0 0 6 0 0 0 0 0 0 0 \n", "-1\n", "1 1 1 2 2 2 2 3 1 1 3 \n", "0 0 0 0 1 1 1 5 0 6 6 0 0 0 2 4 4 4 4 6 2 6 3 3 3 3 6 0 0 \n", "0 3 0 5 1 1 1 1 1 1 2 5 1 1 1 1 1 4 0 0 0 0 5 5 0 0 0 0 \n", "0 0 8 8 8 8 1 1 8 9 8 8 8 8 8 8 8 3 3 9 8 8 4 4 0 0 2 9 6 6 0 9 0 0 0 0 7 7 7 9 7 7 7 7 7 7 7 9 7 7 7 7 7 7 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 9 5 5 5 5 5 5 5 5 5 0 9 0 0 0 0 0 0 \n", "0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 2 2 1 1 1 1 1 1 1 3 1 1 1 1 1 1 1 1 1 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \n", "-1\n", "1 1 0 8 9 8 8 8 8 8 8 5 5 5 5 8 8 8 9 8 8 8 8 8 8 7 7 7 2 2 2 2 2 2 2 3 3 3 3 3 3 9 9 7 7 7 7 7 7 9 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 6 7 7 7 7 7 7 9 4 4 0 0 0 0 9 9 0 0 0 0 0 0 0 \n", "-1\n", "2 2 1 1 2 2 3 2 3 \n", "4 2 2 1 1 1 1 7 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 5 3 7 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 7 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 7 5 5 5 5 5 5 5 5 6 6 6 6 0 0 7 7 0 0 0 0 0 0 \n", "0 0 3 5 3 3 6 3 3 3 3 3 4 4 4 4 1 1 1 1 1 1 1 1 1 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 2 2 2 2 0 6 \n", "0 0 0 2 2 2 2 1 1 1 1 6 1 1 1 5 5 4 4 4 4 4 6 6 4 4 4 3 3 3 3 6 3 3 3 3 3 3 3 3 3 3 0 0 0 6 0 0 0 0 \n", "3 4 1 2 4 4 \n", "2 2 2 2 2 2 2 3 3 2 2 2 2 2 2 2 1 1 1 2 4 4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \n"]}, "solutions": "[\"def ke(i):\\n    return b[i]\\nn,m=map(int,input().split())\\na=[0]*m\\nb=[0]*m\\nc=[0]*m\\ne=[]\\nans=[0]*n\\nfor i in range(m):\\n    a[i],b[i],c[i]=map(int,input().split())\\n    ans[b[i]-1]=m+1\\n    e.append(i)\\ne.sort(key=ke)\\nfor i in range(m):\\n    k=0\\n    for j in range(a[e[i]]-1,b[e[i]]-1):\\n        if ans[j]==0:\\n            ans[j]=e[i]+1\\n            k+=1\\n        if k==c[e[i]]:\\n            break\\n    if k!=c[e[i]]:\\n        print(-1)\\n        return\\nfor i in ans:\\n    print(i,end=' ')\", \"n, m = list(map(int, input().split()))\\nL = []\\nfor i in range(m):\\n    a, b, c = list(map(int, input().split()))\\n    L.append([b, a, c, i])\\nL.sort()\\n\\nM = [-1 for i in range(n + 1)]\\nfor i in range(m):\\n    M[L[i][0]] = m + 1\\nfor i in range(1, n + 1):\\n    if M[i] == -1:\\n        f = False\\n        for j in range(m):\\n            if L[j][1] <= i and L[j][2] > 0 and i < L[j][0]:\\n                M[i] = L[j][3] + 1\\n                L[j][2] -= 1\\n                f = True\\n                break\\n        if not(f):\\n            M[i] = 0\\nf = True\\nfor j in range(m):\\n    if L[j][2] > 0:\\n        f = False\\nif f:\\n    print(*M[1:])\\nelse:\\n    print(-1)\\n\", \"T = input().split(' ')\\nn = int(T[0])\\nm = int(T[1])\\nL = [0] * n\\nM = []\\nD = [0] * m\\nF = [0] * m\\nfor i in range(m):\\n    S = input().split(' ')\\n    a = int(S[0])\\n    b = int(S[1])\\n    c = int(S[2])\\n    L[b-1] = m+1\\n    F[i] = b-1\\n    M.append((a-1, b-2, i+1))\\n    D[i] = c\\nM.sort()\\nfor i in range(n):\\n    if L[i] == 0:\\n        G = []\\n        for j in range(len(M)):\\n            if M[j][0]<=i:\\n                G.append((M[j][1], M[j][2]))\\n        G.sort()\\n        for k in range(len(G)):\\n            if D[G[k][1]-1] > 0 and F[G[k][1]-1]>i:\\n                D[G[k][1]-1]-=1\\n                L[i] = G[k][1]\\n                break\\nb = True\\nfor j in range(len(D)):\\n    if D[j] > 0:\\n        b = False\\nif b:\\n    for i in range(n-1):\\n        print(L[i], end=' ')\\n    print(L[n-1])\\nelse:\\n    print(-1)\\n\", \"n, m = list(map(int, input().split()))\\nprep = []\\n\\ndays = [-1] * n\\nrelease = []\\n\\nfor i in range(m):\\n    s_, d_, c_ = list(map(int, input().split()))\\n    release.append(s_)\\n    days[d_ - 1] = i\\n    prep.append(c_)\\n\\nrel_on_day = {}\\nfor i, r in enumerate(release):\\n    if r - 1 in rel_on_day:\\n        rel_on_day[r - 1].append(i)\\n    else:\\n        rel_on_day[r - 1] = [i]\\n\\nans = []\\n\\nwaiting = set()\\n\\nexam_q = []\\nfor d in days:\\n    if d != -1:\\n        exam_q.append(d)\\n\\n#print(rel_on_day)\\n\\nfor i in range(n):\\n    if i in rel_on_day:\\n        waiting = waiting | set(rel_on_day[i])\\n\\n #   print(waiting)\\n\\n\\n    if days[i] != -1: #exam\\n        if prep[days[i]] == 0:\\n            ans.append(m + 1)\\n            waiting.remove(days[i])\\n        else:\\n            print(-1)\\n            return\\n    else: #choose closest unstudied exam\\n        chosen = None\\n        for ex in exam_q:\\n            if prep[ex] > 0 and ex in waiting:\\n                chosen = ex\\n                break\\n        if not chosen is None:\\n            prep[ex] -= 1\\n            ans.append(ex + 1)\\n        else:\\n            ans.append(0)\\n\\nprint(\\\" \\\".join(list(map(str, ans))))\\n\", \"import sys\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\ndef __starting_point():\\n    n, m = [int(c) for c in input().split()]\\n    s = []\\n    d = []\\n    c = []\\n    studying = []\\n    for _ in range(m):\\n        x,y,z = [int(w) for w in input().split()]\\n        s.append(x)\\n        d.append(y)\\n        c.append(z)\\n        \\n    plan = []\\n\\n    for i in range(1, n+1):\\n        \\n        if i in s:\\n            indices = [k for k, x in enumerate(s) if x == i]\\n            for idx in indices:\\n                studying.append( (d[idx], idx) )\\n            studying.sort()\\n        \\n        #print(studying)\\n        if i in d:\\n            idx = d.index(i)\\n            if (i, idx) in studying:\\n                print (-1)\\n                return\\n            else:\\n                plan.append(m+1)\\n        else:\\n            if not studying:\\n                plan.append(0)\\n                continue\\n            idx = studying[0][1]\\n            plan.append(idx+1)\\n            c[idx] -= 1\\n            if c[idx] == 0:\\n                studying = studying[1:]\\n\\n    for i in plan:\\n        print (i, end=' ')\\n    print()\\n\\n\\n\\n\\n\\n\\n__starting_point()\", \"# Hello World program in Python\\nclass exam:\\n    def __init__(self, tickets, ex_day, prep_days, index):\\n        self.tick = tickets-1\\n        self.ex_day = ex_day-1\\n        self.prep_days = prep_days\\n        self.index = index\\n\\n\\ndef task():\\n    n, m = [int(x) for x in input().split(' ')]\\n    exs = list()\\n    for i in range(m):\\n        a, b, c = [int(x) for x in input().split(' ')]\\n        exs.append(exam(a, b, c, i + 1))\\n    s = sum((x.prep_days for x in exs))\\n    if s > n - m:\\n        print(-1)\\n        return -1\\n    exs = sorted(exs, key=lambda x: -x.tick)\\n    exdays = [x.ex_day for x in exs]\\n    days = [m+1 if i in exdays else 0 for i in range(0, n)]\\n    for ex in exs:\\n        d = ex.ex_day\\n        offs = 1\\n        for i in range(ex.prep_days):\\n            cont = True\\n            while (cont):\\n                if d - offs < ex.tick:\\n                    print(-1)\\n                    return\\n                if days[d - offs] == 0:\\n                    days[d - offs] = ex.index\\n                    cont = False\\n                else:\\n                    offs += 1\\n\\n    print(' '.join((str(x) for x in days)))\\n\\n\\ntask()\", \"n, m = map(int, input().split())\\nexams = []\\nfor i in range(m):\\n    e = list(map(int, input().split()))\\n    e.append(0)\\n    e.append(i + 1)\\n    exams.append(e)\\nexams.sort()\\nnow, have, f, ans, c = 0, [], True, [], 0\\nfor i in range(1, n + 1):\\n    while now < m and exams[now][0] == i:\\n        have.append(exams[now][1:])\\n        now += 1\\n        have.sort()\\n    if c < len(have) and have[c][0] == i:\\n        if have[c][1] == have[c][2]:\\n            ans.append(m + 1)\\n            c += 1\\n        else:\\n            f = False\\n            break\\n    else:\\n        j = 0\\n        while j < len(have) and have[j][1] == have[j][2]:\\n            j += 1\\n        if j == len(have):\\n            ans.append(0)\\n        else:\\n            ans.append(have[j][3])\\n            have[j][2] += 1\\nif f:\\n    for i in range(n):\\n        print(ans[i], end=' ')\\nelse:\\n    print(-1)\", \"n, m =[int(i) for i in input().split()]\\ns = [0] * m\\nd = [0] * m\\nc = [0] * m\\nfor i in range(m):\\n\\ts[i], d[i], c[i] = [int(j) - 1 for j in input().split()]\\n\\tc[i] += 1\\n\\tif d[i] - s[i] < c[i]:\\n\\t\\tprint(-1)\\n\\t\\tquit()\\n\\nans = [0] * n\\nfor i in d:\\n\\tans[i] = m + 1\\n\\nexam = []\\nfor i in range(n):\\n\\texam.append([])\\n\\tfor j in range(m):\\n\\t\\tif s[j] <= i < d[j]:\\n\\t\\t\\texam[i].append(j)\\n\\nfor i in range(n):\\n\\tif ans[i] == 0:\\n\\t\\tday_min = n + 1\\n\\t\\tfor j in exam[i]:\\n\\t\\t\\tif (d[j] < day_min) and (c[j] > 0):\\n\\t\\t\\t\\tday_min = d[j]\\n\\t\\t\\t\\texam_min = j\\n\\t\\tif day_min != n + 1:\\n\\t\\t\\tans[i] = exam_min + 1\\n\\t\\t\\tc[exam_min] -= 1\\n\\telse:\\n\\t\\tif c[d.index(i)] != 0:\\n\\t\\t\\tprint(-1)\\n\\t\\t\\tquit()\\n\\nfor i in range(n):\\n\\tif i != n - 1:\\n\\t\\tprint(ans[i], end = \\\" \\\")\\n\\telse:\\n\\t\\tprint(ans[i])\\n\\n\\n\", \"(n, m) = list(map(int, input().split()))\\n\\narray = [0] * (n + 1)\\nlst = []\\nfor x in range(m):\\n    (s, d, c) = list(map(int, input().split()))\\n    lst.append((d, s, c, x + 1))\\n\\nlst.sort()\\ni = 0\\nflag = True\\nfor (d, s, c, p) in lst:\\n    x = s\\n    while c > 0 and x < d:\\n        if array[x] == 0:\\n            array[x] = p\\n            c -= 1\\n        x += 1\\n    if c != 0:\\n        flag = False\\n        break\\n    else:\\n        array[d] = m + 1\\n\\nif flag:\\n    print(*array[1:])\\nelse:\\n    print(-1)\\n\", \"import bisect\\nn,m=list(map(int,input().split()))\\na=[]\\nb=[]\\nfor i in range(m):\\n    s,d,c=list(map(int,input().split()))\\n    if c>d-s+1:\\n        print(-1)\\n        quit()\\n    l=bisect.bisect_left(b,d)\\n    a.insert(l,[s,d,c,i+1])\\n    b.insert(l,d)\\nds=list('0' for i in range(n))\\nfor i in range(m):\\n    s,d,c,mi=a[i]\\n    c0=0\\n    for j in range(s,d):\\n        if ds[j-1]=='0':\\n            ds[j-1]=str(mi)\\n            c0+=1\\n        if c0>=c:\\n            break\\n    if c0<c:\\n        print(-1)\\n        quit()\\n    ds[d-1]=str(m+1)\\nprint(' '.join(ds))\\n\", \"[n, m] = [int(x) for x in input().split()]\\nI = 0\\nS = 1\\nD = 2\\nC = 3\\nexses = [[0, 0, 0, 0]]\\npops = [0] * (n+1)\\ni = 1\\nwhile i <= m:\\n  [s, d, c] = [int(x) for x in input().split()]\\n  exses.append([i, s, d, c])\\n  pops[d] = i\\n  i += 1\\n\\ni = 1\\nresult = [0] * (n+1)\\nfail = False\\nwhile i <=n:\\n  if pops[i] != 0 and exses[pops[i]][C] == 0:\\n    result[i] = m+1\\n  elif pops[i] != 0 and exses[pops[i]][C] > 0:\\n    fail = True\\n    break\\n  else:\\n    ex = None\\n    min = n+1\\n    for e in exses:\\n      if e[D] > i and e[S] <= i and e[D] < min and e[C] > 0:\\n        min = e[D]\\n        ex = e\\n    if ex == None:\\n      result[i] = 0\\n    else:\\n      result[i] = ex[I]\\n      ex[C] -= 1\\n  i += 1\\n\\nif fail:\\n  print(-1)\\nelse:\\n  for x in result[1:]:\\n    print(x, end=' ')\\n\", \"def solve(n, m, ss, dd, cc):\\n\\t# day: i ( 1 -> n)\\n\\t# exam: j (0 -> m - 1)\\n\\t# date : d (1 -> n)\\n\\t# start: s (1 -> n)\\n\\t#\\n\\n\\tdate = [-1] * (n + 1)\\n\\tfor j, d in enumerate(dd):\\n\\t\\tdate[d] = j\\t\\t# mark exam date for i-th exam\\n\\t# print(date)\\n\\tstart = [[] for _ in range(n + 1)]\\n\\tfor j, d in enumerate(ss):\\n\\t\\tstart[d].append(j)\\n\\t# print(start)\\n\\tpreps = []\\n\\tfor i in range(1, n + 1): # for each day in n days\\n\\t\\tif start[i]: # a start date\\n\\t\\t\\tpreps += start[i] # add to the list of preparation\\n\\t\\t# print(date)\\n\\t\\tu = date[i]\\n\\n\\t\\t# print(i, u, start[i], end=' ')\\n\\t\\tif u >= 0: # an exam date 0 -> m - 1\\n\\t\\t\\tj = u # j-th exam\\n\\t\\t\\tif cc[j] > 0: # failed to prepare\\n\\t\\t\\t\\t# print('failed ', j + 1)\\n\\t\\t\\t\\treturn -1\\n\\t\\t\\tdate[i] = m + 1 # take the exam\\n\\t\\telse:\\n\\t\\t\\t# print(preps, end=' ')\\n\\t\\t\\tif not preps: # no subject to prepare\\n\\t\\t\\t\\tdate[i] = 0\\n\\t\\t\\telse: # prepare for subject closest to the exam date\\n\\t\\t\\t\\tmin_d = min(dd[j] for j in preps)\\n\\t\\t\\t\\tfor j in preps:\\n\\t\\t\\t\\t\\tif dd[j] == min_d: break\\n\\t\\t\\t\\tdate[i] = j + 1 # prepare for j-th exam\\n\\t\\t\\t\\tcc[j] -= 1\\n\\t\\t\\t\\tif cc[j] == 0:\\n\\t\\t\\t\\t\\tpreps.remove(j)\\n\\t\\t# print(date[i])\\n\\n\\treturn date[1:]\\n\\n\\n\\n\\n\\ndef main():\\n\\tn, m = [int(_) for _ in input().split()]\\n\\n\\ts = []\\n\\td = []\\n\\tc = []\\n\\tfor i in range(m):\\n\\t\\ts_, d_, c_ = [int(_) for _ in input().split()]\\n\\n\\t\\ts.append(s_)\\n\\t\\td.append(d_)\\n\\t\\tc.append(c_)\\n\\n\\n\\n\\n\\tplan = solve(n, m, s, d, c)\\n\\tif isinstance(plan, list):\\n\\t\\tprint(' '.join(map(str, plan)))\\n\\telse:\\n\\t\\tprint(-1)\\n\\n\\n\\n\\ndef __starting_point():\\n\\tmain()\\n\\n__starting_point()\", \"import heapq\\nn,m = [int(s) for s in input().split()]\\nq0,q1 = [],[]\\nans = [0]*n\\nfor i in range(m):\\n    si, di, ci = [int(s) for s in input().split()]\\n    si -= 1\\n    di -= 1\\n    ans[di] = m+1\\n    heapq.heappush(q0, (si, di, ci, i))\\n\\nfor currday in range(n):\\n    while len(q0) and q0[0][0] <= currday:\\n        si,di,ci,i = heapq.heappop(q0)\\n        heapq.heappush(q1, (di,si,ci,i))\\n    if len(q1) and ans[currday] == 0:\\n        if currday > q1[0][0]:\\n            break\\n        ans[currday] = q1[0][3]+1\\n        if q1[0][2] == 1:\\n            heapq.heappop(q1)\\n        else:\\n            q1[0] = (q1[0][0], q1[0][1], q1[0][2]-1, q1[0][3])\\n\\nif len(q1) == 0 and len(q0) == 0:\\n    print(*ans)\\nelse:\\n    print(-1)\", \"#!/usr/bin/env python3\\nfrom sys import stdin, stdout\\n\\ndef rint():\\n    return list(map(int, stdin.readline().split()))\\n#lines = stdin.readlines()\\n\\nn, m = rint()\\n\\ns = [0 for i in range(m)]\\nd = [0 for i in range(m)]\\nc = [0 for i in range(m)]\\n\\n\\nfor i in range(m):\\n    s[i], d[i], c[i] = rint()\\n\\ns_in_day = [set() for i in range(n+1)]\\nfor i in range(m):\\n    day = s[i]\\n    s_in_day[day].add(i)\\n\\nd_in_day = [-1 for i in range(n+1)]\\nfor i in range(m):\\n    day = d[i]\\n    d_in_day[day] = i\\n\\n\\ndi_sorted = [0 for i in range(m)]\\ndi_sorted.sort(key=lambda x: d[i])\\n\\nans = [0 for i in range(n+1)]\\n\\ncandi_exam = set()\\nfor day in range(1, n+1):\\n    for exam in s_in_day[day]:\\n        candi_exam.add(exam)\\n    if d_in_day[day] != -1:\\n        exam = d_in_day[day]\\n        if c[exam] != 0:\\n            print(-1)\\n            return\\n        ans[day] = m+1\\n        if exam in candi_exam:\\n            candi_exam.remove(exam)\\n        continue\\n    \\n    if len(candi_exam) == 0:\\n        ans[day] = 0\\n        continue\\n    min_d_day = 101\\n    busy_exam = 0\\n    for exam in candi_exam:\\n        if d[exam] < min_d_day:\\n            busy_exam = exam\\n            min_d_day = d[exam]\\n    \\n    ans[day] = busy_exam + 1\\n    c[busy_exam] -= 1\\n    if c[busy_exam] == 0:\\n        candi_exam.remove(busy_exam)\\nfor i in range(m):\\n    if c[i] != 0:\\n        print(-1)\\n        return\\nprint(*ans[1:])\\n    \\n\\n        \\n\\n\", \"aa = input()\\nn, m = [int(s) for s in aa.split(' ')]\\n\\nexams = []\\nres = [0] * n\\n\\nfor i in range(m):\\n    aa = input()\\n    s,d,c = [int(s) for s in aa.split(' ')]\\n    el = {'s':s-1, 'd':d-1, 'c':c}\\n    exams.append(el)\\n    res[d - 1] = m + 1\\n\\nfor i in range(n-1, -1,-1):\\n    if res[i] > 0: #exam\\n        continue\\n    exam_num = -1\\n    min_zapas = n + 1\\n    for j in range(m):\\n        if (exams[j]['s'] <= i) and (i < exams[j]['d']) and (exams[j]['c'] > 0):\\n            zapas = i - exams[j]['s'] - exams[j]['c']\\n            if zapas < min_zapas:\\n                min_zapas = zapas\\n                exam_num = j\\n            if zapas < 0:\\n                break\\n    if exam_num == -1:\\n        continue\\n    \\n    res[i] = exam_num + 1\\n    exams[exam_num]['c'] = exams[exam_num]['c'] - 1\\n    \\npossible = True\\n\\nfor i in range(m):\\n    if exams[i]['c'] > 0:\\n        possible = False\\n        break\\n\\nif possible:\\n    print(\\\" \\\".join([str(x) for x in res]))\\nelse:\\n    print(-1)\", \"R = lambda: list(map(int, input().split()))\\n\\nn, m= R()\\na = []\\nfor i in range(m):\\n    s, d, c = R()\\n    a.append([d, s, c, i+1])\\na.sort()\\nr = [0] * (n+1)\\nfor i in range(m): r[a[i][0]] = m + 1\\nfor i in range(m):\\n    for j in range(a[i][1], a[i][0]):\\n        if a[i][2]==0: break\\n        elif r[j]==0:\\n            r[j] = a[i][3]\\n            a[i][2] -= 1\\n    if a[i][2]: print((-1)); return\\nprint(*r[1:])\\n\", \"from collections import namedtuple\\n\\nExam = namedtuple(\\\"Exam\\\", \\\"id s d c\\\")\\n\\n\\ndef get_exam(day, exams, prepared):\\n    result = None\\n\\n    for exam in exams:\\n        if exam.s <= day and prepared[exam.id] < exam.c and (result is None or exam.d < result.d):\\n            result = exam\\n\\n    return result\\n\\n\\nn, m = list(map(int, input().split()))\\nexams = []\\nprepared = [0] * (m + 1)\\nschedule = [0] * (n + 1)\\n\\nfor i in range(m):\\n    s, d, c = list(map(int, input().split()))\\n    exams.append(Exam(i + 1, s, d, c))\\n    schedule[d] = -1\\n\\nfor day in range(1, n + 1):\\n    if schedule[day] == -1:\\n        print(-1)\\n        return\\n\\n    if schedule[day] == m + 1:\\n        continue\\n\\n    exam = get_exam(day, exams, prepared)\\n\\n    if exam is None:\\n        continue\\n\\n    prepared[exam.id] += 1\\n    schedule[day] = exam.id\\n\\n    if prepared[exam.id] == exam.c:\\n        schedule[exam.d] = m + 1\\n\\nprint(' '.join(map(str, schedule[1:])))\\n\", \"a = input().split(\\\" \\\")\\na = [int(e) for e in a]\\n\\nisdc = []\\nfor i in range(a[1]):\\n    l = input().split(\\\" \\\")\\n    l = [int(e) for e in l]\\n    isdc.append([i+1, l[0]-1, l[1]-1, l[2]])\\n\\nl = [0] * a[0]\\nfor e in isdc:\\n    l[e[2]] = len(isdc) + 1\\n\\nisdc = sorted(isdc, key=lambda one: one[2])\\n\\nfor exam in isdc:\\n    day = exam[1]\\n    while day < exam[2]:\\n        if exam[3] == 0:\\n            break\\n        if l[day] == 0:\\n            l[day] = exam[0]\\n            exam[3] -= 1\\n\\n        day += 1\\n\\n    if exam[3] != 0:\\n        print(-1)\\n        return\\n\\nfor e in l:\\n    print(e, end=\\\" \\\")\\n\", \"import heapq\\n\\n\\n\\n\\nn, m = map(int, input().split())\\nans = [0]*n\\nary = []\\ndp = [[0]*n for i in range(n)]\\n# print(dp)\\ntmp =0\\n\\nwhile tmp < m:\\n    s, d, c = map(int, input().split())\\n    s -= 1; d -= 1\\n    ans[d] = m + 1\\n    ary.append((s, d, c + 1, tmp))\\n    # print('sdc', s,d,c)\\n    dp[s][d] = c + 1\\n    # print('dp', dp[s][d])\\n    tmp += 1\\n\\n\\n# print(dp)\\n\\n\\nd = 2\\nwhile d< n:\\n    l = 0\\n    while l+d < n:\\n        r = l+d\\n\\n        dp[l][r] += dp[l+1][r] + dp[l][r-1] - dp[l+1][r-1]\\n        # print('lr', l, r ,dp[l][r], dp[l + 1][r], dp[l][r - 1], dp[l + 1][r - 1])\\n        # if dp[l][r] > d:\\n        #     print(-1)\\n        #     quit(0)\\n        l += 1\\n    d+=1\\n\\nl = 0\\npos = 0\\nsary = sorted(ary)\\n# print(sary)\\nque = []\\n\\nwhile l<n:\\n    while pos<m and sary[pos][0] == l:\\n        heapq.heappush(que, [sary[pos][1], sary[pos][2] , sary[pos][3]])\\n        pos += 1\\n    if ans[l] > 0:\\n        l += 1\\n        continue\\n    if que.__len__() == 0:\\n        # ans[l] = 0\\n        l += 1\\n        continue\\n    head = heapq.heappop(que)\\n    # print('head',l, head)\\n    if head[1] + l - 1 > head[0]:\\n        print(-1)\\n        quit(0)\\n\\n\\n    head[1] -= 1\\n    ans[l] = head[2] + 1\\n    if head[1] > 1:\\n        heapq.heappush(que, head)\\n    l += 1\\n\\nif que.__len__() >0 or pos < m:\\n    print(-1)\\nelse:\\n    print(*ans)\", \"import heapq\\n\\n\\n\\n\\nn, m = map(int, input().split())\\nans = [0]*n\\nary = []\\ndp = [[0]*n for i in range(n)]\\n# print(dp)\\ntmp =0\\n\\nwhile tmp < m:\\n    s, d, c = map(int, input().split())\\n    s -= 1; d -= 1\\n    ans[d] = m + 1\\n    ary.append((s, d, c + 1, tmp))\\n    # print('sdc', s,d,c)\\n    dp[s][d] = c\\n    # print('dp', dp[s][d])\\n    tmp += 1\\n\\n\\n# print(dp)\\n\\n\\nd = 2\\nwhile d< n:\\n    l = 0\\n    while l+d < n:\\n        r = l+d\\n\\n        dp[l][r] += dp[l+1][r] + dp[l][r-1] - dp[l+1][r-1]\\n        # print('lr', l, r ,dp[l][r], dp[l + 1][r], dp[l][r - 1], dp[l + 1][r - 1])\\n        if dp[l][r] > d:\\n            print(-1)\\n            quit(0)\\n        l += 1\\n    d+=1\\n\\nl = 0\\npos = 0\\nsary = sorted(ary)\\n# print(sary)\\nque = []\\n\\nwhile l<n:\\n    while pos<m and sary[pos][0] == l:\\n        heapq.heappush(que, [sary[pos][1], sary[pos][2] , sary[pos][3]])\\n        pos += 1\\n    if ans[l] > 0:\\n        l += 1\\n        continue\\n    if que.__len__() == 0:\\n        # ans[l] = 0\\n        l += 1\\n        continue\\n    head = heapq.heappop(que)\\n    # print('head',l, head)\\n    if head[1] + l - 1 > head[0]:\\n        print(-1)\\n        quit(0)\\n\\n\\n    head[1] -= 1\\n    ans[l] = head[2] + 1\\n    if head[1] > 1:\\n        heapq.heappush(que, head)\\n    l += 1\\n\\nif que.__len__() >0 or pos < m:\\n    print(-1)\\nelse:\\n    print(*ans)\", \"n,m =map(int,input().split())\\nl = list()\\nout = [0] * n\\nfor i in range(m):\\n    s1,d1,c1 = map(int,input().split())\\n    l.append((s1,d1,c1,i))\\nl.sort(key=lambda x:x[1])\\ncan = True\\nfor j in l:\\n    out[j[1] - 1] = m + 1\\nfor i in l:\\n    c = i[2]\\n    for t in range(i[0],i[1]):\\n        if out[t - 1] == 0 and c > 0:\\n            out[t - 1] = i[3] + 1\\n            c -= 1\\n        if c == 0:\\n            break\\n    if c != 0:\\n        print(-1)\\n        can = False\\n        break\\n\\nif can is True:\\n    print(\\\" \\\".join(map(str,out)))\", \"rd = lambda: list(map(int, input().split()))\\nn, m = rd()\\na = sorted(([*rd()] + [i + 1] for i in range(m)), key=lambda x: x[1])\\nr = [0] * n\\nfor x in a:\\n    r[x[1] - 1] = m + 1\\n    for i in range(x[0] - 1, x[1] - 1):\\n        if not r[i]:\\n            r[i] = x[3]\\n            x[2] -= 1\\n            if not x[2]:\\n                break\\n    if x[2]:\\n        print(-1)\\n        return\\nprint(*r)\\n\", \"# from itertools import accumulate\\n# from bisect import bisect_left\\n# from collections import OrderedDict\\n\\nI = lambda: list(map(int, input().split()))\\n\\nn, m = I()\\ndates = [0 for i in range(n + 1)]\\ndata = []\\nfor i in range(m):\\n    d = I() + [i + 1]\\n    if dates[d[1]]:\\n        print(-1)\\n        return\\n    dates[d[1]] = m + 1\\n    data.append(d)\\ndata.sort(key = lambda x: x[1])\\nfor s, d, c, idx in data:\\n    x = 0\\n    for i in range(s, d):\\n        if x == c:\\n            break\\n        if not dates[i]:\\n            dates[i] = idx\\n            x += 1\\n    if x != c:\\n        print(-1)\\n        return\\nprint(*dates[1:])\"]", "task": "apps", "difficulty": "introductory", "split": "test", "transformation_type": "plain_summary"}