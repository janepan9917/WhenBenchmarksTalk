{"qid": 4172, "orig_input": "You are given the array $a$ consisting of $n$ elements and the integer $k \\le n$.\n\nYou want to obtain at least $k$ equal elements in the array $a$. In one move, you can make one of the following two operations:\n\n  Take one of the minimum elements of the array and increase its value by one (more formally, if the minimum value of $a$ is $mn$ then you choose such index $i$ that $a_i = mn$ and set $a_i := a_i + 1$);  take one of the maximum elements of the array and decrease its value by one (more formally, if the maximum value of $a$ is $mx$ then you choose such index $i$ that $a_i = mx$ and set $a_i := a_i - 1$). \n\nYour task is to calculate the minimum number of moves required to obtain at least $k$ equal elements in the array.\n\n\n-----Input-----\n\nThe first line of the input contains two integers $n$ and $k$ ($1 \\le k \\le n \\le 2 \\cdot 10^5$) \u2014 the number of elements in $a$ and the required number of equal elements.\n\nThe second line of the input contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^9$), where $a_i$ is the $i$-th element of $a$.\n\n\n-----Output-----\n\nPrint one integer \u2014 the minimum number of moves required to obtain at least $k$ equal elements in the array.\n\n\n-----Examples-----\nInput\n6 5\n1 2 2 4 2 3\n\nOutput\n3\n\nInput\n7 5\n3 3 2 1 1 1 3\n\nOutput\n4", "input": "Find the minimum moves to equalize at least k elements in an array by incrementing or decrementing values.", "test_cases": {"inputs": ["6 5\n1 2 2 4 2 3\n", "7 5\n3 3 2 1 1 1 3\n", "1 1\n1\n", "1 1\n1000000000\n", "2 1\n1 1\n", "2 1\n1 1000000000\n", "2 1\n1 2\n", "2 2\n1 1\n", "2 2\n1 123\n", "8 6\n4 5 1 2 3 5 3 3\n", "8 6\n893967334 893967335 893967331 893967332 893967333 893967335 893967333 893967333\n", "6 3\n1 10 10 10 10 20\n", "4 2\n10 20 20 30\n", "4 2\n5 10 10 20\n", "21 6\n12 15 14 4 4 7 2 4 11 1 15 4 12 11 12 8 11 12 3 4 4\n", "11 3\n1 1 2 3 4 5 5 5 6 7 8\n", "10 4\n1 2 3 5 5 5 5 10 11 12\n"], "outputs": ["3\n", "4\n", "0\n", "0\n", "0\n", "0\n", "0\n", "0\n", "122\n", "5\n", "5\n", "0\n", "0\n", "0\n", "0\n", "0\n", "0\n"]}, "solutions": "[\"#!usr/bin/env python3\\nfrom collections import defaultdict, deque\\nfrom heapq import heappush, heappop\\nfrom itertools import permutations, accumulate\\nimport sys\\nimport math\\nimport bisect\\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\\ndef I(): return int(sys.stdin.readline())\\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\\ndef S():\\n    res = list(sys.stdin.readline())\\n    if res[-1] == \\\"\\\\n\\\":\\n        return res[:-1]\\n    return res\\ndef IR(n):\\n    return [I() for i in range(n)]\\ndef LIR(n):\\n    return [LI() for i in range(n)]\\ndef SR(n):\\n    return [S() for i in range(n)]\\ndef LSR(n):\\n    return [LS() for i in range(n)]\\n\\nsys.setrecursionlimit(1000000)\\nmod = 1000000007\\n\\ndef solve():\\n    n,k = LI()\\n    a = LI()\\n    a.sort()\\n    d = defaultdict(lambda : 0)\\n    c = defaultdict(lambda : 0)\\n    s = [0]\\n    for i in a:\\n        d[i] += i\\n        c[i] += 1\\n        s.append(s[-1]+i)\\n    ans = float(\\\"inf\\\")\\n    p = -1\\n    for i in a:\\n        if i == p:\\n            continue\\n        if k <= c[i]:\\n            ans = 0\\n            break\\n        l,r = bisect.bisect_left(a,i),bisect.bisect_right(a,i)\\n        m = r\\n        if m >= k:\\n            ns = l*(i-1)-s[l]\\n            su = ns+k-c[i]\\n            if su < ans:\\n                ans = su\\n        m = n-l\\n        if m >= k:\\n            ns = s[n]-s[r]-(n-r)*(i+1)\\n            su = ns+k-c[i]\\n            if su < ans:\\n                ans = su\\n        ns = s[n]-s[r]-(n-r)*(i+1)+l*(i-1)-s[l]\\n        su = ns+k-c[i]\\n        if su < ans:\\n            ans = su\\n        p = i\\n    print(ans)\\n    return\\n\\n#Solve\\ndef __starting_point():\\n    solve()\\n\\n__starting_point()\", \"from collections import Counter\\n\\nimport sys\\nfrom itertools import accumulate\\n\\n\\n#\\n# _INPUT_LINES = sys.stdin.read().splitlines()\\n# input = iter(_INPUT_LINES).__next__\\n\\ndef go():\\n    n, k = list(map(int, input().split()))\\n    a = sorted(map(int, input().split()))\\n    c = Counter(a)\\n    if max(c.values()) >= k:\\n        return 0\\n\\n    upsum = {}\\n    upcnt = {}\\n    prev = -1\\n    cursum = 0\\n    for cnt, aa in enumerate(a):\\n        if aa != prev:\\n            upsum[aa] = cursum\\n            upcnt[aa] = cnt\\n        cursum += aa\\n        prev = aa\\n\\n    downsum = {}\\n    downcnt = {}\\n    prev = -1\\n    cursum = 0\\n    for cnt, aa in enumerate(reversed(a)):\\n        if aa != prev:\\n            downsum[aa] = cursum\\n            downcnt[aa] = cnt\\n        cursum += aa\\n        prev = aa\\n\\n    best = cursum\\n    for target, cnt in list(c.items()):\\n        need = k - cnt\\n        if upcnt[target] >= need:\\n            best = min(best, (target - 1) * upcnt[target] - upsum[target] + need)\\n        if downcnt[target] >= need:\\n            best = min(best, downsum[target] - (target + 1) * downcnt[target] + need)\\n        best = min(best, (target - 1) * upcnt[target] - upsum[target]\\n                   + downsum[target] - (target + 1) * downcnt[target] +need\\n                   )\\n\\n    return best\\n\\n\\n# x,s = map(int,input().split())\\n# t = int(input())\\nt = 1\\n# ans = []\\nfor _ in range(t):\\n    print(go())\\n    # ans.append(str(go()))\\n#\\n# print('\\\\n'.join(ans))\\n\", \"def main():\\n    import sys\\n    input=sys.stdin.readline\\n    n,k=map(int,input().split())\\n    A=list(map(int,input().split()))\\n    A.sort()\\n    A.append(0)\\n    l1=[0]*n\\n    for i in range(1,n):\\n        l1[i]=l1[i-1]+(A[i]-A[i-1])*i \\n    l2=[0]*n\\n    for i in range(1,n):\\n        l2[n-i-1]=l2[n-i]+(A[n-i]-A[n-i-1])*i \\n    ans=float(\\\"INF\\\")\\n    c=1\\n    for i in range(n):\\n        if A[i+1]==A[i]:\\n            c+=1\\n        else:\\n            c1=i-c+1\\n            c2=n-i-1\\n            if c>=k:\\n                ans=0\\n            elif c+c1>=k or c+c2>=k:\\n                if c+c1>=k:\\n                \\tans=min(ans,l1[i]-c-c1+k)\\n                if c+c2>=k:\\n                \\tans=min(ans,l2[i]-c-c2+k)\\n            else:\\n                ans=min(ans,l1[i]+l2[i]-n+k)\\n            c=1\\n    print(ans)\\ndef __starting_point():\\n    main()\\n__starting_point()\", \"from collections import Counter\\nfrom bisect import bisect, bisect_left\\nn, k = map(int, input().split())\\na = list(map(int, input().split()))\\na = Counter(a)\\nc = sorted(Counter(a).items())\\nkeys = sorted(Counter(a).keys())\\n\\nm = len(c)\\nl_cum = [c[0][0] * c[0][1]]\\nl_cnt = [c[0][1]]\\nfor i in range(1, m):\\n\\tl_cum.append(l_cum[-1] + c[i][0] * c[i][1])\\n\\tl_cnt.append(l_cnt[-1] + c[i][1])\\n\\n\\nr_cum = [0 for _ in range(m)]\\nr_cum[-1] = c[-1][0] * c[-1][1]\\nr_cnt = [0 for _ in range(m)]\\nr_cnt[-1] = c[-1][1]\\nfor i in range(m-2, -1, -1):\\n\\tr_cum[i] = r_cum[i+1] + c[i][0] * c[i][1]\\n\\tr_cnt[i] = r_cnt[i+1] + c[i][1]\\n\\n#print(l_cum)\\n#print(r_cum)\\n\\nans = 10**20\\nfor i in range(m):\\n\\tc_num = a[keys[i]]\\n\\tif c_num >= k:\\n\\t\\tans = 0\\n\\t\\tbreak\\n\\n\\tif i > 0:\\n\\t\\tl_res = (keys[i]-1) * l_cnt[i-1] - l_cum[i-1]\\n\\t\\tl_num = l_cnt[i-1]\\n\\telse:\\n\\t\\tl_res = 10**30\\n\\t\\tl_num = 0\\n\\tif i < m-1:\\n\\t\\tr_res = r_cum[i+1] - (keys[i]+1) * r_cnt[i+1]\\n\\t\\tr_num = r_cnt[i+1]\\n\\telse:\\n\\t\\tr_res = 10**30\\n\\t\\tr_num = 0\\n\\n\\tif c_num + l_num < k and c_num + r_num < k:\\n\\t\\tans = min(ans, l_res + r_res + k - c_num)\\n\\telif c_num + l_num < k:\\n\\t\\tans = min(ans, r_res + k - c_num)\\n\\telif c_num + r_num < k:\\n\\t\\tans = min(ans, l_res + k - c_num)\\n\\telse:\\n\\t\\tans = min(ans, min(r_res, l_res) + k - c_num)\\n\\t#print(ans)\\n\\nprint(ans)\", \"n, k = list(map(int, input().split()))\\na = sorted(list(map(int, input().split())))\\nsums, suf, q1 = [0]*n, [n]*n, n\\nfor q in range(n-2, -1, -1):\\n    sums[q] = sums[q + 1]\\n    if a[q] != a[q1-1]:\\n        sums[q] += (n-q1)*(a[q1-1]-a[q])+(q1-q-1)*(a[q1-1]-a[q]-1)\\n        q1 = q + 1\\n    suf[q] = q1\\nans, sum1, q1 = sums[0]+k-suf[0] if suf[0] < k else 0, 0, -1\\nfor q in range(1, n):\\n    if a[q] != a[q1 + 1]:\\n        sum1 += (q1+1)*(a[q]-a[q1+1])+(q-q1-1)*(a[q]-a[q1+1]-1)\\n        q1 = q - 1\\n    if suf[q]-q1-1 >= k:\\n        ans = 0\\n        break\\n    if k <= suf[q]:\\n        ans = min(ans, sum1+k-suf[q]+q1+1)\\n    if k < n-q1:\\n        ans = min(ans, sums[q]+k-suf[q]+q1+1)\\n    ans = min(ans, sum1+sums[q]+k-suf[q]+q1+1)\\nprint(ans)\\n\"]", "task": "apps", "difficulty": "introductory", "split": "test", "transformation_type": "plain_summary"}