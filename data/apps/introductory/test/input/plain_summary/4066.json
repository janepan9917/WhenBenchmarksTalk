{"qid": 4066, "orig_input": "You are given an array $a$ consisting of $n$ integers $a_1, a_2, \\dots, a_n$.\n\nYour problem is to find such pair of indices $i, j$ ($1 \\le i < j \\le n$) that $lcm(a_i, a_j)$ is minimum possible.\n\n$lcm(x, y)$ is the least common multiple of $x$ and $y$ (minimum positive number such that both $x$ and $y$ are divisors of this number).\n\n\n-----Input-----\n\nThe first line of the input contains one integer $n$ ($2 \\le n \\le 10^6$) \u2014 the number of elements in $a$.\n\nThe second line of the input contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^7$), where $a_i$ is the $i$-th element of $a$.\n\n\n-----Output-----\n\nPrint two integers $i$ and $j$ ($1 \\le i < j \\le n$) such that the value of $lcm(a_i, a_j)$ is minimum among all valid pairs $i, j$. If there are multiple answers, you can print any.\n\n\n-----Examples-----\nInput\n5\n2 4 8 3 6\n\nOutput\n1 2\n\nInput\n5\n5 2 11 3 7\n\nOutput\n2 4\n\nInput\n6\n2 5 10 1 10 2\n\nOutput\n1 4", "input": "Find the pair of indices in an array that yields the minimum least common multiple (LCM) of their corresponding elements.", "test_cases": {"inputs": ["5\n2 4 8 3 6\n", "5\n5 2 11 3 7\n", "6\n2 5 10 1 10 2\n", "2\n1 1\n", "2\n10000000 9999999\n", "4\n21 23 26 28\n", "2\n7 2\n", "2\n6 7\n", "2\n4 4\n", "2\n8 8\n", "2\n6 5\n", "3\n3 4 3\n", "3\n8 8 6\n", "3\n7 4 7\n", "3\n8 6 7\n", "3\n6 7 8\n", "4\n8 6 8 1\n", "4\n6 4 4 7\n", "4\n7 3 3 4\n", "4\n7 7 6 7\n", "4\n7 5 5 6\n", "5\n4 7 6 6 6\n", "5\n3 4 4 2 3\n", "5\n5 5 4 5 8\n", "5\n7 4 5 5 5\n", "5\n7 6 7 8 5\n", "3\n10000000 9999999 9999997\n", "2\n999999 1000000\n", "4\n9999991 9999883 9999659 9999433\n", "3\n1 1 10000000\n", "3\n10000000 9999999 9999998\n"], "outputs": ["1 2\n", "2 4\n", "1 4\n", "1 2\n", "1 2\n", "1 4\n", "1 2\n", "1 2\n", "1 2\n", "1 2\n", "1 2\n", "1 3\n", "1 2\n", "1 3\n", "1 2\n", "1 3\n", "2 4\n", "2 3\n", "2 3\n", "1 2\n", "2 3\n", "3 4\n", "1 5\n", "1 2\n", "3 4\n", "1 3\n", "2 3\n", "1 2\n", "3 4\n", "1 2\n", "1 3\n"]}, "solutions": "[\"import math\\nfrom collections import defaultdict\\nimport sys\\ninput = sys.stdin.readline\\n\\n\\ndef main():\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n\\n    MAX = 10**7 + 1\\n    res = MAX * MAX\\n\\n    #MAX_P = int(math.sqrt(MAX))\\n    MAX_P = 3163\\n\\n    primes = []\\n    p = 2\\n    sieve = [True] * (MAX_P+1)\\n    while p < MAX_P:\\n        if sieve[p]:\\n            primes.append(p)\\n            k = 2\\n            while k * p < MAX_P:\\n                sieve[k * p] = False\\n                k += 1\\n        p += 1\\n\\n    np = len(primes)\\n    cand1 = {}\\n    cand2 = {}\\n    ind1 = {}\\n    ind2 = {}\\n\\n    res = MAX * MAX\\n    for index in range(n):\\n        val = a[index]\\n        if val >= res:\\n            continue\\n\\n        divisors = [1]\\n        p = 0\\n        while val > 0 and p < np:\\n            while val % primes[p] == 0:\\n                divisors += [d * primes[p] for d in divisors]\\n                val //= primes[p]\\n            p += 1\\n        if val > 1:\\n            divisors += [d * val for d in divisors]\\n\\n        for d in set(divisors):\\n            if d not in cand1:\\n                cand1[d] = a[index]\\n                ind1[d] = index\\n            else:\\n                if d not in cand2:\\n                    if a[index] < cand1[d]:\\n                        cand2[d] = cand1[d]\\n                        ind2[d] = ind1[d]\\n                        cand1[d] = a[index]\\n                        ind1[d] = index\\n                    else:\\n                        cand2[d] = a[index]\\n                        ind2[d] = index\\n                else:\\n                    if a[index] < cand1[d]:\\n                        cand2[d] = cand1[d]\\n                        ind2[d] = ind1[d]\\n                        cand1[d] = a[index]\\n                        ind1[d] = index\\n                    elif a[index] < cand2[d]:\\n                        cand2[d] = a[index]\\n                        ind2[d] = index\\n                    else:\\n                        continue\\n                if res > cand1[d] // d * cand2[d]:\\n                    x, y = ind1[d], ind2[d]\\n                    res = cand1[d] // d * cand2[d]\\n\\n    print(min(x+1, y+1), max(x+1, y+1))\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\"]", "task": "apps", "difficulty": "introductory", "split": "test", "transformation_type": "plain_summary"}