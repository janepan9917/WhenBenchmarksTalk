{"qid": 4120, "orig_input": "There are $n$ cities in Berland. Some pairs of cities are connected by roads. All roads are bidirectional. Each road connects two different cities. There is at most one road between a pair of cities. The cities are numbered from $1$ to $n$.\n\nIt is known that, from the capital (the city with the number $1$), you can reach any other city by moving along the roads.\n\nThe President of Berland plans to improve the country's road network. The budget is enough to repair exactly $n-1$ roads. The President plans to choose a set of $n-1$ roads such that:\n\n  it is possible to travel from the capital to any other city along the $n-1$ chosen roads,  if $d_i$ is the number of roads needed to travel from the capital to city $i$, moving only along the $n-1$ chosen roads, then $d_1 + d_2 + \\dots + d_n$ is minimized (i.e. as minimal as possible). \n\nIn other words, the set of $n-1$ roads should preserve the connectivity of the country, and the sum of distances from city $1$ to all cities should be minimized (where you can only use the $n-1$ chosen roads).\n\nThe president instructed the ministry to prepare $k$ possible options to choose $n-1$ roads so that both conditions above are met.\n\nWrite a program that will find $k$ possible ways to choose roads for repair. If there are fewer than $k$ ways, then the program should output all possible valid ways to choose roads.\n\n\n-----Input-----\n\nThe first line of the input contains integers $n$, $m$ and $k$ ($2 \\le n \\le 2\\cdot10^5, n-1 \\le m \\le 2\\cdot10^5, 1 \\le k \\le 2\\cdot10^5$), where $n$ is the number of cities in the country, $m$ is the number of roads and $k$ is the number of options to choose a set of roads for repair. It is guaranteed that $m \\cdot k \\le 10^6$.\n\nThe following $m$ lines describe the roads, one road per line. Each line contains two integers $a_i$, $b_i$ ($1 \\le a_i, b_i \\le n$, $a_i \\ne b_i$) \u2014 the numbers of the cities that the $i$-th road connects. There is at most one road between a pair of cities. The given set of roads is such that you can reach any city from the capital.\n\n\n-----Output-----\n\nPrint $t$ ($1 \\le t \\le k$) \u2014 the number of ways to choose a set of roads for repair. Recall that you need to find $k$ different options; if there are fewer than $k$ of them, then you need to find all possible different valid options.\n\nIn the following $t$ lines, print the options, one per line. Print an option as a string of $m$ characters where the $j$-th character is equal to '1' if the $j$-th road is included in the option, and is equal to '0' if the road is not included. The roads should be numbered according to their order in the input. The options can be printed in any order. All the $t$ lines should be different.\n\nSince it is guaranteed that $m \\cdot k \\le 10^6$, the total length of all the $t$ lines will not exceed $10^6$.\n\nIf there are several answers, output any of them.\n\n\n-----Examples-----\nInput\n4 4 3\n1 2\n2 3\n1 4\n4 3\n\nOutput\n2\n1110\n1011\n\nInput\n4 6 3\n1 2\n2 3\n1 4\n4 3\n2 4\n1 3\n\nOutput\n1\n101001\n\nInput\n5 6 2\n1 2\n1 3\n2 4\n2 5\n3 4\n3 5\n\nOutput\n2\n111100\n110110", "input": "Given a connected graph, output multiple distinct minimum spanning trees that minimize the total distance from a designated root node to all other nodes.", "test_cases": {"inputs": ["4 4 3\n1 2\n2 3\n1 4\n4 3\n", "4 6 3\n1 2\n2 3\n1 4\n4 3\n2 4\n1 3\n", "5 6 2\n1 2\n1 3\n2 4\n2 5\n3 4\n3 5\n", "2 1 200000\n2 1\n", "3 2 100000\n1 2\n2 3\n", "3 2 100000\n1 2\n1 3\n", "3 3 1000\n1 2\n2 3\n3 1\n", "5 6 166666\n1 2\n1 3\n2 4\n2 5\n3 4\n3 5\n", "5 6 10\n4 5\n3 2\n3 5\n1 3\n5 1\n1 2\n", "6 9 10\n3 5\n3 2\n1 3\n2 1\n6 3\n1 6\n4 2\n1 5\n6 5\n", "10 14 100\n2 8\n4 7\n1 4\n9 1\n6 9\n8 6\n10 2\n8 4\n1 7\n6 5\n10 9\n3 10\n6 2\n1 3\n", "15 20 100\n6 7\n15 11\n2 15\n9 5\n9 1\n8 2\n2 10\n2 12\n3 11\n5 12\n14 9\n4 11\n11 2\n13 5\n12 7\n6 1\n13 3\n8 6\n10 8\n3 7\n", "16 20 100\n9 12\n7 1\n9 6\n1 5\n5 14\n9 11\n6 1\n3 1\n1 16\n5 6\n11 3\n9 5\n10 7\n13 1\n4 3\n5 16\n9 8\n15 13\n9 2\n14 3\n", "16 20 100\n8 4\n2 16\n8 7\n6 11\n8 9\n10 4\n1 4\n3 9\n5 8\n3 14\n5 6\n11 4\n10 15\n1 16\n9 5\n13 10\n5 14\n3 1\n12 16\n6 1\n", "16 20 100\n7 8\n6 5\n15 1\n7 2\n2 12\n1 7\n7 9\n13 15\n11 14\n3 10\n8 3\n2 14\n3 4\n1 5\n4 15\n10 12\n11 4\n4 8\n7 16\n14 13\n", "16 20 100\n6 3\n15 16\n14 2\n15 5\n6 12\n13 16\n9 12\n16 3\n5 11\n16 14\n10 8\n4 3\n2 7\n8 14\n2 3\n1 3\n13 15\n14 3\n3 5\n8 2\n", "16 20 100\n4 6\n7 15\n10 5\n8 6\n9 11\n12 15\n14 1\n13 7\n12 2\n4 12\n14 16\n3 16\n9 15\n4 5\n8 15\n6 3\n2 11\n9 12\n5 15\n3 11\n", "18 23 100\n5 13\n10 2\n6 3\n8 2\n1 16\n18 10\n12 1\n2 1\n18 2\n6 2\n4 1\n16 7\n15 18\n17 11\n9 17\n17 3\n16 15\n12 14\n14 17\n5 9\n9 2\n17 13\n7 10\n", "18 23 100\n12 14\n2 11\n1 13\n2 7\n18 17\n16 13\n9 13\n15 1\n9 12\n3 4\n10 11\n18 4\n2 18\n13 8\n5 6\n9 2\n9 4\n13 5\n5 15\n15 4\n18 1\n10 9\n16 5\n", "18 23 100\n14 1\n4 3\n2 9\n16 10\n10 12\n10 1\n6 15\n1 8\n3 12\n11 14\n9 8\n15 1\n15 9\n7 10\n1 5\n18 16\n3 1\n8 14\n4 9\n11 13\n13 6\n10 17\n13 15\n", "18 23 100\n5 13\n6 7\n8 2\n13 7\n18 12\n11 18\n9 5\n5 4\n17 15\n11 4\n6 13\n13 15\n18 16\n14 15\n4 8\n7 2\n12 14\n12 1\n2 10\n13 4\n8 5\n3 18\n1 10\n", "18 23 100\n4 16\n12 17\n2 12\n16 13\n5 8\n2 18\n5 15\n11 5\n15 11\n13 9\n10 4\n15 10\n13 7\n14 15\n4 9\n5 1\n6 13\n3 17\n18 11\n15 3\n9 5\n1 9\n3 5\n"], "outputs": ["2\n1110\n1011\n", "1\n101001\n", "2\n111100\n110110\n", "1\n1\n", "1\n11\n", "1\n11\n", "1\n101\n", "4\n111100\n110110\n111001\n110011\n", "1\n100111\n", "1\n001101110\n", "6\n10111001111001\n00111011111001\n00111001111011\n10111001110101\n00111011110101\n00111001110111\n", "4\n10111100111101010111\n10111100011111010111\n10111100101101110111\n10111100001111110111\n", "4\n11111011101011101110\n11011011101111101110\n11110011101011101111\n11010011101111101111\n", "2\n11110111011011010111\n11100111011111010111\n", "8\n11111111011101101010\n11111111010111101010\n11111111001101111010\n11111111000111111010\n11111111011001101011\n11111111010011101011\n11111111001001111011\n11111111000011111011\n", "4\n11001111101111110110\n11001111101110110111\n10011111101111110110\n10011111101110110111\n", "6\n11111011101111011001\n11111011011111011001\n11111011001111011101\n11111011101101111001\n11111011011101111001\n11111011001101111101\n", "4\n11111011111101101101100\n01111011111101101101110\n11111011111101001111100\n01111011111101001111110\n", "4\n11111111110111100100110\n11111111110011100101110\n11111111110111100010110\n11111111110011100011110\n", "4\n11111111011101111000011\n11111111010111111000011\n11110111111101111000011\n11110111110111111000011\n", "4\n01111110110011011110111\n01111110100011111110111\n01101110110111011110111\n01101110100111111110111\n", "4\n11001111011011111110011\n11001111010111111110011\n01011111011011111110011\n01011111010111111110011\n"]}, "solutions": "[\"import sys\\nimport os\\n\\nclass Path():\\n    def __init__(self, idx, s, d):\\n        self.idx = idx\\n        self.s = s\\n        self.d = d\\n\\n    def __eq__(self, rhs):\\n        return self.s == rhs.s and self.d == rhs.d\\n\\n    def __hash__(self):\\n        return self.s * 100000 + self.d\\n\\ndef shortestPath(n, k, paths):\\n    ps = dict()\\n    for p in paths:\\n        if p.s not in ps:\\n            ps[p.s] = [p]\\n        else:\\n            ps[p.s].append(p)\\n\\n        if p.d not in ps:\\n            ps[p.d] = [p]\\n        else:\\n            ps[p.d].append(p)\\n\\n    d = set()\\n    open = set()\\n\\n    d.add(1)\\n    for e in paths:\\n        if e.s == 1 or e.d == 1:\\n            open.add(e)\\n\\n    general_edges = []\\n    general_choices = []\\n    while len(d) < n:\\n        newd = set()\\n        choices = dict()\\n        for e in open:\\n            oe = e.s\\n            if e.s in d:\\n                oe = e.d\\n\\n            newd.add(oe)\\n\\n            if oe not in choices:\\n                choices[oe] = [e.idx]\\n            else:\\n                choices[oe].append(e.idx)\\n\\n        d.update(newd)\\n        for oe, p in choices.items():\\n            if len(p) > 1:\\n                general_choices.append(p)\\n            else:\\n                general_edges.append(p[0])\\n\\n        open = set()\\n        for node in newd:\\n            for p in ps[node]:\\n                if (p.s in d) != (p.d in d):\\n                    open.add(p)\\n\\n    maxk = 1\\n    for choice in general_choices:\\n        maxk *= len(choice)\\n\\n    k = min(k, maxk)\\n    print(k)\\n    output = ['0'] * len(paths)\\n    for e in general_edges:\\n        output[e] = '1'\\n    for e in general_choices:\\n        output[e[0]] = '1'\\n\\n    for i in range(k):\\n        print(''.join(output))\\n\\n        for choice in general_choices:\\n            done = False\\n            for i in range(len(choice) - 1):\\n                if output[choice[i]] == '1':\\n                    output[choice[i]] = '0'\\n                    output[choice[i + 1]] = '1'\\n                    done = True\\n                    break\\n\\n            if done:\\n                break\\n\\n            output[choice[len(choice) - 1]] = '0'\\n            output[choice[0]] = '1'\\n\\ndef main():\\n    n, m, k = (int(x) for x in input().split())\\n    paths = []\\n    for i in range(m):\\n        path = [int(x) for x in input().split()]\\n        paths.append(Path(i, path[0], path[1]))\\n    shortestPath(n, k, paths)\\n\\ndef __starting_point():\\n    main()\\n__starting_point()\", \"from math import inf\\nimport heapq\\n\\nn, m, k = map(int, input().split(' '))\\n\\nedge = [[] for _ in range(n)]\\n\\nfor i in range(m):\\n    a, b = map(int, input().split(' '))\\n    edge[a-1].append((i, b-1))\\n    edge[b-1].append((i, a-1))\\n\\nd = [inf  for _ in range(n)]\\nd[0] = 0\\n\\nq = [0 for _ in range(n)]\\nf = 0\\nr = 1\\nwhile f < r:\\n    i = q[f]\\n    f += 1\\n    for (_, j) in edge[i]:\\n        if d[j] == inf:\\n            d[j] = d[i]+1\\n            q[r] = j\\n            r += 1\\n\\n#print(d)\\n\\npre = [[] for _ in range(n)]\\n\\nfor i in range(n):\\n    for (ind, j) in edge[i]:\\n        if d[j] == d[i]-1:\\n            pre[i].append((ind, j))\\n\\n#print(pre)\\n\\ns = [0 for _ in range(n)]\\ntop = n\\nsol = []\\nwhile top > 0:\\n    #print(top, s)\\n    if top == n:\\n        u = ['0' for _ in range(m)]\\n        #print(s)\\n        for i in range(1,n):\\n            u[pre[i][s[i]][0]] = '1'\\n        sol.append(\\\"\\\".join(u))\\n        if len(sol) == k:\\n            break\\n        top -= 1\\n    else:\\n        s[top] += 1\\n        if s[top] == len(pre[top]):\\n            top -= 1\\n            #s[top] += 1\\n        else:\\n            top += 1\\n            if top < n:\\n                s[top] = -1\\n\\nprint(len(sol))\\nfor x in sol:\\n    print(x)\", \"n, m, k = [int(x) for x in input().split()]\\nE = [[] for _ in range(n)]\\nfor i in range(m):\\n    a, b = [int(x) for x in input().split()]\\n    E[a - 1].append((b - 1, i))\\n    E[b - 1].append((a - 1, i))\\n\\n\\nQ = [0]\\nINFTY = n + 1\\nlevels = [INFTY] * n\\nlevels[0] = 0\\nE_min = [[] for _ in range(n)]\\n# bfs\\nwhile len(Q) > 0:\\n    city = Q.pop(0)\\n    for adj, i in E[city]:\\n        if levels[city] + 1 <= levels[adj]:\\n            if levels[adj] == INFTY:\\n                Q.append(adj)\\n            levels[adj] = levels[city] + 1\\n            E_min[adj].append(i)\\n\\ndef gen_poss(city, selected, all_poss, next_choice, poss):\\n    if len(all_poss) >= k:\\n        return\\n\\n    if poss >= k:\\n        all_poss.append(''.join(selected))\\n        return\\n\\n    if city == n:\\n        all_poss.append(''.join(selected))\\n    else:\\n        # choose one from E_min[edge]\\n        for i in E_min[city]:\\n            selected[i] = '1'\\n            next_city = next_choice[city]   # skip edges with only one choice\\n            gen_poss(next_city, selected, all_poss, next_choice, poss * len(E_min[city]))\\n            selected[i] = '0'\\n\\n\\nnext_choice = [0] * n\\nselected = ['0'] * m\\nnc = n\\nfor i in range(n - 1, -1, -1):\\n    next_choice[i] = nc\\n    if len(E_min[i]) > 1:\\n        nc = i\\n    if len(E_min[i]) >= 1:\\n        selected[E_min[i][0]] = '1'\\nall_poss = []\\ngen_poss(next_choice[0], selected, all_poss, next_choice, 1)\\n\\nprint('{}\\\\n{}'.format(len(all_poss), '\\\\n'.join(all_poss)))\", \"from math import inf\\n\\nnmk = list(map(int, input().split(' ')))\\nn = nmk[0]\\nm = nmk[1]\\nk = nmk[2]\\n\\na = []\\n\\nfor i in range(m):\\n\\ta.append(list(map(int, input().split(' '))))\\n\\nsmej = [[] for j in range(n)]\\nnums = {}\\n\\nt = 0\\nfor i in a:\\n\\tnums.update({(i[0], i[1]):t})\\n\\tt += 1\\n\\tsmej[i[0]-1].append(i[1]-1)\\n\\tsmej[i[1]-1].append(i[0]-1)\\n\\t\\ndists = [inf for i in range(n)]\\ndists[0] = 0\\nq = [0]\\n\\nwhile len(q) > 0:\\n\\tu = q.pop(0)\\n\\t\\n\\tfor i in smej[u]:\\n\\t\\tif (dists[i] == inf):\\n\\t\\t\\tq.append(i)\\n\\t\\t\\tdists[i] = dists[u] + 1\\n\\t\\t\\t\\t\\np = [[] for i in range(n)]\\n\\t\\t\\t\\nfor i in range(1, n):\\n\\tfor j in smej[i]:\\n\\t\\tif(dists[j] == dists[i]-1):\\n\\t\\t\\ttry:\\n\\t\\t\\t\\tp[i].append(nums[(j+1,i+1)])\\n\\t\\t\\texcept:\\n\\t\\t\\t\\tp[i].append(nums[(i+1,j+1)])\\n\\nam = 1\\np.pop(0)\\n\\nfor i in range(len(p)):\\n\\tam *= len(p[i])\\n\\nif(am < k):\\n\\tprint(am)\\nelse:\\n\\tprint(k)\\n\\nf = [0 for i in range(len(p))]\\nans = []\\n\\nfor i in range(k):\\n\\ts = ['0'for i in range(m)]\\n\\t\\n\\tfor j in range(len(p)):\\n\\t\\ts[p[j][f[j]]] = '1'\\n\\t\\n\\ts = ''.join(s)\\n\\tans.append(s)\\n\\n\\tok = False\\n\\tfirst = True\\n\\t\\n\\tfor j in range(len(p)-1, -1, -1):\\n\\t\\tif first:\\n\\t\\t\\tfirst = False\\n\\t\\t\\tif(f[j]+1 == len(p[j])):\\n\\t\\t\\t\\tif(j == 0):\\n\\t\\t\\t\\t\\tok = True\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tf[j] = 0\\n\\t\\t\\t\\tf[j-1]+= 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tf[j]+= 1\\n\\t\\t\\t\\tbreak\\n\\t\\telse:\\n\\t\\t\\tif(f[j] == len(p[j])):\\n\\t\\t\\t\\tif(j == 0):\\n\\t\\t\\t\\t\\tok = True\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tf[j] = 0\\n\\t\\t\\t\\t\\tf[j-1] += 1\\n\\tif ok:\\n\\t\\tbreak\\n\\nfor j in range(len(ans)):\\n\\tprint(ans[j])\\n\\n\\n\\n\\n\\n\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\", \"import sys\\ninput=lambda:sys.stdin.readline().rstrip()\\nsys.setrecursionlimit(200001)\\nn,m,k=list(map(int,input().split()))\\nedge=[[]for _ in range(n)]\\ndi={}\\nfor i in range(m):\\n  a,b=list(map(int,input().split()))\\n  a-=1\\n  b-=1\\n  if a>b:a,b=b,a\\n  di[(a,b)]=i\\n  edge[a].append(b)\\n  edge[b].append(a)\\nd=[10**10]*n\\nd[0]=0\\nroot=[set()for _ in range(n)]\\nqueue=[0]\\nfor node in queue:\\n  for mode in edge[node]:\\n    if d[mode]!=10**10:\\n      if d[mode]+1==d[node]:\\n        root[node].add(mode)\\n      elif d[mode]==d[node]+1:\\n        root[mode].add(node)\\n      continue\\n    d[mode]=d[node]+1\\n    queue.append(mode)\\nfor i in range(n):root[i]=list(root[i])\\nt=1\\nfor i in range(1,n):t*=len(root[i])\\nprint(min(t,k))\\nfor i in range(min(t,k)):\\n  ans=[\\\"0\\\"]*m\\n  for j in range(1,n):\\n    i,jj=divmod(i,len(root[j]))\\n    ans[di[(min(j,root[j][jj]),max(j,root[j][jj]))]]=\\\"1\\\"\\n  print(\\\"\\\".join(ans))\\n\"]", "task": "apps", "difficulty": "introductory", "split": "test", "transformation_type": "plain_summary"}