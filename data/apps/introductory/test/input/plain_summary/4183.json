{"qid": 4183, "orig_input": "We have N clocks. The hand of the i-th clock (1\u2264i\u2264N) rotates through 360\u00b0 in exactly T_i seconds.\n\nInitially, the hand of every clock stands still, pointing directly upward.\n\nNow, Dolphin starts all the clocks simultaneously.\n\nIn how many seconds will the hand of every clock point directly upward again?\n\n-----Constraints-----\n - 1\u2264N\u2264100 \n - 1\u2264T_i\u226410^{18} \n - All input values are integers.  \n - The correct answer is at most 10^{18} seconds.\n\n-----Input-----\nInput is given from Standard Input in the following format:  \nN\nT_1\n:  \nT_N\n\n-----Output-----\nPrint the number of seconds after which the hand of every clock point directly upward again.\n\n-----Sample Input-----\n2\n2\n3\n\n-----Sample Output-----\n6\n\nWe have two clocks. The time when the hand of each clock points upward is as follows:\n - Clock 1: 2, 4, 6, ... seconds after the beginning\n - Clock 2: 3, 6, 9, ... seconds after the beginning\nTherefore, it takes 6 seconds until the hands of both clocks point directly upward.", "input": "Calculate the least common multiple of rotation periods for multiple clocks to determine when they'll simultaneously point upward again.", "test_cases": {"inputs": ["2\n2\n3\n", "5\n2\n5\n10\n1000000000000000000\n1000000000000000000\n", "75\n22\n1968854689373829\n87153\n51936214827607\n174306\n89708007429503\n37408239098102751\n5282\n89708007429503\n57\n417\n28328844451422\n311617288965642\n822981260158260522\n14164422225711\n2\n5920728490347198\n103872429655214\n28328844451422\n7219133861037373\n418\n418\n7219133861037373\n29051\n2960364245173599\n411490630079130261\n3058\n7219133861037373\n834\n33\n14164422225711\n51936214827607\n114\n24938826065401834\n139\n4587\n418\n6\n7219133861037373\n15846\n834\n51936214827607\n311617288965642\n155808644482821\n7923\n14164422225711\n179416014859006\n155808644482821\n139\n3058\n418\n7219133861037373\n1973576163449066\n2960364245173599\n139\n418\n33\n14438267722074746\n139\n7219133861037373\n38\n538248044577018\n1973576163449066\n278\n137163543359710087\n1254\n269124022288509\n43314803166224238\n417\n274327086719420174\n21657401583112119\n656284896457943\n5282\n209\n38\n", "100\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n8324330666941631\n", "2\n35121409\n52986961\n", "100\n378851070\n30495947160070\n237677\n2516171273\n3186774591\n13209\n2574390\n44028259795\n53450045\n323578005270\n11594\n70880089\n680046290\n3777774\n14982329441010\n1721446090\n250134430\n4552702\n340381426\n2535789894\n205713497990\n7703531\n6117431593\n127063558167\n2156826905849\n19443138\n361053770\n936743605\n70068713\n289291530\n2841476273295\n887030859\n8920835\n9178442\n483621117\n249651545\n17100553470\n30247531265\n148682391\n20348167686\n37930404206310\n1319953509105\n829687193\n362235\n523888365\n709284973254\n4005535682291\n16211\n10816210\n101358654\n8474741\n56103681270\n9442259\n22943811\n401845535\n8422797526\n23639078\n67756390\n35597316430\n2710716681\n14105\n65797074618\n3866544770\n54560382558\n1895271945\n2928387462\n13505646\n7375654\n37162195\n38168130\n3442319205\n147552522\n39149565\n1924962\n11362452010\n133476945\n18277680135\n3049594716007\n1006366256282310\n1321740862\n246800730\n28349178\n1489547735\n42629217\n29008339981530\n84709038778\n13846602\n5616823443\n501260793\n96467190505\n16168117735\n537586\n10982920419185\n51226493142\n5847270\n756465\n25933670\n4350140795\n174048567\n608812012270\n", "100\n2770511515200\n1124622030\n228009600\n66119933880\n582307520256\n512697900\n324475200\n3148308540\n1434837060\n1843661648400\n7127148\n39230730\n22033411200\n944570484\n99885614400\n1073592\n86223945600\n52946180672\n43876879200\n3690377600\n154752\n140140\n25924864\n741332481\n2425048470\n11544666\n129850236672\n40978002240\n15775320\n594345024\n2480\n181889608320\n6265618349760\n7983360\n12313833840\n987704640\n8145303854688\n8998704\n142962019200\n95578540785\n681589755\n6752592\n1245335\n1023120\n219459240\n14351264\n2778327136\n37494912\n8928\n865555761600\n91827456\n213962\n506839347705600\n49100480\n9396354240\n576969120\n927999072\n799110312\n169716816\n4417319059200\n3124872\n252036744960\n12039060\n2291572800\n2037666533760\n35218927744\n67456\n126489384\n1297660\n35915348700\n3235617\n9033314400\n41379885892800\n2920581300\n3181360\n27572400\n28405\n77022999900\n301587\n1351245952\n22971\n785019200\n4035782400\n246847753152\n11449339200\n15247232\n2510766720\n3284396715600\n30254016\n6380\n391875840\n411406133600\n1880167161600\n615393174816\n33587136\n18928359450\n2487643200\n4112960432490\n342034131600\n61999938\n", "23\n2\n4\n8\n16\n32\n64\n128\n3\n9\n27\n5\n25\n125\n7\n49\n11\n13\n17\n19\n23\n29\n31\n37\n", "2\n8373882553630601\n6825769812623263\n", "96\n8643848\n8857955177102492\n10\n290649389\n7619107\n11072443971378115\n329292014018680\n20495397830\n65858402803736\n16464600700934\n8\n44289775885512460\n2214488794275623\n76191070\n5402405\n1\n11072443971378115\n8232300350467\n11072443971378115\n32929201401868\n15238214\n2160962\n1076\n2\n5402405\n21609620\n10760\n1080481\n40990795660\n20\n269\n290649389\n7619107\n164646007009340\n2906493890\n40990795660\n8643848\n10247698915\n21609620\n5\n2214488794275623\n329292014018680\n20495397830\n11625975560\n8232300350467\n2906493890\n581298778\n1\n2690\n1453246945\n21609620\n20\n1080481\n538\n20\n5380\n4099079566\n11072443971378115\n1076\n290649389\n21609620\n329292014018680\n2325195112\n88579551771024920\n1453246945\n5812987780\n20495397830\n8232300350467\n2214488794275623\n2160962\n7619107\n1345\n2049539783\n8857955177102492\n5812987780\n2690\n5\n11625975560\n4321924\n20495397830\n76191070\n2906493890\n5\n1\n20495397830\n8643848\n30476428\n2\n16464600700934\n10247698915\n10247698915\n1345\n82323003504670\n4099079566\n581298778\n17715910354204984\n", "12\n24602221\n4877\n3126157\n157045\n3514603\n321155327\n31409\n765908465\n12326262605587\n16133495\n2248087289\n191905\n", "89\n1\n1\n1\n967743772045\n621227\n3106135\n193548754409\n3106135\n193548754409\n5\n120237712055239843\n120237712055239843\n621227\n601188560276199215\n1\n3106135\n120237712055239843\n3106135\n120237712055239843\n5\n5\n5\n193548754409\n120237712055239843\n193548754409\n601188560276199215\n193548754409\n621227\n120237712055239843\n120237712055239843\n601188560276199215\n120237712055239843\n3106135\n621227\n5\n3106135\n601188560276199215\n601188560276199215\n601188560276199215\n193548754409\n3106135\n1\n5\n193548754409\n193548754409\n601188560276199215\n601188560276199215\n1\n621227\n120237712055239843\n1\n601188560276199215\n193548754409\n193548754409\n120237712055239843\n1\n3106135\n193548754409\n120237712055239843\n1\n1\n3106135\n1\n601188560276199215\n967743772045\n5\n1\n967743772045\n1\n120237712055239843\n193548754409\n3106135\n601188560276199215\n193548754409\n601188560276199215\n621227\n120237712055239843\n621227\n193548754409\n5\n193548754409\n621227\n967743772045\n3106135\n120237712055239843\n3106135\n1\n3106135\n5\n", "35\n1\n1\n1\n1\n724303797378088699\n724303797378088699\n1\n1\n1\n1\n724303797378088699\n724303797378088699\n724303797378088699\n724303797378088699\n1\n1\n724303797378088699\n724303797378088699\n1\n1\n1\n724303797378088699\n1\n724303797378088699\n724303797378088699\n724303797378088699\n1\n1\n724303797378088699\n1\n724303797378088699\n1\n724303797378088699\n724303797378088699\n724303797378088699\n", "100\n1\n1\n1\n999999999999999989\n1\n999999999999999989\n1\n1\n999999999999999989\n1\n999999999999999989\n999999999999999989\n1\n999999999999999989\n999999999999999989\n999999999999999989\n1\n1\n999999999999999989\n1\n1\n999999999999999989\n1\n999999999999999989\n999999999999999989\n1\n999999999999999989\n1\n999999999999999989\n1\n1\n1\n999999999999999989\n999999999999999989\n999999999999999989\n999999999999999989\n999999999999999989\n999999999999999989\n1\n999999999999999989\n1\n999999999999999989\n999999999999999989\n999999999999999989\n1\n1\n1\n1\n999999999999999989\n999999999999999989\n1\n1\n1\n1\n999999999999999989\n1\n999999999999999989\n1\n1\n999999999999999989\n999999999999999989\n999999999999999989\n999999999999999989\n1\n999999999999999989\n1\n1\n999999999999999989\n1\n999999999999999989\n999999999999999989\n1\n999999999999999989\n1\n1\n1\n999999999999999989\n999999999999999989\n1\n999999999999999989\n1\n1\n1\n1\n1\n999999999999999989\n1\n999999999999999989\n1\n999999999999999989\n1\n1\n999999999999999989\n999999999999999989\n1\n1\n1\n1\n999999999999999989\n1\n", "100\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n999999999999999967\n", "1\n123456789012345671\n", "100\n1\n9998999000109989\n99999989\n99999989\n9998999000109989\n9998999000109989\n99999989\n1\n99999989\n99990001\n1\n99999989\n99999989\n1\n9998999000109989\n1\n99990001\n1\n9998999000109989\n99999989\n99990001\n1\n99990001\n99990001\n99999989\n99990001\n9998999000109989\n99990001\n99999989\n99999989\n1\n9998999000109989\n99999989\n9998999000109989\n99990001\n99990001\n1\n99999989\n1\n9998999000109989\n99990001\n1\n1\n99999989\n9998999000109989\n99999989\n99990001\n1\n99990001\n9998999000109989\n9998999000109989\n99990001\n99999989\n9998999000109989\n99990001\n99999989\n1\n9998999000109989\n1\n9998999000109989\n1\n1\n99999989\n1\n1\n1\n9998999000109989\n1\n99990001\n1\n1\n99990001\n99990001\n99990001\n99990001\n99990001\n99999989\n9998999000109989\n9998999000109989\n9998999000109989\n99999989\n99999989\n99990001\n9998999000109989\n99990001\n1\n1\n9998999000109989\n99999989\n1\n99999989\n99999989\n99990001\n9998999000109989\n1\n99999989\n99999989\n1\n1\n9998999000109989\n"], "outputs": ["6\n", "1000000000000000000\n", "822981260158260522\n", "8324330666941631\n", "1860976728948049\n", "614889782588491410\n", "897612484786617600\n", "748010403988848000\n", "812266607702168297\n", "88579551771024920\n", "276539701556344345\n", "601188560276199215\n", "724303797378088699\n", "999999999999999989\n", "999999999999999967\n", "123456789012345671\n", "9998999000109989\n"]}, "solutions": "[\"\\nimport math\\nfrom functools import reduce\\n\\nurl = \\\"https://atcoder.jp//contests/abc070/tasks/abc070_c\\\"\\n\\ndef lcm_base(x, y):\\n    return (x * y) // math.gcd(x, y)\\n\\ndef lcm(*numbers):\\n    return reduce(lcm_base, numbers, 1)\\n\\ndef main():\\n    count = int(input())\\n    clocks = []\\n    for i in range(count):\\n        clocks.append(int(input()))\\n    print((lcm(*clocks)))\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"import math\\n\\ndef lcm(x, y):\\n    return x * y // math.gcd(x, y)\\n\\nn = int(input())\\nt = int(input())\\n\\nfor i in range(n - 1):\\n    num = int(input())\\n    t = lcm(t, num)\\nprint(t)\", \"import math\\n\\nN = int(input())\\nT = [int(input())for _ in range(N)]\\n\\nans = T[0]\\n\\nfor i in range(1,N):\\n    ans = (ans*T[i])//math.gcd(ans,T[i])\\n    ans %= 10**18+7\\nprint(ans)\\n    \\n\", \"import math\\n\\nn = int(input())\\ntl = list(int(input()) for _ in range(n))\\n\\nif n == 1:\\n    print(tl[0])\\nelse:\\n    ans = tl[0]\\n    for i in range(1, n):\\n        ans = ans//math.gcd(ans, tl[i])*tl[i]\\n\\n    print(ans)\", \"import math\\n\\ndef lcm(a,b):\\n    return a*b//math.gcd(a,b)\\n\\nN=int(input())\\nT=[int(input()) for _ in range(N)]\\nans=1\\nfor t in T:\\n    ans=lcm(ans,t)\\nprint(ans)\\n\", \"from functools import reduce\\nfrom fractions import gcd\\n\\nN = int(input())\\nT = list(int(input()) for _ in range(N))\\n\\ndef lcm_base(x, y):\\n    return (x*y)//gcd(x, y)\\n\\ndef lcm(numbers):\\n    return reduce(lcm_base, numbers, 1)\\n\\nprint((lcm(T)))\\n\", \"import math\\nfrom functools import reduce\\n\\ndef lcm_base(x, y):\\n    return (x * y) // math.gcd(x, y)\\n\\ndef lcm(*numbers):\\n    return reduce(lcm_base, numbers, 1)\\n\\ndef lcm_list(numbers):\\n    return reduce(lcm_base, numbers, 1)\\n\\nn = int(input())\\nt = [int(input()) for _ in range(n)]\\n\\nprint(lcm(*t))\", \"import math\\n\\nN = int(input())\\nT = [0] * N\\nfor i in range(N):\\n    T[i] = int(input())\\n\\nif N == 1:\\n    print((T[0]))\\nelif N == 2:\\n    print((T[0]*T[1]//math.gcd(T[0], T[1])))\\nelse:\\n    L = T[0]\\n    for i in range(1, N):\\n        L = L*T[i]//math.gcd(L, T[i])\\n    print(L)\\n\", \"import math\\n\\n\\ndef lcm(a, b):\\n    return a * b // math.gcd(a, b)\\n\\n\\nN = int(input())\\nans = int(input())\\nfor _ in range(N - 1):\\n    ans = lcm(ans, int(input()))\\nprint(ans)\", \"import math\\nN=int(input())\\na = [int(input()) for _ in range(N)]\\nans = a[0]\\nfor i in range(1, N):\\n    ans = ans * a[i] // math.gcd(ans, a[i])\\nprint(ans)\", \"N=int(input())\\nT=[int(input()) for _ in range(N)]\\n\\nimport math\\nfrom functools import reduce\\n\\nprint(reduce(lambda x,y : (x * y) // math.gcd(x, y), T,1))\", \"from math import gcd\\n\\nN = int(input())\\n\\nall_t = []\\ngcd_all = 0\\n\\nif N >= 2:\\n  for i in range(N):\\n    all_t.append(int(input()))\\n\\n    if i == 1:\\n      gcd_all = gcd(all_t[0], all_t[1])\\n      base = int(all_t[0] * all_t[1] // gcd_all)\\n    elif i >= 2:\\n      gcd_all = gcd(base, all_t[i])\\n      base = int(base * all_t[i] // gcd_all)\\n  print(base)\\nelse:\\n  print((int(input())))\\n\", \"from math import *\\n\\nN=int(input())\\nT=list(int(input()) for _ in range(N))\\nans=T[0]\\nfor i in range(1,N):\\n  ans=ans*T[i]//gcd(ans,T[i])\\nprint(ans)\\n\", \"import math\\ndef gcd(a, b):\\n    while b:\\n        a, b = b, a % b\\n    return a\\ndef lcm(x, y):\\n    return (x * y) // gcd(x, y)\\n\\nN = int(input())\\nT = [int(input()) for _ in range(N)]\\nif N == 1:\\n    print((T[0]))\\n    return\\n\\nans = lcm(T[0] , T[1])\\nfor i in range(2 , N):\\n    ans = lcm(T[i] , ans)\\nprint(ans)\\n\", \"import numpy as np\\nn = int(input())\\nlis = []\\nfor i in range(n):\\n    lis.append(int(input()))\\nprint(np.lcm.reduce(lis))\", \"from math import gcd\\nn = int(input())\\nt = list([int(input()) for _ in range(n)])\\nx = 1\\nfor i in t:\\n    x = x*i//gcd(x,i)\\nprint(x)\", \"import math\\nN = int(input())\\nlcm = int(input()) #T0\\nfor i in range(N-1):\\n    x = int(input())\\n    lcm = lcm * x // math.gcd(lcm,x)\\nprint(lcm)\", \"n = int(input())\\nt = [int(input()) for _ in range(n)]\\n\\nimport math\\nfrom functools import reduce\\ndef lcm_base(x, y):\\n    return (x * y) // math.gcd(x, y)\\ndef lcm(*numbers):\\n    return reduce(lcm_base, numbers, 1)\\nprint(lcm(*t))\", \"import sys\\nimport math\\npin=sys.stdin.readline\\n\\ndef main():\\n  N=int(pin())\\n  ans=int(pin())\\n  for i in range(N-1):\\n    T=int(pin())\\n    ans=(ans*T)//math.gcd(ans,T)\\n  print(ans)\\n  return\\nmain()\", \"import fractions\\nn=int(input())\\nt=[]\\nfor _ in range(n):\\n    T=int(input())\\n    t.append(T)\\nans=t[0]\\nfor i in range(1, len(t)):\\n    ans = ans * t[i] // fractions.gcd(ans, t[i])\\nprint(ans)    \", \"import math\\nfrom functools import reduce\\n\\ndef lcm_base(x, y):\\n\\treturn (x * y) // math.gcd(x, y)\\n\\ndef lcm(*numbers):\\n\\treturn reduce(lcm_base, numbers, 1)\\n\\ndef lcm_list(numbers):\\n\\treturn reduce(lcm_base, numbers, 1)\\n\\nn = int(input())\\nt = [0]*n\\nfor i in range(n):\\n\\tt[i] = int(input())\\nprint(lcm_list(t))\", \"import math\\ndef lcm(x, y):\\n    return (x * y) // math.gcd(x, y)\\n\\nN=int(input())\\na=int(input())\\nfor i in range(N-1):\\n    a=lcm(a,int(input()))\\nprint(a)\\n\", \"def lcm(m, n):\\n    return m//gcd(m, n)*n\\n\\n\\ndef gcd(m, n):\\n    r = m % n\\n    return gcd(n, r) if r else n\\n\\n\\nn = int(input())\\narr = [int(input()) for _ in range(n)]\\nans = 1\\nfor i in arr:\\n    ans = lcm(ans, i)\\n\\nprint(ans)\", \"import math\\nN = int(input())\\nT = int(input())\\nfor i in range(N-1):\\n    t = int(input())\\n    T = T // math.gcd(T, t) * t\\nprint(T)\", \"import math\\ndef lcm(x, y):\\n    return (x * y) // math.gcd(x, y)\\n\\nn=int(input())\\nt=[]\\nfor i in range(n):\\n    t.append(int(input()))\\n\\nans=t[0]\\nfor i in range(1,n):\\n    ans=lcm(ans,t[i])\\nprint(ans)\\n\", \"def delete_head_zeros(n):\\n\\tn = str(n)\\n\\tl = len(n)\\n\\tif \\\".\\\" in n:\\n\\t\\tl = n.find(\\\".\\\")\\n\\thead_zeros = 0\\n\\tfor i in range(l - 1):\\n\\t\\tif n[i] == \\\"0\\\":\\n\\t\\t\\thead_zeros += 1\\n\\t\\telse:\\n\\t\\t\\tbreak\\n\\n\\treturn n[head_zeros:]\\n\\n# compare a, b\\n# a, b: int or string\\ndef bigint_compare(a, b):\\n\\ta = delete_head_zeros(a)\\n\\tb = delete_head_zeros(b)\\n\\tif len(a) > len(b):\\n\\t\\treturn 1\\n\\telif len(a) < len(b):\\n\\t\\treturn -1\\n\\telse:\\n\\t\\tif a > b:\\n\\t\\t\\treturn 1\\n\\t\\telif a < b:\\n\\t\\t\\treturn -1\\n\\t\\telse:\\n\\t\\t\\treturn 0\\n\\n# calculate a + b\\n# a, b: int or string\\ndef bigint_plus(a, b):\\n\\ta = str(a)\\n\\tb = str(b)\\n\\n\\td = max([len(a), len(b)])\\n\\ta = '0' * (d - len(a)) + a\\n\\tb = '0' * (d - len(b)) + b\\n\\n\\tans = \\\"\\\"\\n\\tcarry = 0\\n\\tfor i in range(d):\\n\\t\\ts = int(a[-i-1]) + int(b[-i-1]) + carry\\n\\t\\tcarry = s // 10\\n\\t\\tans = str(s % 10) + ans\\n\\telse:\\n\\t\\tif carry:\\n\\t\\t\\tans = str(carry) + ans\\n\\n\\treturn ans\\n\\n# calculate a - b\\n# a, b: int or string\\ndef bigint_minus(a, b): \\n\\ta = str(a)\\n\\tb = str(b)\\n\\tM = []\\n\\tm = []\\n\\tsign = \\\"\\\"\\n\\n\\tif len(a) > len(b) or (len(a) == len(b) and a >= b):\\n\\t\\t[M, m] = [a, b]\\n\\telse:\\n\\t\\t[M, m] = [b, a]\\n\\t\\tsign = \\\"-\\\"\\n\\tm = '0' * (len(M) - len(m)) + m\\n\\n\\tans = \\\"\\\"\\n\\tborrow = 0\\n\\tfor i in range(len(M)):\\n\\t\\ts = int(M[-i-1]) - int(m[-i-1]) - borrow\\n\\t\\tif s < 0:\\n\\t\\t\\tborrow = 1\\n\\t\\t\\ts += 10\\n\\t\\telse:\\n\\t\\t\\tborrow = 0\\n\\t\\tans = str(s) + ans\\n\\n\\treturn sign + delete_head_zeros(ans)\\n\\n# calculate a * b\\n# a, b: int or string\\ndef bigint_multiply(a, b):\\n\\ta = str(a)\\n\\tb = str(b)\\n\\n\\tmd = []\\n\\tfor j in range(len(b)):\\n\\t\\tcarry = 0\\n\\t\\tmj = \\\"\\\"\\n\\t\\tfor i in range(len(a)):\\n\\t\\t\\tm = int(a[-i-1]) * int(b[-j-1]) + carry\\n\\t\\t\\tcarry = m // 10\\n\\t\\t\\tmj = str(m % 10) + mj\\n\\t\\telse:\\n\\t\\t\\tif carry:\\n\\t\\t\\t\\tmj = str(carry) + mj\\n\\t\\tmd.append(mj)\\n\\n\\tans = 0\\n\\tfor k in range(len(md)):\\n\\t\\tans = bigint_plus(md[k] + \\\"0\\\" * k, ans)\\n\\n\\treturn ans\\n\\n# calculate a / b to d digits after decimal point\\n# a, b, d: int or string\\ndef bigint_divide(a, b, d = 0):\\n\\ta = str(a)\\n\\tb = str(b)\\n\\td = int(d)\\n\\tif d < 0:\\n\\t\\td = 0\\n\\n\\tans = \\\"\\\"\\n\\tr = \\\"\\\"\\n\\tfor i in range(len(a) + d):\\n\\t\\tq = 0\\n\\t\\tif i < len(a):\\n\\t\\t\\tr += a[i]\\n\\t\\telif i == len(a):\\n\\t\\t\\tans += \\\".\\\"\\n\\t\\t\\tr += \\\"0\\\"\\n\\t\\telse:\\n\\t\\t\\tr += \\\"0\\\"\\n\\n\\t\\tif bigint_compare(r, b) == -1:\\n\\t\\t\\tans += str(q)\\n\\t\\telse:\\n\\t\\t\\twhile bigint_compare(r, b) >= 0:\\n\\t\\t\\t\\tr = bigint_minus(r, b)\\n\\t\\t\\t\\tq += 1\\n\\t\\t\\tans += str(q)\\n\\n\\treturn delete_head_zeros(ans)\\n\\ndef gcd(a, b):\\n\\tif bigint_compare(a, b) >= 0:\\n\\t\\tM = a\\n\\t\\tm = b\\n\\telse:\\n\\t\\tM = b\\n\\t\\tm = a\\n\\tif m == \\\"0\\\":\\n\\t\\treturn M\\n\\telse:\\n\\t\\tq = bigint_divide(M, m)\\n\\t\\tr = bigint_minus(M, bigint_multiply(m, q))\\n\\t\\treturn gcd(m, r)\\n\\ndef lcm(a, b):\\n\\treturn bigint_divide(bigint_multiply(a, b), gcd(a, b))\\n\\ndef main():\\n\\tN = int(input())\\n\\tT = [input() for i in range(N)]\\n\\tans = 1\\n\\tfor i in range(len(T)):\\n\\t\\tans = lcm(T[i], ans)\\n\\n\\tprint(ans)\\n\\nmain()\", \"import numpy as np\\nwith open(0) as f:\\n    N, *T = map(int, f.read().split())\\nans = 1\\nfor t in T:\\n    ans = np.lcm(ans, t)\\nprint(ans)\", \"# ==================================================-\\n# \\u6700\\u5927\\u516c\\u7d04\\u6570n\\u500b\\ndef euclid(a, b):\\n    if b == 0:\\n        return a\\n    else:\\n        return euclid(b, a % b)\\n\\n\\ndef multiple(a, b):\\n    return a * b // euclid(a, b)\\n\\n\\nimport functools\\n\\n\\n# ------\\u30e1\\u30a4\\u30f3\\u95a2\\u6570-------\\n# nums\\u306f\\u6574\\u6570\\u306e\\u30ea\\u30b9\\u30c8\\ndef lcm(nums):\\n    return functools.reduce(multiple, nums)\\n\\na=[]\\n\\nn=int(input())\\nfor i in range(n):\\n    a.append(int(input()))\\n\\nprint(lcm(a))\", \"import math\\nfrom functools import reduce\\n\\nn = int(input())\\nt = [int(input()) for _ in range(n)]\\n\\ndef lcm(a,b):\\n    return a*b//math.gcd(a,b)\\n\\nprint(reduce(lcm, t))\", \"from math import gcd\\nfrom functools import reduce\\n\\n\\ndef lcm(a, b):\\n    return (a * b) // gcd(a, b)\\n\\n\\ndef main():\\n    n = int(input())\\n    t = [int(input()) for _ in range(n)]\\n    print((reduce(lcm, t)))\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"# -*- coding: utf-8 -*-\\n\\\"\\\"\\\"\\nCreated on Sat Sep 26 22:43:32 2020\\n\\n@author: liang\\n\\\"\\\"\\\"\\n\\nfrom math import gcd\\n\\nN = int(input())\\nT = [int(input()) for i in range(N)]\\nans = 1\\n\\nfor i in range(N):\\n    ans = ans*T[i]//gcd(ans,T[i])\\n\\nprint(ans)\", \"N = int(input())\\nT = [int(input()) for _ in range(N)]\\n\\ndef gcd(a, b):\\n    if a % b == 0:\\n        return b\\n    else:\\n        return gcd(b, a%b)\\n\\n\\ndef lcm(a, b):\\n    return a*b // gcd(a, b)\\n\\n\\nans = 1\\nfor t in T:\\n    ans = lcm(ans, t)\\nprint(ans)\\n\", \"import math\\nN = int(input())\\nans = 1\\nfor i in range(N):\\n  a = int(input())\\n  ans = ans*a//math.gcd(ans,a)\\nprint(ans)\", \"import math\\nimport functools\\ndef lcm(x,y):\\n    return (x*y)//math.gcd(x,y)\\nn = int(input())\\nt = [int(input()) for i in range(n)]\\na = functools.reduce(math.gcd,t)\\nprint(functools.reduce(lcm,t))\", \"def gcd(a,b):\\n    while b:\\n        a,b=b,a%b\\n    return a\\n\\ndef lcm(a,b):\\n    return a*b//gcd(a,b)\\n      \\nN=int(input())\\nT=[]\\ntotal=1\\nfor i in range(N):\\n    a=int(input())\\n    T.append(a)\\nT_set=sorted(list(set(T)))\\nM=len(T_set)\\n\\nans=T_set[0]\\nif M==1:\\n    ans=T_set[0]\\nelse:\\n    for i in range(1,M):\\n        ans=lcm(ans,T_set[i])\\n\\nprint(ans)\", \"def main():\\n    def gcd(a,b):\\n        while b!=0:\\n            a, b = b, a%b\\n        return a\\n\\n    def lcm(a,b):\\n        return a*b // gcd(a,b)\\n\\n    N = int(input())\\n    T = [int(input()) for _ in range(N)]\\n    ans = 1\\n    for t in T:\\n        ans = lcm(ans, t)\\n    print(ans)\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"import math\\nn=int(input())\\nt=[int(input()) for i in range(n)]\\nres=t[0]\\nfor i in range(1,n):\\n  res=res*t[i]//math.gcd(res,t[i])\\nprint(res)\", \"from math import gcd\\nfrom functools import reduce\\n\\ndef lcm(x, y):\\n  return (x*y) // gcd(x, y)\\n\\nN = int(input())\\nTS = [int(input()) for _ in range(N)]\\n\\nprint((reduce(lcm, TS)))\\n\", \"import math\\nn=int(input())\\nt=[int(input()) for i in range(n)]\\nres=t[0]\\nfor i in range(1,n):\\n  res=res*t[i]//math.gcd(res,t[i])\\nprint(res)\", \"import math\\ndef lcm(x,y):\\n    return (x*y)//(math.gcd(x,y))\\n\\nn=int(input())\\nt=[int(input()) for _ in range(n)]\\nans=1\\nfor i in t:\\n    ans=lcm(i,ans)\\nprint(ans)\", \"from math import gcd\\nN = int(input())\\ndef lcm(a,b):\\n    return a*b//gcd(a,b)\\n\\nT1 = int(input())\\nans = T1\\nfor i in range(N-1):\\n    T2 = int(input())\\n    ans = lcm(ans,T2)\\n    T1 = T2\\n\\nprint(ans)\", \"import math\\nfrom functools import reduce\\n\\n\\nn = int(input())\\ntt = [int(input()) for i in range(n)]\\n\\nx = 1\\n\\ndef lcm_base(x,y):\\n  return (x*y) // math.gcd(x,y)\\ndef lcm(*numbers):\\n  return reduce(lcm_base, numbers, 1)\\n\\nprint(lcm(*tt))\", \"N = int(input())\\nti = [int(input()) for i in range(N)]\\n\\n\\ndef euc_alg(val1, val2):\\n\\n    if val1 == val2:\\n        return val1\\n\\n    mod = min(val1, val2)\\n    divided = max(val1, val2)\\n    while 1:\\n        tmp_mod = divided % mod\\n\\n        if tmp_mod == 0:\\n            break\\n        divided = mod\\n        mod = tmp_mod\\n\\n    ret = val1 * val2 // mod\\n\\n    return ret\\n\\nmaxti = max(ti)\\n# least_common_mult = max([euc_alg(maxti, t) for t in ti])\\n\\nans = ti[0]\\nfor t in ti:\\n    ans = euc_alg(ans, t)\\n\\nprint(ans)\\n\", \"import math\\n        \\nN = int(input())\\nT = []\\nfor i in range(N):\\n    T.append(int(input()))\\nans = T[0]\\n\\nfor i in range(1, N):\\n    ans = ans * T[i] // math.gcd(ans, T[i])\\n\\nprint(ans)\\n    \\n\\n\", \"def gcd(a,b):\\n    while b!=0:\\n        a, b = b, a%b\\n    return a\\n\\ndef lcm(a,b):\\n    return a*b // gcd(a,b)\\n\\nN = int(input())\\nT = [int(input()) for _ in range(N)]\\nans = 1\\nfor t in T:\\n    ans = lcm(ans, t)\\nprint(ans)\\n\", \"n=int(input())\\nimport math\\nans=1\\nfor i in range(n):\\n    t=int(input())\\n    ans=(ans//math.gcd(ans,t))*t\\n    \\nprint(ans)\\n\", \"import math\\n\\nN = int(input())\\n\\ndef lcm(x, y):\\n  return (x*y) // math.gcd(x, y)\\n\\nans = 1\\n\\nfor _ in range(N):\\n  T = int(input())\\n  ans = lcm(ans, T)\\n\\nprint(ans)\", \"import math\\n\\n\\ndef lcm(x, y):\\n    return x * y // math.gcd(x, y)\\n\\n\\ndef main():\\n    n = int(input())\\n    t_lst = [int(input()) for _ in range(n)]\\n    t_lst.sort()\\n    answer = t_lst[0]\\n    for i in range(1, n):\\n        t = t_lst[i]\\n        answer = lcm(answer, t)\\n\\n    print(answer)\\n\\n\\ndef __starting_point():\\n    main()\\n__starting_point()\", \"N=int(input())\\nT=list(int(input()) for _ in range(N))\\n\\ndef gcd(a, b):\\n\\twhile b:\\n\\t\\ta, b = b, a%b\\n\\treturn a\\n\\nans=T[0]\\nfor i in range(1, N):\\n\\tans=ans*T[i]//gcd(ans, T[i])\\nprint(ans)\", \"import math\\nfrom math import gcd,pi,sqrt\\nINF = float(\\\"inf\\\")\\n\\nimport sys\\nsys.setrecursionlimit(10**6)\\nimport itertools\\nfrom collections import Counter,deque\\ndef i_input(): return int(input())\\ndef i_map(): return list(map(int, input().split()))\\ndef i_list(): return list(i_map())\\ndef i_row(N): return [i_input() for _ in range(N)]\\ndef i_row_list(N): return [i_list() for _ in range(N)]\\ndef s_input(): return input()\\ndef s_map(): return input().split()\\ndef s_list(): return list(s_map())\\ndef s_row(N): return [s_input for _ in range(N)]\\ndef s_row_str(N): return [s_list() for _ in range(N)]\\ndef s_row_list(N): return [list(s_input()) for _ in range(N)]\\n\\n\\ndef main():\\n    n = i_input()\\n    t = i_input()\\n    for i in range(n-1):\\n        k = i_input()\\n        t = t*k//gcd(t,k)\\n    print(t)\\n\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"def gcd(a, b):\\n    if b == 0:\\n        return a\\n    return gcd(b, a % b)\\n\\ndef lcm(a, b):\\n    g = gcd(a, b)\\n    return a // g * b\\n\\nN = int(input())\\nT = [int(input()) for _ in range(N)]\\n\\nans = 1\\n\\nfor i in range(N):\\n    ans = lcm(ans, T[i])\\n\\nprint(ans)\", \"import math\\nfrom functools import reduce\\n\\ndef lcm_base(x, y):\\n    return (x * y) // math.gcd(x, y)\\n\\ndef lcm_list(list):\\n    return reduce(lcm_base, list, 1)\\n\\nN = int(input())\\nT = [int(input()) for i in range(N)]\\n\\nprint((lcm_list(T)))\\n\", \"from math import *\\n\\ndef lcm(x,y):\\n  return (x*y)//gcd(x,y)\\n\\nN=int(input())\\nT=[int(input()) for _ in range(N)]\\nans=T[0]\\nfor i in range(1,N):\\n  ans=lcm(ans,T[i])\\nprint(ans)\\n\", \"from math import gcd\\n\\nn = int(input())\\nans = 1\\nfor _ in range(n):\\n    t = int(input())\\n    ans = ans * t // gcd(ans, t)\\nprint(ans)\", \"import math\\nfrom functools import reduce\\n\\ndef lcm_base(x, y):\\n    return (x * y) // math.gcd(x, y)\\n\\ndef lcm_list(numbers):\\n    return reduce(lcm_base, numbers, 1)\\n\\nn = int(input())\\n\\nl = []\\n\\nfor i in range(n):\\n    t = int(input())\\n    l.append(t)\\n\\nprint((lcm_list(l)))\\n\", \"import math\\nfrom functools import reduce\\nN = int(input())\\nT = [int(input()) for _ in range(N)]\\n\\ndef lcm_base(x, y):\\n    return (x * y) // math.gcd(x, y)\\n\\ndef lcm_list(numbers):\\n    return reduce(lcm_base, numbers, 1)\\n\\nprint(lcm_list(T))\", \"n = int(input())\\nt = [int(input()) for _ in range(n)]\\n\\nimport math\\n\\ndef lcm(x,y):\\n    return (x * y) // math.gcd(x, y)\\n\\nans = 1\\nfor i in range(n):\\n    ans = lcm(ans,t[i])\\nprint(ans)\", \"#\\n# abc070 c\\n#\\nimport sys\\nfrom io import StringIO\\nimport unittest\\nimport math\\nfrom functools import reduce\\n\\n\\nclass TestClass(unittest.TestCase):\\n    def assertIO(self, input, output):\\n        stdout, stdin = sys.stdout, sys.stdin\\n        sys.stdout, sys.stdin = StringIO(), StringIO(input)\\n        resolve()\\n        sys.stdout.seek(0)\\n        out = sys.stdout.read()[:-1]\\n        sys.stdout, sys.stdin = stdout, stdin\\n        self.assertEqual(out, output)\\n\\n    def test_\\u5165\\u529b\\u4f8b_1(self):\\n        input = \\\"\\\"\\\"2\\n2\\n3\\\"\\\"\\\"\\n        output = \\\"\\\"\\\"6\\\"\\\"\\\"\\n        self.assertIO(input, output)\\n\\n    def test_\\u5165\\u529b\\u4f8b_2(self):\\n        input = \\\"\\\"\\\"5\\n2\\n5\\n10\\n1000000000000000000\\n1000000000000000000\\\"\\\"\\\"\\n        output = \\\"\\\"\\\"1000000000000000000\\\"\\\"\\\"\\n        self.assertIO(input, output)\\n\\n\\ndef resolve():\\n    N = int(input())\\n    T = [int(input()) for _ in range(N)]\\n\\n    print((lcmlist(T)))\\n\\n\\ndef lcm(x, y):\\n    return (x * y) // math.gcd(x, y)\\n\\n\\ndef lcmlist(l):\\n    return reduce(lcm, l)\\n\\n\\ndef __starting_point():\\n    # unittest.main()\\n    resolve()\\n\\n__starting_point()\", \"n = int(input())\\nT = [int(input()) for _ in range(n)]\\n\\ndef gcd(a, b):\\n  if a > b:\\n    a, b = b, a\\n  while a % b != 0:\\n    a, b = b, a % b\\n  return b\\n\\ndef lcm(a, b):\\n  return a * b // gcd(a, b)\\n\\nl = T.pop()\\nfor t in T:\\n  l = lcm(l, t)\\nprint(l)\", \"from math import gcd\\nn = int(input())\\nans = int(input())\\nfor _ in range(n - 1):\\n    t = int(input())\\n    ans = (ans * t) // gcd(ans, t)\\n\\nprint(ans)\\n\", \"N=int(input())\\nT=[int(input()) for _ in range(N)]\\n\\ndef gcd(a,b):\\n    l=max(a,b)\\n    s=min(a,b)\\n    while True:\\n        x=s\\n        y=l%s\\n        if y==0:\\n            break\\n        else:\\n            l=x\\n            s=y\\n    return s\\nif N!=1:\\n  ans=T[0]*T[1]//gcd(T[0],T[1])\\n  for n in range(1,N):\\n    ans=ans*T[n]//gcd(ans,T[n])\\nelse:\\n  ans=T[0]\\n\\nprint(ans)            \\n\", \"def gcd(x, y):\\n    if(y == 0):\\n        return x\\n        \\n    return gcd(y, x%y)\\n    \\ndef lcm(x, y):\\n    return (x*y)//(gcd(x, y))\\n\\n\\nn = int(input())\\nx = []\\nfor i in range(n):\\n    x.append(int(input()))\\n        \\nl = x[0]\\nfor i in range(1, n):\\n    l = lcm(l, x[i])\\n        \\nprint(l)\", \"from math import gcd\\nfrom functools import reduce\\n\\n\\ndef lcm(a, b):\\n    return (a * b) // gcd(a, b)\\n\\n\\ndef main():\\n    n = int(input())\\n    t = {int(input()) for _ in range(n)}\\n    print((reduce(lcm, t)))\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"import math\\n\\nN = int(input())\\nT = [int(input())for _ in range(N)]\\n\\nans = T[0]\\n\\nfor i in range(1,N):\\n    ans = (ans*T[i])//math.gcd(ans,T[i])\\n    #ans %= 10**18+7\\nprint(ans)\\n    \\n\", \"from math import gcd\\n\\nn = int(input())\\nT = [int(input()) for _ in range(n)]\\n\\nans = 1\\nfor i in range(n):\\n    ans = ans * T[i] // gcd(ans, T[i])\\nprint(ans)\", \"import math\\ndef lcm(a, b): return a * b // math.gcd(a, b)\\n\\nn = int(input())\\n\\nif n == 1:\\n    print(input())\\n\\nelif n == 2:\\n    a = int(input())\\n    b = int(input())\\n    print(lcm(a,b))\\nelse:\\n    a = int(input())\\n    b = int(input())\\n    ans = lcm(a,b)\\n    for _ in range(n-2):\\n        i = int(input())\\n        ans = lcm(ans, i)\\n    print(ans)\", \"N = int(input())\\nT = []\\n\\nfor i in range(N):\\n  T.append(int(input()))\\n\\nimport math\\n\\ndef lcm(m,n):\\n  return (m*n)//math.gcd(m,n)\\n\\ndef lcm_list(nums):\\n  lcm_num = nums[0]\\n  for i in range(1,len(nums)):\\n    lcm_num = lcm(lcm_num,nums[i])\\n  return lcm_num\\n\\nprint(lcm_list(T))\", \"import math\\n\\nn = int(input())\\na = []  \\nfor i in range(n):\\n  a.append(int(input()))\\nif n == 1:\\n  print((a[0]))\\nelse:\\n  lcm = (a[0] * a[1]) // math.gcd(a[0], a[1])\\n  for i in range(2, n):\\n    lcm = (lcm * a[i]) // math.gcd(lcm, a[i])\\n  print(lcm)\\n\", \"import math\\n\\nn = int(input())\\nans = 1\\nfor _ in range(n):\\n    t1 = int(input())\\n    ans = ans//math.gcd(ans, t1)*t1\\n\\nprint(ans)\", \"n= int(input())\\na=int(input())\\n\\nimport math\\nif n==1:\\n\\tprint(a)\\n\\treturn\\n\\nb=int(input())\\nc=(a*b)//math.gcd(a,b)\\nfor i in range(n-2):\\n\\tb=int(input())\\n\\tc=(c*b)//math.gcd(c,b)\\n\\nprint(c)\", \"import math\\nN = int(input())\\nans = 0\\nfor i in range(N):\\n  if i == 0:\\n    ans = int(input())\\n  else:\\n    a = int(input())\\n    ans = (a * ans) // math.gcd(ans,a)\\nprint(ans)\\n\", \"def gcd(a,b):\\n    while b!=0:\\n        tmp = b\\n        b = a%b\\n        a = tmp\\n    return a\\n\\ndef lcm(a,b):\\n    return a*b // gcd(a,b)\\n\\nN = int(input())\\nT = [int(input()) for _ in range(N)]\\nans = 1\\nfor t in T:\\n    ans = lcm(ans, t)\\nprint(ans)\\n\", \"import math\\nN = int(input())\\nlsT = []\\nfor i in range(N):\\n    lsT.append(int(input()))\\na = lsT[0]\\nfor b in range(1,N):\\n    a = a*lsT[b] // math.gcd(a,lsT[b])\\nprint(a)\", \"import math\\n\\nn = int(input())\\ntL = [int(input()) for _ in range(n)]\\n\\n\\ndef lcm(x, y):\\n    return (x * y) // math.gcd(x, y)\\n\\n\\nans = tL[0]\\nfor t in tL[1:]:\\n    ans = lcm(t, ans)\\n\\nprint(ans)\", \"n=int(input())\\nA=[]\\nfor i in range(n):\\n    A.append(int(input()))\\n\\nimport numpy as np\\nprint(np.lcm.reduce(A))\", \"import math\\nfrom functools import reduce\\n\\ndef lcm_base(x, y):\\n    return (x * y) // math.gcd(x, y)\\n\\ndef lcm(*numbers):\\n    return reduce(lcm_base, numbers, 1)\\n\\ndef lcm_list(numbers):\\n    return reduce(lcm_base, numbers, 1)\\nN = int(input())\\nAA = [int(input()) for i in range(N)]\\nprint(lcm(*AA))\", \"n = int(input())\\na = []\\nfor i in range(n):\\n  a.append(int(input()))\\n\\ndef gcd(x,y):\\n  while y != 0:\\n    x, y = y, x % y\\n  return x\\n\\nres = a[0]\\nfor i in range(n):\\n  res = (res*a[i]) // gcd(res,a[i])\\n\\nprint(res)\", \"from math import gcd\\nn = int(input())\\nT = []\\nfor i in range(n):\\n    T.append(int(input()))\\n\\ntmp = T[0]\\nfor i in range(1,n):\\n    g = gcd(tmp,T[i])\\n    tmp = T[i]*tmp//g\\n    \\nprint(tmp)\", \"N = int(input())\\nT = [int(input()) for _ in range(N)]\\n\\ndef gcd(a,b):\\n    if a % b == 0:\\n        return b\\n    return gcd(b, a%b)\\n\\nres = T[0]\\nfor t in T:\\n    gcd_ = gcd(res, t)\\n    res = res*t//gcd_\\nprint(res)\\n\", \"#\\u6700\\u5927\\u516c\\u7d04\\u6570\\ndef gcd(a,b):\\n  if b==0:\\n    return a\\n  else:\\n    return gcd(b,a%b)\\n\\n#\\u6700\\u5c0f\\u516c\\u500d\\u6570\\ndef lcm(a,b):\\n  return a*b//gcd(a,b)\\n\\n#\\u5168\\u3066\\u306e\\u6700\\u5c0f\\u516c\\u500d\\u6570\\u3092\\u6c42\\u3081\\u308c\\u3070\\u3044\\u3044\\nn=int(input())\\nans=1\\nfor i in range(n):\\n  ans=lcm(ans,int(input()))\\nprint(ans)\\n\\n  \\n\\n\\n\\n\", \"n = int(input())\\nfrom fractions import gcd\\ng = int(input())\\nfor i in range(n-1):\\n  h = int(input())\\n  g = g * h // gcd(g,h)\\nprint(g)\", \"from math import gcd\\nn = int(input())\\nt = [int(input()) for i in range(n)]\\nans = 1\\nfor i in range(n):\\n    ans = ans*t[i]//gcd(ans, t[i])\\nprint(ans)\", \"import math\\n\\nn = int(input())\\nans = 1\\nfor _ in range(n):\\n    t = int(input())\\n    ans = ans * t // math.gcd(ans, t)\\nprint(ans)\", \"import math\\nfrom functools import reduce\\n\\ndef lcm_base(x, y):\\n    return (x * y) // math.gcd(x, y)\\n\\ndef lcm_list(numbers):\\n    return reduce(lcm_base, numbers, 1)\\n\\nN = int(input())\\nN_List = []\\nfor i in range(N):\\n    N_List.append(int(input()))\\n\\nprint((lcm_list(N_List)))\\n\", \"import math\\n\\nn = int(input())\\ntl = [int(input()) for _ in range(n)]\\n\\nif n == 1:\\n    print((tl[0]))\\nelse:\\n    g = tl[0] // math.gcd(tl[0], tl[1]) * tl[1]\\n    for i in range(1, n):\\n        g = g // math.gcd(g, tl[i]) * tl[i]\\n    print(g)\\n\", \"import math\\n\\nn = int(input())\\nt = [int(input()) for _ in range(n)]\\n\\nans = 1\\nfor i in t:\\n    ans = ans*i // math.gcd(ans, i)\\nprint(ans)\", \"import math\\nn = int(input())\\nT = [int(input()) for _ in range(n)]\\n\\n#\\u6700\\u5c0f\\u516c\\u500d\\u6570\\ndef lcm(x, y):\\n    return (x*y)//math.gcd(x, y)\\n\\nans = T[0]\\nfor t in T[1:]:\\n    ans = lcm(ans, t)\\nprint(ans)\", \"n=int(input())\\n\\nimport math\\nfrom functools import reduce\\ndef lcm_base(x, y):# \\u6700\\u5c0f\\u516c\\u500d\\u6570\\n    return (x * y) // math.gcd(x, y)\\ndef lcm(numbers):\\n    return reduce(lcm_base, numbers, 1)\\n\\nt=[]\\nfor i in range(n):\\n    t.append(int(input()))\\n\\nprint(lcm(t))\", \"#70\\nfrom math import gcd\\nn=int(input())\\nt=[int(input()) for i in range(n)]\\n\\nans=1\\nfor i in range(n):\\n    ans*=t[i]//gcd(ans,t[i])\\nprint(ans)\\n\", \"import math\\n\\na = 1\\nn = int(input())\\nfor i in range(n):\\n  t = int(input())\\n  a = (a * t) // math.gcd(a, t)\\nprint(a)\", \"#from statistics import median\\n#import collections\\n#aa = collections.Counter(a) # list to list || .most_common(2)\\u3067\\u6700\\u5927\\u306e2\\u500b\\u3068\\u308a\\u3060\\u305b\\u308b\\u304a a[0][0]\\nfrom math import gcd\\nfrom itertools import combinations,permutations,accumulate, product # (string,3) 3\\u56de\\n#from collections import deque\\nfrom collections import deque,defaultdict,Counter\\nimport decimal\\nimport re\\nimport math\\nimport bisect\\nimport heapq\\n#\\n#\\n#\\n# python\\u3067\\u7121\\u7406\\u306a\\u3068\\u304d\\u306f\\u3001pypy\\u3067\\u3084\\u308b\\u3068\\u6b63\\u89e3\\u3059\\u308b\\u304b\\u3082\\uff01\\uff01\\n#\\n#\\n# my_round_int = lambda x:np.round((x*2 + 1)//2)\\n# \\u56db\\u6368\\u4e94\\u5165g\\n#\\n# \\u30a4\\u30f3\\u30c7\\u30c3\\u30af\\u30b9\\u7cfb\\n# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);\\n# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);\\n#\\n#\\nimport sys\\nsys.setrecursionlimit(10000000)\\n# mod = 10**9 + 7\\n#mod = 9982443453\\nmod = 998244353\\nINF = float('inf')\\nfrom sys import stdin\\nreadline = stdin.readline\\ndef readInts():\\n  return list(map(int,readline().split()))\\ndef readTuples():\\n    return tuple(map(int,readline().split()))\\ndef I():\\n    return int(readline())\\nn = I()\\ng = 0\\nlcm = 1\\nfor i in range(n):\\n    A = I()\\n    g = math.gcd(A,g)\\n    if i == 0:\\n        lcm = A\\n    else:\\n        lcm = (lcm*A)//g\\n    g = lcm\\nprint(lcm)\\n\", \"#!/usr/bin/env python\\n# -*- coding: utf-8 -*-\\n#\\n# FileName: \\tC\\n# CreatedDate:  2020-09-04 15:32:03 +0900\\n# LastModified: 2020-09-04 15:43:28 +0900\\n#\\n\\n\\nimport os\\nimport sys\\n# import numpy as np\\n# import pandas as pd\\n\\n\\ndef gcd(a, b):\\n    while a % b != 0:\\n        r = a % b\\n        a = b\\n        b = r\\n    return b\\n\\n\\ndef main():\\n    n = int(input())\\n    ans = int(input())\\n    for _ in range(n-1):\\n        t = int(input())\\n        ans = ans*t//gcd(max(ans, t), min(ans, t))\\n    print(ans)\\n\\n\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"N = int(input())\\nT = [int(input()) for i in range(N)]\\nimport math\\na = T[0]\\nfor i in range(1,N):\\n    a = (a*T[i]) // math.gcd(a,T[i])\\nprint(a)\", \"# C - Multiple Clocks\\nimport functools\\nimport math\\nN = int(input())\\nT = [int(input()) for _ in range(N)]\\n\\ndef lcm(a,b):\\n    LCM = a*b//math.gcd(a,b)\\n    return LCM\\n\\ndef all_lcm(A):\\n    ans = functools.reduce(lcm,A,1)\\n    return ans\\n\\nprint(all_lcm(T))\", \"import math\\nN = int(input())\\nT = [int(input()) for _ in range(N)]\\n\\ndef lcm(a, b):\\n    return a*b // math.gcd(a, b)\\n\\nans = T[0]\\nfor i in range(1, N):\\n    ans = lcm(ans, T[i])\\nprint(ans)\\n\", \"def gcd(m, n):\\n    if m < n:\\n        m, n = n, m\\n\\n    while True:\\n        r = m % n\\n        if r == 0:\\n            return n\\n        else:\\n            m, n = n, r\\n\\ndef lcm(m, n):\\n    return m*n // gcd(m, n)\\n\\nn = int(input())\\nl = []\\n\\nans = 1\\n\\nfor i in range(n):\\n    t = int(input())\\n    ans = lcm(ans, t)\\n\\nprint(ans)\\n\", \"import math\\nfrom functools import reduce\\n\\ndef lcm_base(x,y):\\n    return (x*y)//math.gcd(x,y)\\n\\ndef lcm_list(numbers):\\n    return reduce(lcm_base,numbers,1)\\n\\nn=int(input())\\nnums=[int(input()) for i in range(n)]\\n\\nprint((lcm_list(nums)))\\n\", \"def lcm(a):\\n    import math\\n    x = a[0]\\n    for i in range(1, len(a)):\\n        x = (x * a[i]) // math.gcd(x, a[i])\\n    return x\\n\\n\\ndef resolve():\\n    N = int(input())\\n    T = [int(input()) for _ in range(N)]\\n    print((lcm(T)))\\n\\n\\nresolve()\\n\", \"from math import gcd\\nn = int(input())\\na = 1\\nfor _ in range(n):\\n  x = int(input())\\n  a = a // gcd(a, x) * x\\nprint(a)\", \"from math import gcd\\n\\nn = int(input())\\ng = int(input())\\n\\nfor i in range(n-1):\\n    t = int(input())\\n    g = g * t // gcd(g, t)\\n\\nprint(g)\\n\"]", "task": "apps", "difficulty": "introductory", "split": "test", "transformation_type": "plain_summary"}