{"qid": 4114, "orig_input": "In the Ancient Kingdom of Snuke, there was a pyramid to strengthen the authority of Takahashi, the president of AtCoder Inc.\n\nThe pyramid had center coordinates (C_X, C_Y) and height H. The altitude of coordinates (X, Y) is max(H - |X - C_X| - |Y - C_Y|, 0).  \nAoki, an explorer, conducted a survey to identify the center coordinates and height of this pyramid. As a result, he obtained the following information:  \n - C_X, C_Y was integers between 0 and 100 (inclusive), and H was an integer not less than 1.  \n - Additionally, he obtained N pieces of information. The i-th of them is: \"the altitude of point (x_i, y_i) is h_i.\"  \nThis was enough to identify the center coordinates and the height of the pyramid. Find these values with the clues above.  \n\n-----Constraints-----\n - N is an integer between 1 and 100 (inclusive).\n - x_i and y_i are integers between 0 and 100 (inclusive).\n - h_i is an integer between 0 and 10^9 (inclusive).\n - The N coordinates (x_1, y_1), (x_2, y_2), (x_3, y_3), ..., (x_N, y_N) are all different.\n - The center coordinates and the height of the pyramid can be uniquely identified.\n\n-----Input-----\nInput is given from Standard Input in the following format:  \nN\nx_1 y_1 h_1\nx_2 y_2 h_2\nx_3 y_3 h_3\n:\nx_N y_N h_N\n\n-----Output-----\nPrint values C_X, C_Y and H representing the center coordinates and the height of the pyramid in one line, with spaces in between.  \n\n-----Sample Input-----\n4\n2 3 5\n2 1 5\n1 2 5\n3 2 5\n\n-----Sample Output-----\n2 2 6\n\nIn this case, the center coordinates and the height can be identified as (2, 2) and 6.", "input": "Determine the center coordinates and height of a pyramid given altitude measurements at specific points.", "test_cases": {"inputs": ["4\n2 3 5\n2 1 5\n1 2 5\n3 2 5\n", "2\n0 0 100\n1 1 98\n", "3\n99 1 191\n100 1 192\n99 0 192\n", "2\n0 0 180291302\n20 20 180291262\n", "4\n47 59 314159265\n59 47 314159265\n59 59 314159265\n47 47 314159265\n", "3\n67 85 414106187\n52 100 414106187\n82 100 414106187\n", "4\n59 3 0\n64 94 56\n5 62 11\n3 93 14\n", "4\n72 14 11\n61 77 41\n20 76 75\n11 74 68\n", "5\n84 2 0\n60 88 9\n80 30 13\n57 41 29\n79 58 32\n", "4\n0 0 1000000000\n0 100 1000000000\n100 0 1000000000\n100 100 1000000000\n", "5\n50 50 999999994\n40 40 999999994\n0 81 999999993\n20 79 999999995\n30 10 999999974\n", "5\n32 67 0\n32 68 1\n33 68 0\n31 68 0\n32 69 0\n", "35\n12 29 5\n11 24 1\n12 23 1\n9 27 2\n13 29 4\n16 27 1\n11 29 4\n82 54 0\n78 39 0\n24 30 0\n27 22 0\n86 7 0\n65 94 0\n82 17 0\n27 81 0\n21 36 0\n33 97 0\n26 20 0\n49 83 0\n57 30 0\n6 76 0\n4 23 0\n51 11 0\n32 21 0\n35 52 0\n68 79 0\n83 51 0\n38 31 0\n15 25 0\n90 16 0\n54 83 0\n40 24 0\n89 30 0\n12 17 0\n36 87 0\n", "69\n74 53 7\n74 49 3\n71 58 11\n63 54 1\n72 52 8\n64 57 5\n79 60 3\n46 30 0\n27 36 0\n92 69 0\n36 58 0\n40 53 0\n0 19 0\n37 11 0\n44 74 0\n11 8 0\n11 4 0\n29 73 0\n56 94 0\n14 60 0\n71 48 3\n37 35 0\n59 9 0\n55 68 0\n84 74 0\n95 34 0\n20 13 0\n64 69 0\n35 67 0\n40 15 0\n28 84 0\n17 58 0\n77 52 3\n21 8 0\n9 55 0\n58 5 0\n0 35 0\n96 60 0\n93 100 0\n55 76 0\n58 54 0\n37 41 0\n49 34 0\n92 81 0\n8 17 0\n74 39 0\n71 36 0\n66 36 0\n14 17 0\n66 26 0\n14 72 0\n0 59 0\n88 41 0\n25 51 0\n48 51 0\n53 76 0\n16 83 0\n15 98 0\n75 42 0\n87 94 0\n81 49 0\n72 67 3\n58 75 0\n64 5 0\n64 10 0\n83 77 0\n4 16 0\n41 59 0\n34 15 0\n", "91\n33 48 1\n32 50 2\n33 50 3\n33 52 1\n34 49 1\n33 49 2\n32 51 1\n27 15 0\n40 37 0\n12 73 0\n80 90 0\n86 50 0\n34 20 0\n99 15 0\n16 93 0\n19 71 0\n50 92 0\n91 0 0\n75 82 0\n75 35 0\n84 61 0\n84 21 0\n79 78 0\n31 58 0\n88 36 0\n68 24 0\n71 46 0\n72 72 0\n31 52 0\n71 91 0\n22 45 0\n28 51 0\n55 56 0\n95 68 0\n40 79 0\n64 31 0\n88 56 0\n43 12 0\n99 9 0\n25 14 0\n35 89 0\n27 87 0\n52 76 0\n44 50 0\n22 42 0\n21 82 0\n49 15 0\n56 1 0\n60 64 0\n94 48 0\n66 64 0\n73 83 0\n93 26 0\n86 99 0\n25 28 0\n4 16 0\n0 35 0\n97 32 0\n47 50 0\n50 50 0\n20 61 0\n70 52 0\n2 49 0\n37 90 0\n68 15 0\n27 68 0\n12 79 0\n95 5 0\n15 72 0\n52 43 0\n38 22 0\n87 49 0\n56 25 0\n50 66 0\n31 72 0\n47 5 0\n59 94 0\n37 86 0\n44 51 0\n47 81 0\n73 44 0\n31 40 0\n88 41 0\n63 44 0\n0 64 0\n53 59 0\n4 56 0\n66 92 0\n85 36 0\n83 15 0\n45 50 0\n", "92\n21 46 27\n38 80 74\n28 66 54\n77 79 34\n56 62 38\n3 84 47\n21 47 28\n59 4 0\n81 46 0\n10 81 51\n34 54 48\n10 59 29\n46 16 2\n16 56 32\n32 6 0\n94 30 0\n39 44 37\n7 54 21\n100 51 0\n49 24 7\n51 78 59\n90 51 0\n82 46 0\n99 74 7\n20 26 6\n73 88 47\n81 39 0\n94 27 0\n20 37 17\n5 87 52\n28 8 0\n20 55 35\n21 89 70\n82 78 28\n3 75 38\n60 73 45\n29 52 41\n42 77 67\n50 3 0\n53 19 0\n66 98 50\n92 94 28\n17 0 0\n41 78 69\n70 10 0\n63 22 0\n17 80 57\n77 86 41\n28 4 0\n10 78 48\n72 33 0\n60 7 0\n43 56 45\n16 11 0\n6 96 52\n67 79 44\n33 4 0\n16 41 17\n73 38 0\n79 39 0\n94 5 0\n92 37 0\n98 84 18\n65 50 17\n64 6 0\n59 80 53\n25 25 10\n96 72 8\n71 39 0\n76 35 0\n47 35 20\n83 40 0\n1 38 0\n12 14 0\n74 17 0\n49 91 74\n28 59 47\n92 86 26\n29 90 79\n35 10 5\n37 78 73\n13 23 0\n69 58 21\n50 81 63\n11 33 4\n0 40 0\n98 10 0\n85 53 0\n36 97 81\n31 42 33\n75 38 0\n9 35 4\n", "75\n38 67 32\n47 82 26\n34 67 28\n65 18 108\n47 40 68\n97 88 32\n19 54 26\n19 76 4\n24 48 37\n63 87 37\n9 87 0\n98 72 47\n64 35 90\n95 36 86\n82 71 64\n18 31 48\n55 64 52\n4 45 20\n64 89 36\n11 50 22\n34 10 77\n90 93 34\n30 41 50\n11 71 1\n1 18 44\n82 59 76\n91 28 98\n9 32 38\n53 77 37\n28 30 59\n41 10 84\n9 61 9\n27 49 39\n55 81 35\n8 16 53\n9 34 36\n31 56 36\n70 22 109\n44 26 79\n47 47 61\n54 43 72\n2 62 1\n18 83 0\n2 100 0\n57 30 88\n55 60 56\n81 94 42\n53 41 73\n26 78 9\n35 41 55\n76 7 116\n77 0 110\n67 60 68\n25 5 63\n23 36 48\n62 13 108\n9 68 2\n13 77 0\n21 83 0\n0 23 38\n72 83 50\n56 24 93\n56 71 46\n54 37 78\n44 91 14\n5 94 0\n74 75 60\n80 21 116\n85 48 84\n46 95 12\n72 20 113\n35 53 43\n0 66 0\n45 85 21\n100 86 31\n", "100\n86 5 64\n100 55 128\n71 49 93\n68 52 93\n65 5 43\n33 40 46\n50 56 79\n60 24 57\n98 44 115\n35 40 48\n7 0 0\n64 45 82\n87 18 78\n22 38 33\n83 8 64\n61 85 119\n49 87 109\n5 88 66\n23 21 17\n52 28 53\n2 35 10\n88 28 89\n88 77 138\n91 29 93\n6 99 78\n28 100 101\n15 26 14\n31 68 72\n93 45 111\n96 88 157\n75 56 104\n86 34 93\n70 85 128\n78 37 88\n43 72 88\n22 52 47\n3 18 0\n12 31 16\n82 62 117\n89 33 95\n37 38 48\n90 66 129\n14 6 0\n5 78 56\n0 52 25\n95 30 98\n25 3 1\n10 38 21\n11 66 50\n89 52 114\n73 96 142\n83 29 85\n51 95 119\n89 18 80\n99 76 148\n96 30 99\n87 65 125\n11 73 57\n55 29 57\n74 44 91\n63 52 88\n44 40 57\n58 55 86\n15 43 31\n44 69 86\n19 7 0\n13 4 0\n56 8 37\n3 53 29\n9 23 5\n65 24 62\n16 16 5\n8 38 19\n75 22 70\n46 91 110\n52 82 107\n8 1 0\n47 67 87\n31 78 82\n63 54 90\n46 12 31\n0 23 0\n19 90 82\n75 5 53\n89 71 133\n12 86 71\n61 73 107\n78 93 144\n95 54 122\n36 31 40\n41 27 41\n23 30 26\n29 89 91\n77 15 65\n18 97 88\n85 79 137\n31 45 49\n68 73 114\n25 89 87\n57 66 96\n", "96\n76 9 23031\n74 66 23032\n92 25 23031\n99 48 23025\n97 4 23005\n89 6 23015\n59 35 23074\n89 53 23030\n48 30 23060\n72 11 23037\n36 51 23041\n12 17 23011\n28 60 23024\n63 19 23054\n32 27 23041\n54 62 23048\n49 75 23030\n45 17 23044\n2 66 22992\n12 73 22995\n8 12 23002\n21 74 23003\n89 73 23010\n61 13 23050\n87 47 23038\n42 100 22998\n85 70 23017\n14 34 23030\n31 28 23041\n14 60 23010\n45 15 23042\n21 3 23006\n49 53 23052\n78 54 23040\n59 41 23072\n68 23 23053\n63 21 23056\n76 39 23057\n1 80 22977\n34 87 23003\n81 93 22998\n66 44 23062\n92 56 23024\n14 85 22985\n46 43 23059\n90 17 23025\n31 1 23014\n22 59 23019\n9 84 22981\n65 41 23066\n32 90 22998\n62 70 23040\n8 73 22991\n75 60 23037\n18 30 23030\n62 20 23056\n73 6 23031\n75 44 23053\n38 94 23000\n53 83 23026\n75 91 23006\n22 95 22983\n23 18 23023\n58 92 23022\n96 73 23003\n18 40 23034\n9 36 23027\n56 60 23052\n51 6 23039\n78 48 23046\n15 3 23000\n51 66 23041\n7 70 22993\n90 33 23041\n31 46 23041\n25 72 23009\n91 50 23031\n33 24 23039\n65 59 23048\n58 20 23060\n69 25 23054\n97 25 23026\n84 12 23026\n53 62 23047\n79 73 23020\n53 55 23054\n42 61 23037\n39 71 23024\n74 19 23043\n73 53 23046\n42 39 23059\n73 54 23045\n57 51 23062\n99 28 23027\n69 4 23033\n38 9 23029\n", "78\n3 85 999881\n52 25 999952\n90 52 999983\n74 40 999989\n3 14 999892\n52 57 999958\n31 57 999937\n3 26 999904\n56 62 999957\n24 58 999929\n29 42 999946\n51 36 999962\n87 41 999991\n20 27 999922\n25 65 999923\n45 34 999954\n68 53 999978\n28 90 999901\n20 9 999904\n83 53 999989\n85 3 999955\n21 37 999933\n5 86 999882\n78 28 999981\n98 48 999979\n2 55 999910\n14 83 999894\n69 34 999978\n41 97 999907\n82 5 999960\n45 55 999953\n83 6 999960\n56 73 999946\n21 22 999918\n93 78 999954\n62 92 999933\n48 42 999965\n81 4 999960\n5 99 999869\n11 21 999907\n77 95 999945\n11 18 999904\n23 38 999936\n39 30 999944\n43 91 999915\n63 29 999967\n57 43 999975\n21 94 999890\n65 30 999970\n95 17 999959\n62 98 999927\n82 0 999955\n74 18 999967\n71 29 999975\n18 67 999914\n1 21 999897\n94 97 999934\n86 84 999955\n29 84 999908\n53 72 999944\n24 40 999939\n4 6 999885\n12 50 999925\n41 78 999926\n61 32 999968\n99 59 999967\n47 25 999947\n33 62 999934\n98 38 999977\n35 59 999939\n23 85 999901\n19 37 999931\n33 44 999952\n33 57 999939\n61 14 999950\n23 43 999941\n7 14 999896\n4 62 999905\n", "100\n10 12 512917373\n6 9 512917366\n66 44 512917421\n49 18 512917412\n57 96 512917426\n65 72 512917442\n62 59 512917440\n27 77 512917437\n31 13 512917395\n38 39 512917428\n15 72 512917430\n0 69 512917418\n22 22 512917395\n9 69 512917427\n37 96 512917428\n12 23 512917386\n100 90 512917389\n4 60 512917415\n96 27 512917374\n75 93 512917411\n43 44 512917438\n83 32 512917392\n95 37 512917385\n82 81 512917416\n59 77 512917443\n95 81 512917403\n88 96 512917395\n48 17 512917412\n64 90 512917425\n62 14 512917395\n45 21 512917417\n92 27 512917378\n90 53 512917406\n46 66 512917463\n65 87 512917427\n53 100 512917426\n71 96 512917412\n37 67 512917455\n60 83 512917436\n40 40 512917431\n95 89 512917395\n33 11 512917395\n4 72 512917419\n2 55 512917408\n98 1 512917346\n80 61 512917424\n93 70 512917416\n13 12 512917376\n82 87 512917410\n73 24 512917394\n68 67 512917442\n5 32 512917388\n30 23 512917404\n50 89 512917440\n96 37 512917384\n38 72 512917453\n50 82 512917447\n65 9 512917387\n51 9 512917401\n32 45 512917428\n73 22 512917392\n45 46 512917442\n71 58 512917430\n11 53 512917415\n16 81 512917422\n9 10 512917370\n68 45 512917420\n62 60 512917441\n89 76 512917414\n81 88 512917410\n21 63 512917435\n17 81 512917423\n38 90 512917435\n78 68 512917433\n81 85 512917413\n99 31 512917375\n89 20 512917374\n1 94 512917394\n15 19 512917385\n72 67 512917438\n52 71 512917456\n46 25 512917422\n61 17 512917399\n50 63 512917456\n80 52 512917415\n38 100 512917425\n82 16 512917377\n11 0 512917362\n30 38 512917419\n17 0 512917368\n54 41 512917430\n13 30 512917394\n95 16 512917364\n61 81 512917437\n94 47 512917396\n82 52 512917413\n19 50 512917420\n86 65 512917422\n4 6 512917361\n56 29 512917416\n", "100\n87 56 912345617\n45 85 912345546\n93 13 912345662\n24 89 912345521\n79 38 912345627\n57 52 912345591\n53 27 912345612\n12 93 912345505\n83 9 912345660\n50 85 912345551\n24 56 912345554\n79 58 912345607\n30 53 912345563\n28 24 912345590\n94 69 912345605\n63 21 912345628\n91 57 912345620\n76 49 912345613\n1 84 912345503\n95 72 912345601\n7 15 912345578\n96 60 912345612\n63 41 912345608\n21 9 912345598\n52 45 912345593\n31 30 912345587\n1 31 912345556\n39 45 912345580\n90 14 912345662\n95 7 912345666\n70 32 912345624\n49 60 912345575\n99 24 912345645\n12 45 912345553\n68 38 912345616\n7 34 912345559\n43 78 912345551\n80 0 912345656\n94 23 912345651\n60 88 912345558\n50 62 912345574\n44 32 912345598\n3 6 912345583\n70 40 912345616\n18 77 912345527\n78 90 912345574\n72 97 912345561\n16 92 912345510\n31 35 912345582\n64 34 912345616\n68 40 912345614\n78 9 912345655\n5 90 912345501\n58 62 912345582\n1 39 912345548\n82 79 912345589\n95 18 912345655\n20 15 912345591\n74 84 912345576\n6 41 912345551\n5 66 912345525\n3 20 912345569\n97 74 912345597\n92 3 912345669\n3 49 912345540\n15 2 912345593\n85 10 912345661\n99 32 912345637\n79 11 912345654\n18 4 912345598\n57 93 912345550\n20 36 912345570\n88 35 912345639\n63 14 912345635\n34 6 912345614\n41 44 912345583\n52 50 912345588\n18 85 912345519\n50 67 912345569\n80 93 912345573\n39 2 912345617\n58 50 912345594\n27 48 912345565\n27 9 912345604\n32 87 912345531\n15 12 912345589\n79 8 912345657\n20 7 912345599\n23 97 912345512\n94 7 912345667\n88 46 912345628\n11 74 912345523\n47 73 912345560\n10 91 912345505\n95 100 912345573\n83 14 912345655\n9 86 912345509\n85 46 912345625\n34 12 912345608\n48 31 912345603\n", "100\n0 0 0\n0 1 0\n0 2 0\n0 3 0\n0 4 0\n0 5 0\n0 6 0\n0 7 0\n0 8 0\n0 9 0\n0 10 0\n0 11 0\n0 12 0\n0 13 0\n0 14 0\n1 0 0\n1 1 0\n1 2 0\n1 3 0\n1 4 0\n1 5 0\n1 6 0\n1 7 0\n1 8 0\n1 9 0\n1 10 0\n1 11 0\n1 12 0\n1 13 0\n2 0 0\n2 1 0\n2 2 0\n2 3 0\n2 4 0\n2 5 0\n2 6 0\n2 7 0\n2 8 0\n2 9 0\n2 10 0\n2 11 0\n2 12 0\n3 0 0\n3 1 0\n3 2 0\n3 3 0\n3 4 0\n3 5 0\n3 6 0\n3 7 0\n3 8 0\n3 9 0\n3 10 0\n3 11 0\n4 0 0\n4 1 0\n4 2 0\n4 3 0\n4 4 0\n4 5 0\n4 6 0\n4 7 0\n4 8 0\n4 9 0\n4 10 0\n5 0 0\n5 1 0\n5 2 0\n5 3 0\n5 4 0\n5 5 0\n5 6 0\n5 7 0\n5 8 0\n5 9 0\n6 0 0\n6 1 0\n6 2 0\n6 3 0\n6 4 0\n6 5 0\n6 6 0\n6 7 0\n6 8 0\n7 0 0\n7 1 0\n7 2 0\n7 3 0\n7 4 0\n7 5 0\n7 6 0\n7 7 0\n8 0 0\n8 1 0\n8 2 0\n8 3 0\n8 4 0\n8 5 0\n99 99 184\n100 100 186\n"], "outputs": ["2 2 6\n", "0 0 100\n", "100 0 193\n", "0 0 180291302\n", "53 53 314159277\n", "67 100 414106202\n", "55 80 79\n", "24 55 100\n", "66 53 50\n", "50 50 1000000100\n", "10 50 1000000034\n", "32 68 1\n", "12 28 6\n", "72 57 13\n", "33 50 3\n", "36 91 87\n", "78 14 125\n", "100 100 173\n", "58 37 23077\n", "81 44 1000000\n", "46 68 512917465\n", "91 5 912345672\n", "100 100 186\n"]}, "solutions": "[\"import sys\\n# import math\\n# import bisect\\n# import numpy as np\\n# from decimal import Decimal\\n# from numba import njit, i8, u1, b1 #JIT compiler\\n# from itertools import combinations, product\\n# from collections import Counter, deque, defaultdict\\n\\n# sys.setrecursionlimit(10 ** 6)\\nMOD = 10 ** 9 + 7\\nINF = 10 ** 9\\nPI = 3.14159265358979323846\\n\\ndef read_str():      return sys.stdin.readline().strip()\\ndef read_int():      return int(sys.stdin.readline().strip())\\ndef read_ints():     return map(int, sys.stdin.readline().strip().split())\\ndef read_ints2(x):   return map(lambda num: int(num) - x, sys.stdin.readline().strip().split())\\ndef read_str_list(): return list(sys.stdin.readline().strip().split())\\ndef read_int_list(): return list(map(int, sys.stdin.readline().strip().split()))\\ndef GCD(a: int, b: int) -> int: return b if a%b==0 else GCD(b, a%b)\\ndef LCM(a: int, b: int) -> int: return (a * b) // GCD(a, b)\\n\\ndef solve(info):\\n    for Cx in range(101):\\n        for Cy in range(101):\\n            height = abs(Cx - info[0][0]) + abs(Cy - info[0][1]) + info[0][2]\\n            flag = True\\n            for x,y,h in info[1:]:\\n                val = max(height - abs(Cx - x) - abs(Cy - y), 0)\\n                if h == val:\\n                    continue\\n                else:\\n                    flag = False\\n                    break\\n            if flag:\\n                return Cx, Cy, height\\n\\ndef Main():\\n    n = read_int()\\n    info = [tuple(read_ints()) for _ in range(n)]\\n    info.sort(key=lambda x: x[2], reverse=True)\\n\\n    print(*solve(info))\\n\\ndef __starting_point():\\n    Main()\\n__starting_point()\", \"N = int(input())\\nxs, ys, hs = [],[],[]\\nfor _ in range(N):\\n    x,y,h = map(int,input().split())\\n    if h != 0:\\n        xx,yy,hh = x,y,h\\n    xs.append(x)\\n    ys.append(y)\\n    hs.append(h)\\nfor cx in range(101):\\n    for cy in range(101):\\n        H = hh+abs(xx-cx)+abs(yy-cy)\\n        if all([hs[i] == max(0,H-abs(cx-xs[i])-abs(cy-ys[i])) for i in range(N)]):\\n            print(cx,cy,H)\\n            return\", \"#!/usr/bin/env python\\n# coding: utf-8\\n\\n# In[1]:\\n\\n\\nN = int(input())\\nxyh = []\\nfor _ in range(N):\\n    xyh.append(list(map(int, input().split())))\\n\\n\\n# In[4]:\\n\\n\\nxyh.sort(key=lambda x:x[2],reverse=True)\\nans = []\\nfor cx in range(101):\\n    for cy in range(101):\\n        x,y,h = xyh[0]\\n        ch = h + abs(x-cx) + abs(y-cy)\\n        if all([h == max(ch-abs(x-cx)-abs(y-cy),0) for x,y,h in xyh[1:]]):\\n            ans = [cx,cy,ch]\\n            break\\n    else:\\n        continue\\n    break\\nprint((*ans))\\n\\n\\n# In[ ]:\\n\\n\\n\\n\\n\", \"n = int(input())\\n\\nx = [0] * n\\ny = [0] * n\\nh = [0] * n\\n\\nfor i in range(n):\\n    x[i], y[i], h[i] = map(int, input().split())\\n\\nfor cx in range(101):\\n    for cy in range(101):\\n        H = -1\\n        for i in range(n):\\n            if h[i] == 0:\\n                pass\\n            else:\\n                tmp = h[i] + abs(x[i]-cx) + abs(y[i]-cy)\\n                H = tmp\\n                break\\n        flag = True\\n        for i in range(n):\\n            if h[i] != max(H-abs(x[i]-cx)-abs(y[i]-cy),0):\\n                flag = False\\n                break\\n        if flag:\\n            print(cx,cy,H)\", \"n=int(input())\\nxyh = [list(map(int,input().split())) for i in range(n)]\\nxyh.sort(key=lambda x:x[2], reverse=True)\\n\\nansh=-1\\nans=[[]]\\nflag=True\\nfor cx in range(0,101):\\n  if flag==False:\\n    break\\n    \\n  for cy in range(0,101):\\n    ansh = 0\\n    for pira in xyh:\\n      if ansh==0:\\n        ansh=pira[2]+(abs(cx-pira[0])+abs(cy-pira[1]))\\n        ans[0]=[cx,cy,ansh]\\n        \\n      elif len(ans[0])>0 and max(ansh -(abs(cx-pira[0])+abs(cy-pira[1])), 0) != pira[2]:\\n        ans[0]=[]\\n    if len(ans[0])>0:\\n      flag=False\\n      break\\nprint((*ans[0]))\\n\", \"n=int(input())\\n\\nxl=[]\\nyl=[]\\nhl=[]\\n\\n\\n\\nfor i in range(n):\\n    xx,yy,hh=list(map(int,input().split()))\\n    xl.append(xx)\\n    yl.append(yy)\\n    hl.append(hh)\\n\\nfor cx in range(0,101):\\n    for cy in range(0,101):\\n        ok=True\\n        for i in range(n):\\n            x=xl[i]\\n            y=yl[i]\\n            h=hl[i]\\n            if h!=0:\\n                high = h + abs(x - cx) + abs(y - cy)\\n                break\\n\\n        for i in range(n):\\n            x=xl[i]\\n            y=yl[i]\\n            h=hl[i]\\n            oh=max(high-abs(x-cx)-abs(y-cy),0)\\n            if h!=oh:\\n                ok=False\\n                break\\n        if ok:\\n            print(cx,cy,high)\\n            return\", \"import sys\\nfrom itertools import product\\n\\ninput = sys.stdin.readline\\n\\n\\ndef main():\\n    N = int(input())\\n    X = [0] * N\\n    Y = [0] * N\\n    H = [0] * N\\n    for i in range(N):\\n        X[i], Y[i], H[i] = list(map(int, input().split()))\\n\\n    for Cx, Cy in product(list(range(101)), repeat=2):\\n        Ch = set()\\n        Ch_upper = float(\\\"inf\\\")\\n        for x, y, h in zip(X, Y, H):\\n            a = abs(x - Cx) + abs(y - Cy)\\n            if h == 0:\\n                Ch_upper = min(Ch_upper, a)\\n            else:\\n                Ch.add(h + a)\\n        if len(Ch) != 1:\\n            continue\\n        else:\\n            Ch = Ch.pop()\\n            if Ch <= Ch_upper:\\n                ans = f\\\"{Cx} {Cy} {Ch}\\\"\\n                break\\n\\n    print(ans)\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"N=int(input())\\nxyh=[list(map(int,input().split()))for _ in range(N)]\\nhxy=[[h,x,y]for x,y,h in xyh]\\nhxy.sort()\\nfor X in range(101):\\n    for Y in range(101):\\n        h,x,y=hxy[-1]\\n        H=h+abs(X-x)+abs(Y-y)\\n        if all(h==max(H-abs(X-x)-abs(Y-y),0)for h,x,y in hxy):\\n            print(X,Y,H)\", \"N = int(input())\\nXYH_list = [list(map(int, input().split())) for i in range(N)]\\nXYH_list = sorted(XYH_list, key=lambda x: x[2], reverse=True)\\n\\nfor xi in range(0, 101):\\n    for yi in range(0, 101):\\n        tmpH = 0\\n        for k in range(N):\\n            x,y,h = XYH_list[k]\\n            if k == 0:\\n                tmpH =h + abs(x - xi) + abs(y - yi)\\n            if h == max((tmpH - abs(x - xi) - abs(y - yi)), 0):\\n                if k == N - 1:\\n                    ans = [str(xi), str(yi), str(tmpH)]\\n                continue\\n            else:\\n                break\\nprint(' '.join(ans))\", \"n = int(input())\\nxyh = []\\nfor i in range(n):\\n    xyh.append(list(map(int, input().split())))\\nxyh.sort(key = lambda x: x[2], reverse = True)\\nfor i in range(101):\\n    for j in range(101):\\n        h = xyh[0][2] + abs(xyh[0][0] - i) + abs(xyh[0][1] - j)\\n        flag = True\\n        for k in range(1, n):\\n            if xyh[k][2] == 0:\\n                if abs(xyh[k][0] - i) + abs(xyh[k][1] - j) < h:\\n                    flag = False\\n                    break\\n            else:\\n                temp = xyh[k][2] + abs(xyh[k][0] - i) + abs(xyh[k][1] - j)\\n                if h != temp:\\n                    flag = False\\n                    break\\n        if flag == True and h >= 1:\\n            print(i, j, h)\\n            break\\n    if flag == True:\\n        break\", \"n = int(input())\\nXYH = [list(map(int, input().split())) for _ in range(n)]\\n#print(XYH)\\n\\nfor x1, y1, h1 in XYH:\\n    if h1 > 0:\\n        for Cx in range(101):\\n            for Cy in range(101):\\n                H = h1 + abs(x1 - Cx) + abs(y1 - Cy)\\n                # print(Cx, Cy, H)\\n                if all(h == max(H - abs(x - Cx) - abs(y - Cy), 0) for x, y, h in XYH):\\n                  print(Cx, Cy, H)\\n                  return\", \"n = int(input())\\nP = []\\nfor _ in range(n):\\n  x, y, h = map(int, input().split())\\n  P.append([h, x, y])\\nP.sort(reverse=True)\\n\\nfor cx in range(101):\\n  for cy in range(101):\\n    H = P[0][0] + abs(P[0][1]-cx) + abs(P[0][2]-cy)\\n    for i in range(1,n):\\n      if max(H-abs(P[i][1]-cx)-abs(P[i][2]-cy), 0) != P[i][0]:\\n        break\\n    else:\\n      print(cx, cy, H)\\n      return\", \"n=int(input())\\ninfo=[list(map(int,input().split())) for i in range(n)]\\nfor cx in range(0,101):\\n    for cy in range(0,101):\\n        H=-10**20\\n        lim=10**20\\n        for l in info:\\n            x,y,h=l \\n            if h==0:\\n                 lim=min(lim,abs(x-cx)+abs(y-cy))\\n                 \\n            else:\\n                if H!=-10**20 and H!=abs(x-cx)+abs(y-cy)+h :break\\n                H=abs(x-cx)+abs(y-cy)+h \\n            if H>lim:break\\n        else:\\n            print(cx,cy,H);return\", \"n = int(input())\\nhs = [list(map(int, input().split())) for _ in range(n)]\\nhs.sort(key= lambda x: x[2], reverse = True)\\n\\ndef main():\\n    for x in range(101):\\n        for y in range(101):\\n            height = hs[0][2] + abs(x-hs[0][0]) + abs(y-hs[0][1])\\n            for i in range(1,n):\\n                if max(height-(abs(x-hs[i][0]) + abs(y-hs[i][1])),0)== hs[i][2]:\\n                    pass\\n                else:\\n                    break\\n                \\n                if i ==n-1:\\n                    print(x,y,height)\\n                    return x,y,height\\nmain()\", \"n = int(input())\\nxyh = [list(map(int, input().split())) for _ in range(n)]\\n\\ntest = [(x,y,h) for x,y,h in xyh if h > 0]\\ntest = test[0]\\nfor cx in range(101):\\n    for cy in range(101):\\n        # h > 0\\u3067\\u4e2d\\u5fc3\\u5ea7\\u6a19\\u306e\\u9ad8\\u3055\\u3092\\u898b\\u7a4d\\u3082\\u308b\\n        x,y,h = test\\n        H = h + abs(x - cx) + abs(y - cy)\\n\\n        # \\u5168\\u30c7\\u30fc\\u30bf\\u306b\\u9069\\u5408\\u3059\\u308b\\u304b        \\n        if all([max(H - abs(x - cx) - abs(y - cy), 0) == h for x,y,h in xyh]):\\n            print(cx, cy, H)\\n            return\", \"N = int(input())\\n\\nInfo = [[] for T in range(0,N)]\\nfor I in range(0,N):\\n    Info[I] = [int(T) for T in input().split()]\\nInfo = sorted(Info,reverse=True,key=lambda X:X[2])\\nfor CX in range(0,101):\\n    for CY in range(0,101):\\n        Flag  = True\\n        BaseH = abs(Info[0][0]-CX)+abs(Info[0][1]-CY)+Info[0][2]\\n        for I in range(1,N):\\n            if max(BaseH-abs(Info[I][0]-CX)-abs(Info[I][1]-CY),0)!=Info[I][2]:\\n                Flag = False\\n                break\\n        if Flag:\\n            Ans = [str(CX),str(CY),str(BaseH)]\\n            break\\n    if Flag:\\n        break\\nprint(' '.join(Ans))\", \"n,*xyh = map(int,open(0).read().split())\\na = sorted([(xyh[i*3],xyh[i*3+1],xyh[i*3+2]) for i in range(n)],key=lambda x:x[2],reverse=True)\\nfor i in range(101):\\n  for j in range(101):\\n    dh = abs(a[0][0]-i)+abs(a[0][1]-j)+a[0][2]\\n    for x,y,h in a[1:]:\\n      if h != max(dh-abs(x-i)-abs(y-j),0):\\n        break\\n    else:\\n      print(i,j,dh)\\n      return\", \"N = int(input())\\nP = [list(map(int,input().split())) for n in range(N)]\\nx,y,h = list(filter(lambda x:x[2],P))[0]\\n\\nfor i in range(101):\\n  for j in range(101):\\n    H = h+abs(x-i)+abs(y-j)\\n    if all(max(H-abs(t[0]-i)-abs(t[1]-j),0)==t[2] for t in P):\\n      print(i,j,H)\", \"# \\u521d\\u671f\\u5165\\u529b\\nimport sys\\ninput = sys.stdin.readline  #\\u6587\\u5b57\\u5217\\u3067\\u306f\\u4f7f\\u308f\\u306a\\u3044\\nN = int(input())\\nxyh =[0]*N\\nh_list =[0]*N\\n\\nfor i in range(N):\\n    x,y,h= (int(i) for i in input().split())\\n    xyh[i] =x,y,h\\n    h_list[i] =h\\n\\nfrom bisect import bisect_right\\nxyh.sort(key =lambda x:x[2])\\nh_list.sort()\\nind =bisect_right(h_list,0)\\nfrom collections import defaultdict\\nH =defaultdict(set)\\n\\nfor x,y,h in xyh[ind:]:\\n    for cx in range(101):\\n        for cy in range(101):\\n            xx =x -cx\\n            yy =y -cy\\n            if cx <=x and cy <=y:\\n                H[(cx,cy)].add( (h +xx +yy) )\\n            elif cx >x and cy <=y:\\n                H[(cx,cy)].add( (h -xx +yy) )\\n            elif cx <=x and cy >y:\\n                H[(cx,cy)].add( (h +xx -yy) )\\n            elif cx >x and cy >y:\\n                H[(cx,cy)].add( (h -xx -yy) )\\n            \\n#print(xyh)\\n#H.sort(key =lambda x:x[1])\\nif len(xyh[ind:]) ==1:\\n    print(*xyh[-1])\\nelse:\\n    for k,v in H.items():\\n    \\n        if len(v)==1:\\n            vv =v.pop()\\n            if 0 <= vv :\\n                print(*k,vv)\\n            elif vv <0:\\n                print(*k,0)\", \"#\\n# abc112 c\\n#\\nimport sys\\nfrom io import StringIO\\nimport unittest\\n\\n\\nclass TestClass(unittest.TestCase):\\n    def assertIO(self, input, output):\\n        stdout, stdin = sys.stdout, sys.stdin\\n        sys.stdout, sys.stdin = StringIO(), StringIO(input)\\n        resolve()\\n        sys.stdout.seek(0)\\n        out = sys.stdout.read()[:-1]\\n        sys.stdout, sys.stdin = stdout, stdin\\n        self.assertEqual(out, output)\\n\\n    def test_\\u5165\\u529b\\u4f8b_1(self):\\n        input = \\\"\\\"\\\"4\\n2 3 5\\n2 1 5\\n1 2 5\\n3 2 5\\\"\\\"\\\"\\n        output = \\\"\\\"\\\"2 2 6\\\"\\\"\\\"\\n        self.assertIO(input, output)\\n\\n    def test_\\u5165\\u529b\\u4f8b_2(self):\\n        input = \\\"\\\"\\\"2\\n0 0 100\\n1 1 98\\\"\\\"\\\"\\n        output = \\\"\\\"\\\"0 0 100\\\"\\\"\\\"\\n        self.assertIO(input, output)\\n\\n    def test_\\u5165\\u529b\\u4f8b_3(self):\\n        input = \\\"\\\"\\\"3\\n99 1 191\\n100 1 192\\n99 0 192\\\"\\\"\\\"\\n        output = \\\"\\\"\\\"100 0 193\\\"\\\"\\\"\\n        self.assertIO(input, output)\\n\\n    def test_\\u5165\\u529b\\u4f8b_4(self):\\n        input = \\\"\\\"\\\"4\\n59 3 0\\n64 94 56\\n5 62 11\\n3 93 14\\\"\\\"\\\"\\n        output = \\\"\\\"\\\"55 80 79\\\"\\\"\\\"\\n        self.assertIO(input, output)\\n\\n\\ndef resolve():\\n    N = int(input())\\n    XYH = [list(map(int, input().split())) for _ in range(N)]\\n    XYH.sort(key=lambda x: x[2], reverse=True)\\n\\n    CX = CY = H = 0\\n    flag = False\\n    for cx in range(101):\\n        if flag == True:\\n            break\\n        for cy in range(101):\\n            H = XYH[0][2]+abs(XYH[0][0]-cx)+abs(XYH[0][1]-cy)\\n            for xyh in XYH[1:]:\\n                x, y, h = xyh\\n                if h != max(H - abs(x-cx) - abs(y-cy), 0):\\n                    break\\n            else:\\n                flag = True\\n                CX = cx\\n                CY = cy\\n                break\\n\\n    print(f\\\"{CX} {CY} {H}\\\")\\n\\n\\ndef __starting_point():\\n    # unittest.main()\\n    resolve()\\n\\n__starting_point()\", \"N = int(input())\\nl = []\\nfor i in range(N):\\n  l.append(list(map(int, input().split())))\\n  \\nfor x in range(101):\\n  for y in range(101):\\n    flag = True\\n    for i in range(N):\\n      if l[i][2]>0:\\n        tmp = abs(x-l[i][0])+abs(y-l[i][1])+l[i][2]\\n        break\\n    for i in range(N):\\n      if l[i][2] != max(tmp-abs(x-l[i][0])-abs(y-l[i][1]), 0):\\n        flag = False\\n        break\\n    if flag:\\n      print(x, y, tmp)\\n      return\", \"def resolve():\\n    n=int(input())\\n    xyh=[list(map(int,input().split())) for _ in range(n)]\\n    xyh.sort(key=lambda x:x[2],reverse=True)\\n    ans=[]\\n    for cx in range(101):\\n        for cy in range(101):\\n            x,y,h=xyh[0]\\n            ch=h+abs(x-cx)+abs(y-cy)\\n            if all([h==max(ch-abs(x-cx)-abs(y-cy),0) for x,y,h in xyh[1:]]):\\n                ans=[cx,cy,ch]\\n                break\\n    print(*ans)\\nresolve()\", \"N = int(input())\\np = [0] * N\\nfor i in range(N):\\n    p[i] = list(map(int, input().split()))\\n\\nfor i in range(N):\\n    if p[i][2] > 0:\\n        pp = p[i]\\n\\nf = 0\\n\\nfor i in range(101):\\n    for j in range(101):\\n        H = pp[2] + abs(i - pp[0]) + abs(j - pp[1])\\n        for k in range(N):\\n            #print(i, j ,k)\\n            if p[k][2] != max(H - abs(i - p[k][0]) - abs(j - p[k][1]), 0):\\n                break\\n            if k == (N - 1):\\n                xa = i\\n                ya = j\\n                Ha = H\\n                f = 1\\n                break\\n        if f == 1:\\n            break\\n    if f == 1:\\n        break\\n\\n\\nprint(xa, ya, Ha)\", \"import math\\nfrom math import gcd,pi,sqrt\\nINF = float(\\\"inf\\\")\\n\\nimport sys\\nsys.setrecursionlimit(10**6)\\nimport itertools\\nfrom collections import Counter,deque\\ndef i_input(): return int(input())\\ndef i_map(): return list(map(int, input().split()))\\ndef i_list(): return list(i_map())\\ndef i_row(N): return [i_input() for _ in range(N)]\\ndef i_row_list(N): return [i_list() for _ in range(N)]\\ndef s_input(): return input()\\ndef s_map(): return input().split()\\ndef s_list(): return list(s_map())\\ndef s_row(N): return [s_input for _ in range(N)]\\ndef s_row_str(N): return [s_list() for _ in range(N)]\\ndef s_row_list(N): return [list(s_input()) for _ in range(N)]\\n\\ndef main():\\n    n = i_input()\\n    l = [i_list() for i in range(n)]\\n\\n    L = []\\n\\n    for i in l:\\n        if i[2] != 0:\\n            L.append(i)\\n    if len(L) == 1:\\n        print((\\\" \\\".join(map(str, L[0]))))\\n        return\\n\\n    for x in range(101):\\n        for y in range(101):\\n            H = L[0][2] + abs(x-L[0][0]) + abs(y-L[0][1])\\n            flg = True\\n            for x1, y1, h1 in L[1:]:\\n                if h1 == 0:\\n                    pass\\n                if H != h1 + abs(x-x1) + abs(y-y1):\\n                    flg = False\\n                    break\\n            if flg == True:\\n                ans = [x,y]\\n    H = L[0][2] + abs(ans[0]-L[0][0]) + abs(ans[1]-L[0][1])\\n    print((\\\" \\\".join(map(str, ans)) +\\\" \\\"+str(H)))\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"n = int(input())\\nxyh = [list(map(int, input().split())) for _ in range(n)]\\nxyh.sort(key=lambda x: x[2], reverse=True)\\nans = []\\n\\nfor cx in range(101):\\n    for cy in range(101):\\n        x, y, h = xyh[0]\\n        ch = h + abs(x - cx) + abs(y - cy)\\n        if all([h == max(ch - abs(x - cx) - abs(y - cy), 0) for x, y, h in xyh[1:]]):\\n            ans = [cx, cy, ch]\\n            break\\nprint(*ans, sep=' ')\", \"n = int(input())\\nx_list = []\\ny_list = []\\nh_list = []\\n\\nfor i in range(n):\\n    a, b, c = list(map(int, input().split()))\\n    x_list.append(a)\\n    y_list.append(b)\\n    h_list.append(c)\\n\\nk = h_list.index(max(h_list))\\n\\nfor x in range(101):\\n    for y in range(101):\\n        h_max = h_list[k] + abs(x_list[k] - x) + abs(y_list[k] - y)\\n        \\n        for j in range(n):\\n            if h_list[j] == 0 :\\n                if h_max - (abs(x_list[j] - x) + abs(y_list[j] - y)) > 0 :\\n                    h_max = -1\\n            else:\\n                if h_max != abs(x_list[j] - x) + abs(y_list[j] - y) + h_list[j]:\\n                    h_max = -1\\n        \\n        if h_max != -1:\\n            print((str(x)+' '+str(y)+ ' '+ str(h_max)))\\n            break\\n\", \"n = int(input())\\nif n == 1:\\n    x, y, h = map(int, input().split())\\n    print(x, y, h)\\n    return\\ns = [list(map(int, input().split())) for _ in range(n)]\\nfor i in range(101):\\n    for j in range(101):\\n        h = -1\\n        ok = 1\\n        for t in s:\\n            if t[2] == 0:\\n                ok += 1\\n            elif h == -1:\\n                h = abs(t[0] - i) + abs(t[1] - j) + t[2]\\n            else:\\n                h0 = abs(t[0] - i) + abs(t[1] - j) + t[2]\\n                if h == h0:\\n                    ok += 1\\n        if ok == n:\\n            for t in s:\\n                if abs(t[0] - i) + abs(t[1] - j) <= h:\\n                    if not h == abs(t[0] - i) + abs(t[1] - j) + t[2]:\\n                        ok = 0\\n                else:\\n                    if not t[2] == 0:\\n                        ok = 0\\n            if ok == n:\\n                print(i, j, h)\\n                return\", \"n = int(input())\\nab = [list(map(int, input().split())) for _ in range(n)]\\n\\nfor _ in range(0,n):\\n    if ab[_][2] !=0:\\n        x = ab[_][0]\\n        y = ab[_][1]\\n        h = ab[_][2]\\n        break\\n\\nfor i in range(101):\\n    for j in range(101):\\n        f = True\\n        l = abs(i-x)+abs(j-y)+h\\n        for k in range(0,n):\\n            dx = ab[k][0]\\n            dy = ab[k][1]\\n            dh = ab[k][2]\\n            if max(l-abs(i-dx)-abs(j-dy),0) ==dh:\\n                pass\\n            else:\\n                f = False\\n        if f:\\n            ansx =i\\n            ansy =j\\n            ansr = l\\n            break\\nprint(str(ansx)+\\\" \\\"+str(ansy)+\\\" \\\"+str(ansr))\", \"N=int(input())\\nhyx=[list(map(int,input().split()))[::-1]for _ in range(N)]\\nR=range(101)\\nfor X in R:\\n    for Y in R:\\n        h,y,x=max(hyx)\\n        H=h+abs(X-x)+abs(Y-y)\\n        if all(h==max(H-abs(X-x)-abs(Y-y),0)for h,y,x in hyx):\\n            print(X,Y,H)\", \"#!/usr/bin/env python3\\n\\n\\n\\ndef solve(n,queries):\\n    def calcTopHeight(h,x,y,cx,cy):\\n        return h + abs(x-cx) + abs(y-cy)\\n    def calcHeight(h,x,y,cx,cy):\\n        return max(h - abs(x-cx) - abs(y-cy), 0)\\n    cand = [query for query in queries if query[2] != 0][0]\\n    for cx in range(101):\\n        for cy in range(101):\\n            cnt = 0\\n            probHeight = calcTopHeight(cand[2],cand[0],cand[1],cx,cy)\\n            for query in queries:\\n                x,y,h = query\\n                if calcHeight(probHeight,x,y,cx,cy) == h:\\n                    cnt += 1\\n            if cnt == n:\\n                return cx,cy,probHeight\\n    return -1,-1,-1\\n\\n\\ndef main():\\n    N = int(int(input()))\\n    queries = [list(map(int,input().split())) for _ in range(N)]\\n    print((*solve(N,queries)))\\n    return\\n    # write c\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"def main():\\n\\tN = int(input())\\n\\tinfo = []\\n\\tfor i in range(N):\\n\\t\\tx, y, h = [int(a) for a in input().split(\\\" \\\")]\\n\\t\\tinfo.append({\\\"x\\\": x, \\\"y\\\": y, \\\"h\\\": h})\\n\\tinfo.sort(key=lambda f: -f[\\\"h\\\"])\\n\\tfor cx in range(101):\\n\\t\\tfor cy in range(101):\\n\\t\\t\\tH = 0\\n\\t\\t\\tfor i in range(len(info)):\\n\\t\\t\\t\\th = info[i][\\\"h\\\"] + abs(info[i][\\\"x\\\"] - cx) + abs(info[i][\\\"y\\\"] - cy)\\n\\t\\t\\t\\tif i == 0:\\n\\t\\t\\t\\t\\tH = h\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tif h != H:\\n\\t\\t\\t\\t\\t\\tif (info[i][\\\"h\\\"] == 0 and h < H) or (info[i][\\\"h\\\"] > 0):\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\telse:\\n\\t\\t\\t\\tprint(cx, cy, H)\\n\\t\\t\\t\\treturn 0\\n\\tif info[0][\\\"x\\\"] in [0, 100] and info[0][\\\"y\\\"] in [0, 100]:\\n\\t\\tprint(info[0][\\\"x\\\"], info[0][\\\"y\\\"], info[0][\\\"h\\\"])\\n\\t\\treturn 0\\n\\nmain()\", \"import sys\\nimport math\\nfrom collections import defaultdict, deque, Counter\\nfrom copy import deepcopy\\nfrom bisect import bisect, bisect_right, bisect_left\\nfrom heapq import heapify, heappop, heappush\\n    \\ninput = sys.stdin.readline\\ndef RD(): return input().rstrip()\\ndef F(): return float(input().rstrip())\\ndef I(): return int(input().rstrip())\\ndef MI(): return map(int, input().split())\\ndef MF(): return map(float,input().split())\\ndef LI(): return list(map(int, input().split()))\\ndef TI(): return tuple(map(int, input().split()))\\ndef LF(): return list(map(float,input().split()))\\ndef Init(H, W, num): return [[num for i in range(W)] for j in range(H)]\\n    \\n    \\ndef main():\\n    N = I()\\n    L = [LI() for i in range(N)]\\n    \\n    for x in range(101):\\n        for y in range(101):\\n            max_num = float('inf')\\n            ans = 0\\n            res = True\\n            for xn, yn, hn in L:\\n                if hn == 0:\\n                    max_num = min(max_num, abs(x-xn)+abs(y-yn))\\n                    if max_num == 0:\\n                        res = False\\n                        break\\n                else:\\n                    temp = abs(x-xn)+abs(y-yn)+hn\\n                    if ans != 0 and ans != temp:\\n                        res = False\\n                        break\\n                    else:\\n                        ans = temp\\n            if (max_num >= 2 and ans == 0) or ans > max_num:\\n                res = False\\n\\n            if res:\\n                if ans != 0:\\n                    print(x,y,ans)\\n                else:\\n                    print(x,y,1)\\n                return\\n    \\n    \\n    \\ndef __starting_point():\\n    main()\\n__starting_point()\", \"import sys\\nN = int(input())\\nls = []\\nfor i in range(N):\\n    x,y,h = map(int,input().split())\\n    ls.append([x,y,h])\\nls.sort(key=lambda x: -x[2])\\n\\nfor i in range(0,101):\\n    for j in range(0,101):\\n        f = True\\n        H = ls[0][2]+abs(i-ls[0][0])+abs(j-ls[0][1])\\n        for k in range(1,N):\\n            if ls[k][2] != 0:\\n                H1 = ls[k][2]+abs(i-ls[k][0])+abs(j-ls[k][1])\\n                if H1 != H:\\n                    f = False\\n                    break\\n            else:\\n                if H > abs(i-ls[k][0])+abs(j-ls[k][1]):\\n                    f = False\\n                    break\\n        if f:\\n            print(i,j,H)\\n            return\", \"from math import ceil,floor,factorial,gcd,sqrt,log2,cos,sin,tan,acos,asin,atan,degrees,radians,pi,inf\\nfrom itertools import accumulate,groupby,permutations,combinations,product,combinations_with_replacement\\nfrom collections import deque,defaultdict,Counter\\nfrom bisect import bisect_left,bisect_right\\nfrom operator import itemgetter\\nfrom heapq import heapify,heappop,heappush\\nfrom queue import Queue,LifoQueue,PriorityQueue\\nfrom copy import deepcopy\\nfrom time import time\\nimport string\\nimport sys\\nsys.setrecursionlimit(10 ** 7)\\ndef input() : return sys.stdin.readline().strip()\\ndef INT()   : return int(input())\\ndef MAP()   : return map(int,input().split())\\ndef LIST()  : return list(MAP())\\n\\nn = INT()\\nx = [0]*n\\ny = [0]*n\\nh = [0]*n\\n\\nfor i in range(n):\\n    x[i], y[i], h[i] = MAP()\\n\\nfor i in range(101):\\n    for j in range(101):\\n        H = 0\\n        for k in range(n):\\n            if h[k] != 0:\\n                if H == 0 or H == h[k] + abs(x[k]-i) + abs(y[k]-j):\\n                    H = h[k] + abs(x[k]-i) + abs(y[k]-j)\\n                else:\\n                    break\\n        else:\\n            for k in range(n):\\n                if h[k] == 0:\\n                    if H - abs(x[k]-i) - abs(y[k]-j) <= 0:\\n                        continue\\n                    else:\\n                        break\\n            else:\\n                print(i,j,H)\", \"n = int(input())\\n\\nxy = [[-1 for i in range(101)] for j in range(101)]\\n\\nx = []\\ny = []\\nh = []\\nfor i in range(n):\\n  xx, yy, hh = map(int, input().split())\\n  x.append(xx)\\n  y.append(yy)\\n  h.append(hh)\\n  if hh > 0:\\n    x0, y0, h0, = xx, yy, hh\\n\\nfor i in range(101):\\n  for j in range(101):\\n    flg = 0\\n    tmp = h0 + abs(x0-i) + abs(y0-j)\\n    for k in range(n):\\n      if h[k] != max(tmp - abs(x[k]-i) - abs(y[k]-j),0):\\n        flg = 1\\n        break\\n    if flg == 0:\\n      print (i,j,tmp)\\n      return\", \"n = int(input())\\nxyh = []\\nx0, y0, h0 = None, None, None\\nfor _ in range(n):\\n    x, y, h = map(int, input().split())\\n    if h > 0 and x0 is None:\\n        x0, y0, h0 = x, y, h\\n    xyh.append([x, y, h])\\n\\nfor cx in range(101):\\n    for cy in range(101):\\n        h = h0 + abs(x0 - cx) + abs(y0 - cy)\\n        done = True\\n        for xk, yk, hk in xyh:\\n            h_ = max(h - abs(xk - cx) - abs(yk - cy), 0)\\n            if h_ != hk:\\n                done = False\\n                break\\n        if done:\\n            print(f'{cx} {cy} {h}')\", \"N=int(input())\\nhyx=[list(map(int,input().split()))[::-1]for _ in range(N)]\\nR=range(101)\\nfor X in R:\\n    for Y in R:\\n        h,y,x=max(hyx)\\n        H=h+abs(X-x)+abs(Y-y)\\n        if all(h==max(H-abs(X-x)-abs(Y-y),0)for h,y,x in hyx):\\n            print(X,Y,H)\", \"import sys\\nfrom heapq import heappush, heappop\\ndef input(): return sys.stdin.readline().rstrip()\\ndef ii(): return int(input())\\ndef mi(): return map(int, input().split())\\ndef li(): return list(mi())\\n\\n\\ndef main():\\n    n = ii()\\n    x = [0]*n\\n    y = [0]*n\\n    h = [0]*n\\n    for i in range(n):\\n        x[i], y[i], h[i] = mi()\\n    idx = h.index(max(h))\\n    for cx in range(101):\\n        for cy in range(101):\\n            flag = True\\n            H = abs(cx-x[idx])+abs(cy-y[idx])+h[idx]\\n            for i in range(n):\\n                tmp = abs(cx-x[i])+abs(cy-y[i])\\n                if h[i] == 0:\\n                    flag &= (tmp >= H)\\n                else:\\n                    tmp += h[i]\\n                    flag &= (tmp==H)\\n            if flag:\\n                print(cx, cy, H)\\n                return\\n            \\n            \\n        \\n        \\n\\n\\n\\n\\ndef __starting_point():\\n    main()\\n__starting_point()\", \"n = int(input())\\n\\nans = [[cx, cy, -1] for cx in range(101) for cy in range(101)]\\nzeroes = []\\n\\nfor i in range(n):\\n    x, y, h = list(map(int, input().split()))\\n\\n    if h > 0:\\n        delete = []\\n\\n        for j in range(len(ans)):\\n            cx, cy, ch = ans[j]\\n\\n            calcH = h + abs(x-cx) + abs(y-cy)\\n            if ch == -1:\\n                ans[j][2] = calcH\\n            else:\\n                if ch != calcH:\\n                    delete.append(j)\\n\\n        while len(delete) > 0:\\n            del ans[delete.pop()]\\n    else:\\n        zeroes.append([x, y])\\n\\nfor x, y in zeroes:\\n    delete = []\\n\\n    for j in range(len(ans)):\\n        cx, cy, ch = ans[j]\\n\\n        if ch - abs(x-cx) - abs(y-cy) > 0:\\n            delete.append(j)\\n\\n    while len(delete) > 0:\\n        del ans[delete.pop()]\\n\\nprint(\\\" \\\".join(map(str, ans[0])))\", \"N = int(input())\\nxyh = [list(map(int,input().split())) for n in range(N)]\\nxyh.sort(key=lambda x:x[2],reverse=True)#\\u9ad8\\u5ea6\\uff11\\u3067\\u306a\\u3044\\u60c5\\u5831\\u304b\\u3089\\u9ad8\\u3055\\u5b9a\\u3081\\u308b\\u305f\\u3081\\nfor X in range(0,101):\\n    for Y in range(0,101):\\n        H = xyh[0][2] + abs(xyh[0][0]-X) + abs(xyh[0][1]-Y)\\n        for i in range(1,N):\\n            x,y,h = xyh[i]\\n            if h != max(H - abs(x-X) -abs(y-Y),0):\\n                break\\n        else:\\n            print(X,Y,H)\\n            break\", \"# -*- coding: utf-8 -*-\\n\\ndef getH(x, cx, y, cy, h):\\n    return h + abs(x-cx) + abs(y-cy)\\n\\nN = int(input())\\nconditions = []\\nfor i in range(N):\\n    x,y,h = map(int, input().split())\\n    if h > 0:\\n        conditions.append([x,y,h])\\n\\nnum_cnd = len(conditions)\\nif num_cnd==1:\\n    print(conditions[0][0],conditions[0][1],conditions[0][2])\\n    return\\n\\nfor cx in range(101):\\n    for cy in range(101):\\n        cnt = 0\\n        h = 0\\n        for i,cnd in enumerate(conditions):\\n            h_tmp = getH(cnd[0], cx, cnd[1], cy, cnd[2])\\n            if h_tmp >= 1:\\n                if i==0:\\n                    h = h_tmp\\n                    cnt += 1\\n                elif h == h_tmp:\\n                    cnt += 1\\n                    if cnt == num_cnd:\\n                        print(cx,cy,h)\\n                        return\\n                else:\\n                    break\\n            else:\\n                break\\n        \\n\\nprint('No')\", \"import sys\\n\\ninput = sys.stdin.readline\\nN = int(input())\\npiramids = []\\nfor _ in range(N):\\n    x, y, h = map(int, input().split())\\n    piramids.append((x, y, h))\\n\\nfor cx in range(101):\\n    for cy in range(101):\\n        h_cands = set()\\n        for x, y, h in piramids:\\n            if h == 0:\\n                continue\\n            cand = h + abs(x - cx) + abs(y - cy)\\n            h_cands.add(cand)\\n\\n        # \\u5236\\u7d04\\u3068\\u3057\\u3066\\u5fc5\\u305a\\u7279\\u5b9a\\u3067\\u304d\\u308b\\n        if len(h_cands) == 1:\\n            for x, y, h in piramids:\\n                if h != max(cand - abs(x - cx) - abs(y -cy), 0):\\n                    break\\n            else:\\n                print(cx, cy, cand)\\n                return\", \"n = int(input())\\nXYH = sorted([list(map(int, input().split())) for _ in range(n)], key=lambda x: -x[2])\\n\\nfor x in range(101):\\n    for y in range(101):\\n        hmax = XYH[0][2] + abs(x-XYH[0][0]) + abs(y-XYH[0][1])\\n        for i in range(n):\\n            if max(hmax-abs(x-XYH[i][0])-abs(y-XYH[i][1]), 0) != XYH[i][2]:\\n                break\\n            if i==n-1:\\n                print(x, y, hmax)\\n                return\", \"N=int(input())\\nL=[list(map(int,input().split())) for i in range(N)]\\nL.sort(key=lambda x:x[2],reverse=True)\\nfor i in range(101):\\n  for j in range(101):\\n    s=L[0][2]+abs(i-L[0][0])+abs(j-L[0][1])\\n    for l in L[1:]:\\n      h=l[2]+abs(i-l[0])+abs(j-l[1])\\n      if s==h:\\n        continue\\n      elif l[2]==0 and s<h:\\n        continue\\n      else:\\n        break\\n    else:\\n      print(i,j,s)\\n      return\", \"n = int(input())\\nxyh = [list(map(int, input().split())) for _ in range(n)]\\n\\nfor i in range(101):\\n    for j in range(101):\\n        s = -1\\n        flag = True\\n        limit = float('inf')\\n        for x, y, h in xyh:\\n            if h != 0:\\n                H = h + abs(x-i) + abs(y-j)\\n                if s != -1:\\n                    if s != H:\\n                        flag = False\\n                        break\\n                s = H\\n            else:\\n                limit = min(limit, abs(x-i) + abs(y-j))\\n        if flag:\\n            if s != -1 and s <= limit:\\n                print(i, j, s)\\n                return\\n            elif s <= limit and limit == 1:\\n                print(i, j, 1)\\n                return\", \"import sys\\nn = int(input())\\nxyh = [list(map(int, input().split())) for i in range(n)]\\ncnt = 0\\nfor i in range(n):\\n  if xyh[i][2] != 0:\\n    cnt += 1\\nif cnt == 1:\\n  for i in range(n):\\n    if xyh[i][2] != 0:\\n      print(\\\" \\\".join(list(map(str, xyh[i]))))\\n      return\\nfor i in range(101):\\n  for j in range(101):\\n    x = []\\n    for k in range(n):\\n      if xyh[k][2] != 0:\\n        x.append(abs(xyh[k][0]-i)+abs(xyh[k][1]-j)+xyh[k][2])\\n    if len(set(x)) == 1:\\n      print(i, j, x[0])\", \"N=int(input())\\ninfo=[]\\nfor i in range(N):\\n  info.append(list(map(int,input().split())))\\ninfo=list(filter(lambda x:x[2]!=0,info))\\nxy_00=max(map(lambda x:x[2]-(x[0]+x[1]),info))\\nxy_10=max(map(lambda x:x[2]-((100-x[0])+x[1]),info))\\nxy_01=max(map(lambda x:x[2]-(x[0]+(100-x[1])),info))\\nxy_11=max(map(lambda x:x[2]-((100-x[0])+(100-x[1])),info))\\n\\ncx1=(-xy_00+xy_10+100)//2\\ncx2=(-xy_01+xy_11+100)//2\\ncy1=(-xy_00+xy_01+100)//2\\ncy2=(-xy_10+xy_11+100)//2\\nflag=False\\nfor cx in [cx1,cx2]:\\n  for cy in [cy1,cy2]:\\n    ch=info[0][2]+(abs(info[0][0]-cx)+abs(info[0][1]-cy))\\n    for i in info:\\n      if not ch==i[2]+abs(cx-i[0])+abs(cy-i[1]):\\n        break\\n    else:\\n      print(f\\\"{cx} {cy} {ch}\\\")\\n      flag=True\\n      break\\n  if flag==True:\\n    break\", \"N = int(input())\\n\\nxyh = []\\nfor i in range(N):\\n    xyh.append(list(map(int,input().split())))\\n\\nxyh_sorted = sorted(xyh, key=lambda x: x[2], reverse=True)\\n\\nanswer = [0, 0, 0]\\nfor cy in range(0, 101):\\n    for cx in range(0, 101):\\n        H = xyh_sorted[0][2] + abs(xyh_sorted[0][0] - cx) + abs(xyh_sorted[0][1] - cy)\\n        flag = True\\n        for i in range(1,N):\\n            h2 = max(H - abs(xyh_sorted[i][0] - cx) - abs(xyh_sorted[i][1] - cy), 0)\\n            if h2 != xyh_sorted[i][2]:\\n                flag = False\\n                break\\n        if flag:\\n            answer = [cx, cy, H]\\n            break\\n    if flag:\\n        break\\n\\nanswerString = str(answer[0]) + \\\" \\\" + str(answer[1]) + \\\" \\\" + str(answer[2])\\nprint(answerString)\", \"def dist(h,xi, yi, cx, cy):\\n    return h + abs(xi - cx) + abs(yi - cy)\\n\\nN = int(input())\\nP = []\\nfor i in range(N):\\n    xi, yi, h= map(int, input().split())\\n    P.append([h, xi, yi])\\nP.sort(reverse = True)\\n\\nfor i in range(101):\\n    for j in range(101):\\n        H = dist(P[0][0], P[0][1], P[0][2],i, j)\\n        for p in P[1:]:\\n            if max(H - abs(p[1]-i)-abs(p[2]-j), 0) != p[0]:\\n                break\\n        else:\\n            print(i, j, H)\\n            break\", \"N = int(input())\\n\\nXYs = []\\nfor _ in range(N):\\n  XYs.append(list(map(int, input().split())))\\n  \\nfor i in range(101):\\n  for j in range(101):\\n    f = 1\\n    for k in range(N):\\n      if XYs[k][2] > 0:\\n        h = XYs[k][2] + abs(XYs[k][0]-i) + abs(XYs[k][1]-j)\\n        break\\n    for k in range(N):\\n      if max(h - abs(XYs[k][0]-i) - abs(XYs[k][1]-j), 0) != XYs[k][2]:\\n        f = 0\\n        break\\n    if f == 1:\\n      print(i,j,h)\\n      return\", \"n = int(input())\\na = []\\nfor i in range(n):\\n    _ = list(map(int, input().split()))\\n    a.append(_)\\na = sorted(a, key=lambda x:x[2],reverse = True)\\n\\ncheck = False\\n    \\nfor i in range(101):\\n    for j in range(101):\\n        b = 0\\n        while b < n:\\n            if b == 0:\\n                h = abs(i - a[b][0]) + abs(j - a[b][1]) + a[b][2]\\n                b +=1\\n            else:\\n                de = max(h - abs(i - a[b][0]) - abs(j - a[b][1]),0)\\n                if de == a[b][2]:\\n                    b+=1\\n                else:\\n                    break\\n        if b == n:\\n            ans = str(i) + ' ' + str(j) + ' ' +str(h)\\n            check = True\\n        if check:\\n            break\\n    if check:\\n        break\\nprint(ans)\\n\", \"n=int(input())\\nxyh=[]\\nfor i in range(n):\\n  x,y,h=map(int,input().split())\\n  xyh.append([h,x,y])\\nxyh.sort(reverse=True)\\nans=0\\n\\nfor cx in range(101):\\n  for cy in range(101):\\n    for N in range(n):\\n      if abs(xyh[0][1]-cx)+abs(xyh[0][2]-cy)+xyh[0][0]>0:\\n        H=abs(xyh[0][1]-cx)+abs(xyh[0][2]-cy)+xyh[0][0]\\n      else:\\n        break\\n      if xyh[N][0]!=max(H-abs(xyh[N][1]-cx)-abs(xyh[N][2]-cy),0):\\n        break\\n      if N == n-1:\\n        ans=[cx,cy,H]\\nprint(*ans)\", \"n=int(input())\\nalist=[list(map(int, input().split())) for i in range(n)]\\nalist.sort(key=lambda x:x[2],reverse=True)\\nfor i in range(101):\\n  for j in range(101):\\n    h=abs(alist[0][0]-i)+abs(alist[0][1]-j)+alist[0][2]\\n    ans=True\\n    for k in range(n):\\n      if max((h-abs(alist[k][0]-i)-abs(alist[k][1]-j)),0)!=alist[k][2]:\\n        ans=False \\n    if ans:\\n      ansx=i\\n      ansy=j\\n      ansh=h\\nprint(ansx,ansy,ansh)\", \"import bisect, collections, copy, heapq, itertools, math, string, sys\\ninput = lambda: sys.stdin.readline().rstrip() \\nsys.setrecursionlimit(10**7)\\nINF = float('inf')\\ndef I(): return int(input())\\ndef F(): return float(input())\\ndef SS(): return input()\\ndef LI(): return [int(x) for x in input().split()]\\ndef LI_(): return [int(x)-1 for x in input().split()]\\ndef LF(): return [float(x) for x in input().split()]\\ndef LSS(): return input().split()\\n\\ndef resolve():\\n    N = I()\\n\\n    # max\\u306e\\u9006\\u6f14\\u7b97\\u306e\\u305f\\u3081\\u3001h\\u304c0\\u306a\\u3082\\u306e\\u3068\\u305d\\u3046\\u3067\\u306a\\u3044\\u3082\\u306e\\u306b\\u5206\\u985e\\n    xyh_0 = []\\n    xyh_not0 = []\\n    for _ in range(N):\\n        xyh = LI()\\n        if xyh[2] == 0:\\n            xyh_0.append(xyh)\\n        else:\\n            xyh_not0.append(xyh)\\n\\n    for cx, cy in itertools.product(list(range(101)), list(range(101))):\\n        H = []\\n        for x, y, h in xyh_not0:\\n            H.append(h + abs(x - cx) + abs(y - cy))\\n        # h\\u304c0\\u3067\\u306a\\u3044\\u3082\\u306e\\u3067OK\\u3060\\u3063\\u305f\\u3089\\u3001h\\u304c0\\u306e\\u3082\\u306e\\u3067\\u8fbb\\u8904\\u304c\\u4f1a\\u3046\\u304b\\u3069\\u3046\\u304b\\u898b\\u308b\\n        if len(set(H)) == 1:\\n            is_ok = True\\n            for x, y, h in xyh_0:\\n                if max(H[0] - abs(x - cx) - abs(y - cy), 0) != 0:\\n                    is_ok = False\\n            if is_ok:\\n                ans = (cx, cy, H[0])\\n\\n    print((*ans))\\n\\ndef __starting_point():\\n    resolve()\\n\\n__starting_point()\", \"N=int(input())\\nl=[list(map(int,input().split())) for i in range(N)]\\nfor i,j,k in l:\\n   if k>0:\\n      fx,fy,fh=i,j,k\\nfor i in range(0,101):#x\\n   for j in range(0,101):#y\\n      sw=0\\n      cer_h=fh+abs(fx-i)+abs(fy-j)\\n      for x,y,h in l:\\n         if max(cer_h-abs(i-x)-abs(j-y),0)!=h:\\n            sw=1\\n            break\\n      if sw==0:\\n         print(i,j,cer_h)\\n         return\", \"def dist(a, b, x, y, h):\\n    return h + abs(a - x) + abs(b - y)\\n\\nN = int(input())\\nP = []\\nfor i in range(N):\\n    x, y, h = map(int, input().split())\\n    P.append([h, x, y])\\nP.sort(reverse = True)\\n\\nfor i in range(101):\\n    for j in range(101):\\n        H = dist(i, j, P[0][1], P[0][2], P[0][0])\\n        for p in P[1:]:\\n            if max(H - abs(p[1]-i)-abs(p[2]-j), 0) != p[0]:\\n                break\\n        else:\\n            print(i, j, H)\\n            break\", \"n = int(input())\\ncoords = [tuple(map(int, input().split())) for i in range(n)]\\nfor xt, yt, ht in coords:\\n    if ht != 0:\\n        break\\nx, y, h = -1, -1, -1\\nfor px in range(101):\\n    for py in range(101):\\n        flag = True\\n        htmp = ht + abs(px-xt) + abs(py-yt)\\n        dxdy = [(abs(px-x1)+abs(py-y1), htmp-h1) for x1, y1, h1 in coords]\\n        dxdy.sort()\\n        for i in range(n-1):\\n            if dxdy[i][0] < dxdy[i+1][0] and dxdy[i][1] > dxdy[i+1][1]:\\n                flag = False\\n                break\\n        for x1, y1, h1 in coords:\\n            #print (px, py, htmp, x1, y1, h1)\\n            if h1 == 0:\\n                continue\\n            if abs(htmp-h1) != abs(px-x1) + abs(py-y1):\\n                flag = False\\n                break\\n        if flag:\\n            if htmp > h:\\n                h = htmp\\n                x = px\\n                y = py\\nprint (x, y, h)\", \"N = int(input())\\nxyh = [list(map(int,input().split())) for i in range(N)]\\nf = False\\nfor x in range(101):\\n    for y in range(101):\\n        for i in range(N):\\n            if xyh[i][2] != 0:\\n                H = abs(xyh[i][0]-x) + abs(xyh[i][1]-y) + xyh[i][2]\\n                break\\n        for i in range(N):\\n            if xyh[i][2] == 0 and H - abs(xyh[i][0]-x) - abs(xyh[i][1]-y) > 0:\\n                break\\n            if xyh[i][2] != 0 and H != abs(xyh[i][0]-x) + abs(xyh[i][1]-y) + xyh[i][2]:\\n                break\\n        else:\\n            f = True\\n            break\\n    if f:\\n        break\\nprint(x,y,H)\", \"N = int(input())\\nl = [list(map(int, input().split())) for i in range(N)]\\nl.sort(key=lambda x: x[2], reverse=True)\\n\\nfor i in range(101):\\n    for j in range(101):\\n        h = l[0][2] + abs(i - l[0][0]) + abs(j - l[0][1])\\n        for k in range(N):\\n            tmp = max(h - abs(i - l[k][0]) - abs(j - l[k][1]), 0)\\n            if tmp != l[k][2]:\\n                break\\n            elif k == N-1:\\n                X = i\\n                Y = j\\n                H = h\\nprint(X,Y,H)\", \"N=int(input())\\nxyh=[list(map(int,input().strip().split())) for _ in range(N)]\\n\\ndp=[[-1 for i in range(101)] for j in range(101)]\\nfor n in range(N):\\n    dp[xyh[n][0]][xyh[n][1]]=xyh[n][2]\\n\\ndef find_top(x,y,N,xyh):\\n    find=True\\n    prev=-1\\n    for n in range(N):\\n        if xyh[n][2]!=0:\\n            top=xyh[n][2]+abs(xyh[n][0]-x)+abs(xyh[n][1]-y)\\n            if prev==-1:\\n                prev=top\\n            else:\\n                if prev!=top:\\n                    find=False\\n                    break\\n    return find,top\\n\\ndef check_top(x,y,top,N,xyh):\\n    check=True\\n    for n in range(N):\\n        if xyh[n][2]==0:\\n            if top-abs(xyh[n][0]-x)-abs(xyh[n][1]-y)>0:\\n                check=False\\n                break\\n    return check\\n\\nfin=False\\nfor x in range(101):\\n    if fin==True:\\n        break\\n    for y in range(101):\\n        find=find_top(x,y,N,xyh)[0]\\n        height=find_top(x,y,N,xyh)[1]\\n        if find and height>=1 and check_top(x,y,height,N,xyh):\\n            print(\\\"{} {} {}\\\".format(x,y,height))\\n            fin=True\"]", "task": "apps", "difficulty": "introductory", "split": "test", "transformation_type": "plain_summary"}