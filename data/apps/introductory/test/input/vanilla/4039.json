{"qid": 4039, "orig_input": "The only difference between easy and hard versions is that you should complete all the projects in easy version but this is not necessary in hard version.\n\nPolycarp is a very famous freelancer. His current rating is $r$ units.\n\nSome very rich customers asked him to complete some projects for their companies. To complete the $i$-th project, Polycarp needs to have at least $a_i$ units of rating; after he completes this project, his rating will change by $b_i$ (his rating will increase or decrease by $b_i$) ($b_i$ can be positive or negative). Polycarp's rating should not fall below zero because then people won't trust such a low rated freelancer.\n\nIs it possible to complete all the projects? Formally, write a program to check if such an order of the projects exists, that Polycarp has enough rating before starting each project, and he has non-negative rating after completing each project.\n\nIn other words, you have to check that there exists such an order of projects in which Polycarp will complete them, so he has enough rating before starting each project, and has non-negative rating after completing each project.\n\n\n-----Input-----\n\nThe first line of the input contains two integers $n$ and $r$ ($1 \\le n \\le 100, 1 \\le r \\le 30000$) \u2014 the number of projects and the initial rating of Polycarp, respectively.\n\nThe next $n$ lines contain projects, one per line. The $i$-th project is represented as a pair of integers $a_i$ and $b_i$ ($1 \\le a_i \\le 30000$, $-300 \\le b_i \\le 300$) \u2014 the rating required to complete the $i$-th project and the rating change after the project completion.\n\n\n-----Output-----\n\nPrint \"YES\" or \"NO\".\n\n\n-----Examples-----\nInput\n3 4\n4 6\n10 -2\n8 -1\n\nOutput\nYES\n\nInput\n3 5\n4 -5\n4 -2\n1 3\n\nOutput\nYES\n\nInput\n4 4\n5 2\n5 -3\n2 1\n4 -2\n\nOutput\nYES\n\nInput\n3 10\n10 0\n10 -10\n30 0\n\nOutput\nNO\n\n\n\n-----Note-----\n\nIn the first example, the possible order is: $1, 2, 3$.\n\nIn the second example, the possible order is: $2, 3, 1$.\n\nIn the third example, the possible order is: $3, 1, 4, 2$.", "input": "The only difference between easy and hard versions is that you should complete all the projects in easy version but this is not necessary in hard version.\n\nPolycarp is a very famous freelancer. His current rating is $r$ units.\n\nSome very rich customers asked him to complete some projects for their companies. To complete the $i$-th project, Polycarp needs to have at least $a_i$ units of rating; after he completes this project, his rating will change by $b_i$ (his rating will increase or decrease by $b_i$) ($b_i$ can be positive or negative). Polycarp's rating should not fall below zero because then people won't trust such a low rated freelancer.\n\nIs it possible to complete all the projects? Formally, write a program to check if such an order of the projects exists, that Polycarp has enough rating before starting each project, and he has non-negative rating after completing each project.\n\nIn other words, you have to check that there exists such an order of projects in which Polycarp will complete them, so he has enough rating before starting each project, and has non-negative rating after completing each project.\n\n\n-----Input-----\n\nThe first line of the input contains two integers $n$ and $r$ ($1 \\le n \\le 100, 1 \\le r \\le 30000$) \u2014 the number of projects and the initial rating of Polycarp, respectively.\n\nThe next $n$ lines contain projects, one per line. The $i$-th project is represented as a pair of integers $a_i$ and $b_i$ ($1 \\le a_i \\le 30000$, $-300 \\le b_i \\le 300$) \u2014 the rating required to complete the $i$-th project and the rating change after the project completion.\n\n\n-----Output-----\n\nPrint \"YES\" or \"NO\".\n\n\n-----Examples-----\nInput\n3 4\n4 6\n10 -2\n8 -1\n\nOutput\nYES\n\nInput\n3 5\n4 -5\n4 -2\n1 3\n\nOutput\nYES\n\nInput\n4 4\n5 2\n5 -3\n2 1\n4 -2\n\nOutput\nYES\n\nInput\n3 10\n10 0\n10 -10\n30 0\n\nOutput\nNO\n\n\n\n-----Note-----\n\nIn the first example, the possible order is: $1, 2, 3$.\n\nIn the second example, the possible order is: $2, 3, 1$.\n\nIn the third example, the possible order is: $3, 1, 4, 2$.", "test_cases": {"inputs": ["3 4\n4 6\n10 -2\n8 -1\n", "3 5\n4 -5\n4 -2\n1 3\n", "4 4\n5 2\n5 -3\n2 1\n4 -2\n", "3 10\n10 0\n10 -10\n30 0\n", "52 276\n303 6\n222 -6\n28 0\n93 6\n96 7\n223 0\n154 -4\n309 -7\n329 6\n94 3\n11 -3\n126 0\n210 2\n101 7\n154 4\n54 6\n33 5\n324 -4\n86 5\n220 -2\n137 -1\n49 -4\n109 6\n107 4\n270 2\n209 -2\n235 -5\n39 1\n110 5\n116 4\n155 1\n37 -1\n193 0\n356 -1\n320 -6\n261 -7\n316 6\n137 2\n165 2\n350 7\n224 6\n89 3\n149 7\n348 3\n271 3\n52 -5\n186 -5\n13 0\n173 -6\n285 2\n20 -5\n152 -5\n", "1 1\n1 0\n", "2 2\n1 2\n2 -2\n", "3 1\n1 0\n1 -1\n3 0\n", "4 1\n3 -1\n1 4\n2 -4\n4 2\n", "5 1\n4 5\n2 3\n4 5\n2 1\n5 3\n", "6 1\n4 6\n5 -6\n4 -3\n5 2\n2 4\n3 -5\n", "7 6\n2 3\n5 3\n7 2\n7 -1\n4 -4\n3 -4\n6 -6\n", "8 1\n2 8\n2 -6\n6 -5\n7 5\n6 8\n6 8\n2 5\n1 -2\n", "9 9\n9 -6\n1 -9\n5 -8\n7 -3\n4 1\n9 1\n1 -1\n1 -8\n7 8\n", "10 1\n7 -10\n2 -2\n7 5\n1 8\n10 -10\n5 6\n7 -9\n1 6\n6 4\n3 -2\n", "11 1\n6 -8\n4 11\n5 -10\n5 2\n8 7\n9 -1\n7 -10\n3 -10\n2 6\n3 4\n7 8\n", "12 10\n11 -12\n11 -5\n7 6\n2 1\n12 -2\n3 -12\n4 -12\n3 -11\n9 0\n9 4\n2 12\n5 -5\n", "13 11\n11 -7\n9 -11\n12 8\n12 4\n11 -12\n6 -4\n11 5\n5 -13\n5 -8\n10 2\n11 -8\n13 -11\n7 -10\n", "14 7\n4 -12\n5 -5\n4 -10\n14 3\n1 6\n4 -12\n6 -10\n4 -8\n5 -2\n2 -10\n9 -6\n1 6\n7 -4\n11 9\n", "15 11\n5 1\n1 -7\n14 6\n5 -7\n9 -3\n12 10\n9 -8\n8 -11\n8 12\n3 -1\n2 -1\n13 3\n13 -12\n3 12\n3 -5\n", "16 8\n16 -4\n12 15\n4 15\n13 10\n9 -4\n1 7\n16 -4\n1 -5\n13 8\n14 0\n8 -13\n10 11\n16 8\n10 6\n3 -5\n11 -8\n", "17 3\n12 -6\n7 -8\n14 -2\n4 -5\n8 0\n7 9\n17 -12\n10 -4\n2 -8\n16 -14\n4 1\n8 4\n14 -15\n3 13\n17 -1\n9 8\n11 -9\n", "18 4\n3 15\n7 3\n15 16\n18 -1\n10 10\n4 3\n2 18\n5 -2\n9 -5\n15 12\n8 5\n16 -7\n16 -9\n16 0\n8 8\n14 2\n8 -4\n13 -15\n", "19 11\n12 -10\n17 -18\n8 15\n5 4\n16 -6\n11 9\n10 -2\n2 -6\n8 -10\n8 -8\n8 13\n3 -12\n18 -11\n3 19\n16 19\n12 8\n15 4\n8 -16\n18 -14\n", "20 10\n19 -20\n7 4\n19 6\n10 -10\n13 4\n4 4\n19 20\n9 -9\n19 8\n13 9\n5 -16\n12 -1\n9 -7\n15 7\n6 -20\n2 -11\n1 -14\n13 -18\n12 -19\n6 19\n", "58 168\n25 -3\n70 -3\n169 2\n182 -4\n183 2\n178 4\n14 2\n18 0\n167 3\n8 4\n215 -4\n146 -3\n229 1\n27 3\n88 3\n202 4\n208 3\n33 2\n161 -4\n87 -1\n115 0\n175 2\n220 -4\n119 3\n188 -4\n50 1\n71 -2\n118 4\n55 1\n55 -4\n144 0\n66 -3\n90 -2\n147 3\n83 0\n111 -2\n10 1\n106 4\n117 -1\n43 3\n36 0\n227 -4\n107 -2\n106 4\n164 -1\n26 3\n227 -4\n202 -3\n176 4\n84 -1\n161 -2\n199 2\n29 2\n13 -3\n194 2\n110 1\n191 2\n92 2\n", "4 2\n3 0\n2 -3\n2 -1\n2 2\n", "3 10\n7 6\n9 -13\n4 -3\n", "6 12\n15 15\n25 -26\n8 3\n11 -6\n26 -19\n26 23\n", "9 4\n3 3\n7 0\n2 0\n5 4\n7 -3\n7 -7\n7 -6\n6 5\n5 0\n", "1 100\n200 -100\n", "2 4\n2 -1\n4 -3\n", "10 10\n1 1\n9 -5\n9 -6\n10 -2\n2 0\n5 5\n2 8\n10 -9\n5 -2\n4 4\n", "2 1000\n900 -1\n1000 -101\n", "6 104\n100 -99\n99 -1\n98 -1\n97 -1\n96 -1\n95 -1\n", "3 110\n100 -25\n90 -10\n70 -10\n", "3 100\n98 -50\n50 -1\n50 -1\n", "20 30000\n29889 -298\n29133 -283\n29949 -296\n29323 -297\n29642 -287\n29863 -299\n29962 -300\n29906 -297\n29705 -295\n29967 -296\n29804 -295\n29886 -295\n29984 -297\n29943 -298\n29711 -300\n29685 -295\n29805 -293\n29994 -292\n29472 -297\n29909 -296\n", "2 1000\n1000 -101\n900 -1\n", "3 20\n7 -13\n5 -4\n4 -3\n", "2 10\n10 -1\n10 -1\n", "1 4\n5 -3\n", "3 100\n96 -50\n50 -2\n50 -2\n", "10 300\n300 -1\n299 -1\n298 -1\n297 -1\n296 -1\n295 -1\n294 -1\n293 -1\n292 -1\n291 -1\n", "3 20\n16 -6\n14 -1\n15 -3\n"], "outputs": ["YES\n", "YES\n", "YES\n", "NO\n", "YES\n", "YES\n", "YES\n", "NO\n", "YES\n", "NO\n", "NO\n", "NO\n", "NO\n", "NO\n", "NO\n", "NO\n", "NO\n", "NO\n", "NO\n", "YES\n", "YES\n", "NO\n", "YES\n", "NO\n", "NO\n", "YES\n", "YES\n", "YES\n", "YES\n", "YES\n", "NO\n", "NO\n", "YES\n", "NO\n", "NO\n", "YES\n", "YES\n", "NO\n", "NO\n", "YES\n", "NO\n", "NO\n", "YES\n", "YES\n", "YES\n"]}, "solutions": "[\"def sign(x):\\n    return (x > 0) - (x < 0)\\n\\n\\ndef key(ab):\\n    a, b = ab\\n    return (2, -a - b) if b < 0 else (1, a)\\n\\n\\ndef main():\\n    n, r = list(map(int, input().split()))\\n    for a, b in sorted((tuple(map(int, input().split())) for _ in range(n)), key=key):\\n        if r < a:\\n            r = -1\\n            break\\n        r += b\\n    if r < 0:\\n        print(\\\"NO\\\")\\n    else:\\n        print(\\\"YES\\\")\\n\\n\\nmain()\\n\", \"n, r = map(int, input().split())\\n\\npt = []\\nnt = []\\nr2 = r\\nfor _ in range(n):\\n    a, b = map(int, input().split())\\n    r2 += b\\n    if b >= 0:\\n        pt.append((a, b))\\n    else:\\n        nt.append((a, b))\\n\\nif r2 < 0:\\n    print('NO')\\n    return\\n\\npt.sort()\\nnt.sort(key=lambda t: t[0]+t[1])\\n\\nfor a, b in pt:\\n    if r<a:\\n        print(\\\"NO\\\")\\n        return\\n    r += b\\n\\nfor a, b in nt:\\n    if r2 < a+b:\\n        print('NO')\\n        return\\n    r2 -= b\\n\\nprint('YES')\", \"n, r = map(int, input().split())\\na = [list(map(int, input().split())) for i in range(n)]\\npos = []\\nneg = []\\nfor x in a:\\n    if x[1] > 0:\\n        pos.append(x)\\n    else:\\n        neg.append(x)\\npos.sort(key=lambda k: k[0])\\nflg = 1\\nfor x in pos:\\n    if r < x[0]:\\n        flg = 0\\n    else:\\n        r += x[1]\\nneg.sort(key=lambda k: k[0]+k[1], reverse=True)\\nfor x in neg:\\n    if r < x[0]:\\n        flg = 0\\n    else:\\n        r += x[1]\\n        if r < 0:\\n            flg = 0\\nif flg == 1:\\n    print('YES')\\nelse:\\n    print('NO')\", \"n, r = [int(i) for i in input().split()]\\n\\nproj = [[0 for i in range(2)] for j in range(n)]\\nposb = 0\\nsum_neg = 0\\n\\nfor i in range(n):\\n    proj[i][0], proj[i][1] = [int(j) for j in input().split()]\\n    if proj[i][1] >= 0: posb += 1\\n    else: sum_neg += proj[i][1]\\n        \\nnegb = n-posb\\n        \\nproj = sorted(proj, key = lambda elem: elem[1])\\n\\nproj_pos = sorted(proj[negb:], key = lambda elem: elem[0])\\n\\nres = True\\n\\ni = 0\\n\\nwhile res and i < posb:\\n    if r < proj_pos[i][0]: res = False\\n    else:\\n        r += proj_pos[i][1]\\n        i += 1\\n        \\nif res:\\n    proj_neg = sorted(proj[:negb], key = lambda elem: elem[0]+elem[1], reverse = True)\\n    \\n    i = 0\\n    \\n    while res and i < negb and r >= 0:\\n        if r < proj_neg[i][0]: res = False\\n        else:\\n            r += proj_neg[i][1]\\n            i += 1\\n    \\n    if r >= 0 and res: print(\\\"YES\\\")\\n    else: print(\\\"NO\\\")\\n    \\n    \\nelse: print(\\\"NO\\\")\", \"\\nn,r = map(int, input().split())\\naa = [0]*n\\nbb = [0]*n\\nfor i in range(n):\\n    aa[i], bb[i] = map(int, input().split())\\navail = set(range(n))\\nfr = r + sum(bb)\\nif fr < 0:\\n    print(\\\"NO\\\")\\n    return\\nok = True\\nfor i in range(n):\\n    nxt = -1\\n    for j in avail:\\n        if aa[j] <= r and bb[j] >= 0:\\n            nxt = j\\n            break\\n    if nxt == -1:\\n        break\\n    avail.remove(nxt)\\n    r += bb[nxt]\\nfor i in range(len(avail)):\\n    nxt = -1\\n    for j in avail:\\n        if aa[j]+bb[j] <= fr and bb[j] < 0:\\n            nxt = j\\n            break\\n    if nxt == -1:\\n        ok = False\\n        break\\n    avail.remove(nxt)\\n    fr -= bb[nxt]\\nif ok:\\n    print(\\\"YES\\\")\\nelse:\\n    print(\\\"NO\\\")\", \"'''input\\n5 20\\n45 -6\\n34 -15\\n10 34\\n1 27\\n40 -45\\n\\n\\n'''\\nimport sys\\nfrom collections import defaultdict as dd\\n\\nmod=10**9+7\\n\\ndef ri(flag=0):\\n\\tif flag==0:\\n\\t\\treturn [int(i) for i in sys.stdin.readline().split()]\\n\\telse:\\n\\t\\treturn int(sys.stdin.readline())\\n\\n\\nn, r = ri()\\n\\neventspos = []\\neventsneg = []\\nfor i in range(n):\\n\\ttemp =ri()\\n\\tif temp[1]>=0:\\n\\t\\teventspos.append(temp)\\n\\telse:\\n\\t\\teventsneg.append(temp)\\n\\neventspos.sort()\\neventsneg.sort(key = lambda x: x[0]+x[1])\\neventsneg.reverse()\\n\\nstatus =1\\n\\nans=0 \\n\\nfor i in range(len(eventspos)):\\n\\tif eventspos[i][0] <= r:\\n\\t\\tr+= eventspos[i][1]\\n\\t\\tans+=1\\n\\telse:\\n\\t\\tstatus = 0\\n\\n\\ncheck = [0 for i in range(r+1)]\\n\\n#print(eventsneg)\\n\\nfor i in range(len(eventsneg)):\\n\\tfor j in range(eventsneg[i][0] , r+1):\\n\\t\\tif j+eventsneg[i][1]>=0:\\n\\t\\t\\tcheck[j+eventsneg[i][1]] = max(check[j+eventsneg[i][1]] , check[j]+1) \\n\\n\\n\\nif max(check)+ ans  == n:\\n\\tprint(\\\"YES\\\")\\nelse:\\n\\tprint(\\\"NO\\\")\\n\\n#print(eventsneg,eventspos)\\n\\n\", \"n, r = map(int, input().split())\\na = [list(map(int, input().split())) for i in range(n)]\\npos = []\\nneg = []\\nfor x in a:\\n    if x[1] > 0:\\n        pos.append(x)\\n    else:\\n        neg.append(x)\\npos.sort(key=lambda k: k[0])\\nflg = 1\\nfor x in pos:\\n    if r < x[0]:\\n        flg = 0\\n    else:\\n        r += x[1]\\nneg.sort(key=lambda k: k[0]+k[1], reverse=True)\\nfor x in neg:\\n    if r < x[0]:\\n        flg = 0\\n    else:\\n        r += x[1]\\n        if r < 0:\\n            flg = 0\\nif flg == 1:\\n    print('YES')\\nelse:\\n    print('NO')\", \"import sys\\nfrom collections import defaultdict as dd\\n \\nmod=10**9+7\\n \\ndef ri(flag=0):\\n\\tif flag==0:\\n\\t\\treturn [int(i) for i in sys.stdin.readline().split()]\\n\\telse:\\n\\t\\treturn int(sys.stdin.readline())\\n \\n \\nn, r = ri()\\n \\neventspos = []\\neventsneg = []\\nfor i in range(n):\\n\\ttemp =ri()\\n\\tif temp[1]>=0:\\n\\t\\teventspos.append(temp)\\n\\telse:\\n\\t\\teventsneg.append(temp)\\n \\neventspos.sort()\\neventsneg.sort(key = lambda x: x[0]+x[1])\\neventsneg.reverse()\\n \\nstatus =1\\n \\nans=0 \\n \\nfor i in range(len(eventspos)):\\n\\tif eventspos[i][0] <= r:\\n\\t\\tr+= eventspos[i][1]\\n\\t\\tans+=1\\n\\telse:\\n\\t\\tstatus = 0\\n \\n \\ncheck = [0 for i in range(r+1)]\\n \\n#print(eventsneg)\\n \\nfor i in range(len(eventsneg)):\\n\\tfor j in range(eventsneg[i][0] , r+1):\\n\\t\\tif j+eventsneg[i][1]>=0:\\n\\t\\t\\tcheck[j+eventsneg[i][1]] = max(check[j+eventsneg[i][1]] , check[j]+1) \\n \\n \\n \\nif max(check)+ ans  == n:\\n\\tprint(\\\"YES\\\")\\nelse:\\n\\tprint(\\\"NO\\\")\\n \\n#print(eventsneg,eventspos)\\n\", \"# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\\nfrom sys import stdin, stdout\\nimport math\\n\\n#T = int(input())\\n#N = int(input())\\n#print(N)\\nN,r = [int(x) for x in stdin.readline().split()]\\n#arr = [int(x) for x in stdin.readline().split()]\\n\\nvisited = [0]*N\\n\\na = [0]*N\\nb = [0]*N\\n\\npos = 0\\n\\nfor i in range(N):\\n    arr = [int(x) for x in stdin.readline().split()]\\n    a[i] = arr[0]\\n    b[i] = arr[1]\\n    \\n    if b[i]>=0:\\n        pos += 1\\n\\nfor i in range(pos):\\n    idx = -1\\n    start = 0\\n    gain = -50000\\n    for j in range(N):\\n        # find available and largest gain\\n        # if gain tie, find largest start r\\n        if visited[j]==1 or b[j]<0:\\n            continue\\n            \\n        if b[j]>gain and r>=a[j]:\\n            gain = b[j]\\n            idx = j\\n            start = a[j]\\n        elif b[j]==gain and r>=a[j]:\\n            if a[j]>start:\\n                idx = j\\n                start = a[j]\\n                \\n    if idx==-1:\\n        print('NO')\\n        quit()\\n    else:\\n        visited[idx] = 1\\n        r += b[idx]\\n        #print(idx,r)\\n        \\n        \\ntmp = []\\nfor i in range(N):\\n    if visited[i]==1 or b[i]>=0:\\n        continue\\n    tmp.append((a[i],b[i],i))\\n    \\ntmp.sort(key=lambda e: (e[0]+e[1],e[0]),reverse=True)\\n\\nfor i in range(len(tmp)):\\n    require = tmp[i][0]\\n    bias = tmp[i][1]\\n    \\n    if r>=require:\\n        r += bias\\n    else:\\n        print('NO')\\n        quit()\\n        \\n\\nif r<0:\\n    print('NO')\\n    quit()\\n        \\nprint('YES')\", \"n, r = map(int, input().split())\\na = [list(map(int, input().split())) for i in range(n)]\\npos = []\\nneg = []\\nfor x in a:\\n    if x[1] > 0:\\n        pos.append(x)\\n    else:\\n        neg.append(x)\\npos.sort(key=lambda k: k[0])\\nflg = 1\\nfor x in pos:\\n    if r < x[0]:\\n        flg = 0\\n    else:\\n        r += x[1]\\nneg.sort(key=lambda k: k[0]+k[1], reverse=True)\\nfor x in neg:\\n    if r < x[0] or r<0:\\n        flg = 0\\n    else:\\n        r += x[1]\\nif flg == 1 and r>=0:\\n    print('YES')\\nelse:\\n    print('NO')\", \"n, r = map(int, input().split())\\n \\npt = []\\nnt = []\\nr2 = r\\nfor _ in range(n):\\n    a, b = map(int, input().split())\\n    r2 += b\\n    if b >= 0:\\n        pt.append((a, b))\\n    else:\\n        nt.append((a, b))\\n \\nif r2 < 0:\\n    print('NO')\\n    return\\n \\npt.sort()\\nnt.sort(key=lambda t: t[0]+t[1])\\n \\nfor a, b in pt:\\n    if r<a:\\n        print(\\\"NO\\\")\\n        return\\n    r += b\\n \\nfor a, b in nt:\\n    if r2 < a+b:\\n        print('NO')\\n        return\\n    r2 -= b\\n \\nprint('YES')\", \"n,r = list(map(int,(input().split())))\\n\\nplus=[]\\nminn=[]\\n\\nfor i in range (0,n):\\n\\n    temp = list(map(int,input().split()))\\n\\n    if temp[1] <=0:\\n        temp.append(temp[0]+temp[1])\\n        minn.append(temp)\\n    else:\\n        plus.append(temp)\\n\\nplus.sort()\\nminn.sort(reverse=True,key = lambda x: x[2])\\nflag = True\\nfor i in plus:\\n\\n    if i[0] <= r:\\n        r+= i[1]\\n        #print(r)\\n    else:\\n        flag=False\\n        break\\n#print(\\\"GANTI\\\")\\nif flag:\\n    for i in minn:\\n        if i[0] <= r:\\n            r +=i[1]\\n            #print(r)\\n        else:\\n            flag=False\\n            break\\n\\n\\nif flag and r>=0:\\n    print(\\\"YES\\\")\\nelse:\\n    print(\\\"NO\\\")\\n\", \"n,r=list(map(int,input().split()))\\narr1=[]\\narr2=[]\\nfor i in range(n):\\n\\tx,y=list(map(int,input().split()))\\n\\tif(y>=0):\\n\\t\\tarr1.append((x,y))\\n\\telse:\\n\\t\\tarr2.append((x,y))\\n \\narr1.sort()\\narr2.sort(reverse=True)\\ncurrval=r\\nflag=0\\nfor i in range(len(arr1)):\\n\\t#print(arr1[i][0],currval)\\n\\tif(arr1[i][0]>currval):\\n\\t\\tprint(\\\"NO\\\")\\n\\t\\treturn\\n\\telse:\\n\\t\\tcurrval+=arr1[i][1]\\ntempval=currval\\n \\nmark=[0]*len(arr2)\\ncountx=0\\nfinalans=0\\nwhile(countx<len(arr2)):\\n\\tflag=-1\\n\\tfor i in range(len(arr2)):\\n\\t\\tif(mark[i]==0 and currval>=arr2[i][0]):\\n\\t\\t\\ttempflag=0\\n\\t\\t\\tfor j in range(len(arr2)):\\n\\t\\t\\t\\tif(j!=i and mark[j]==0):\\n\\t\\t\\t\\t\\tif(currval+arr2[i][1]<arr2[j][0]):\\n\\t\\t\\t\\t\\t\\ttempflag=1\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t#print(tempflag)\\n\\t\\t\\tif(tempflag==0):\\n\\t\\t\\t\\tflag=i\\n\\t\\t\\t\\tbreak\\n\\tif(flag==-1):\\n\\t\\tfinalans=1\\n\\t\\tbreak\\n\\telse:\\n\\t\\tcurrval+=arr2[flag][1]\\n\\t\\tmark[flag]=1\\n\\t\\tcountx+=1\\nif(currval<0):\\n\\tfinalans=1\\nif(finalans==0):\\n\\tprint(\\\"YES\\\")\\nelse:\\n\\tmark=[0]*len(arr2)\\n\\tcountx=0\\n\\tfinalans=0\\n\\tcurrval=tempval\\n\\twhile(countx<len(arr2)):\\n\\t\\tflag=-1\\n\\t\\tfor i in range(len(arr2)):\\n\\t\\t\\tif(mark[i]==0 and currval>=arr2[i][0]):\\n\\t\\t\\t\\ttempflag=0\\n\\t\\t\\t\\tfor j in range(len(arr2)):\\n\\t\\t\\t\\t\\tif(j!=i and mark[j]==0):\\n\\t\\t\\t\\t\\t\\tif(currval+arr2[i][1]<arr2[j][0]):\\n\\t\\t\\t\\t\\t\\t\\ttempflag=1\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t#print(tempflag)\\n\\t\\t\\t\\tif(tempflag==0):\\n\\t\\t\\t\\t\\tflag=i\\n\\t\\t\\t\\t\\t\\n\\t\\tif(flag==-1):\\n\\t\\t\\tprint(\\\"NO\\\")\\n\\t\\t\\treturn\\n\\t\\t\\tbreak\\n\\t\\telse:\\n\\t\\t\\tcurrval+=arr2[flag][1]\\n\\t\\t\\tmark[flag]=1\\n\\t\\t\\tcountx+=1\\n\\tif(currval<0):\\n\\t\\tprint(\\\"NO\\\")\\n\\telse:\\n\\t\\tprint(\\\"YES\\\")\\n\\n\", \"n,r=list(map(int,input().split()))\\narr1=[]\\narr2=[]\\nfor i in range(n):\\n\\tx,y=list(map(int,input().split()))\\n\\tif(y>=0):\\n\\t\\tarr1.append((x,y))\\n\\telse:\\n\\t\\tarr2.append((x,y))\\n \\narr1.sort()\\narr2.sort(reverse=True)\\ncurrval=r\\nflag=0\\nfor i in range(len(arr1)):\\n\\t#print(arr1[i][0],currval)\\n\\tif(arr1[i][0]>currval):\\n\\t\\tprint(\\\"NO\\\")\\n\\t\\treturn\\n\\telse:\\n\\t\\tcurrval+=arr1[i][1]\\ntempval=currval\\n \\nmark=[0]*len(arr2)\\ncountx=0\\nfinalans=0\\nwhile(countx<len(arr2)):\\n\\tflag=-1\\n\\tfor i in range(len(arr2)):\\n\\t\\tif(mark[i]==0 and currval>=arr2[i][0]):\\n\\t\\t\\ttempflag=0\\n\\t\\t\\tfor j in range(len(arr2)):\\n\\t\\t\\t\\tif(j!=i and mark[j]==0):\\n\\t\\t\\t\\t\\tif(currval+arr2[i][1]<arr2[j][0]):\\n\\t\\t\\t\\t\\t\\ttempflag=1\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t#print(tempflag)\\n\\t\\t\\tif(tempflag==0):\\n\\t\\t\\t\\tflag=i\\n\\t\\t\\t\\tbreak\\n\\tif(flag==-1):\\n\\t\\tfinalans=1\\n\\t\\tbreak\\n\\telse:\\n\\t\\tcurrval+=arr2[flag][1]\\n\\t\\tmark[flag]=1\\n\\t\\tcountx+=1\\nif(currval<0):\\n\\tfinalans=1\\nif(finalans==0):\\n\\tprint(\\\"YES\\\")\\nelse:\\n\\tmark=[0]*len(arr2)\\n\\tcountx=0\\n\\tfinalans=0\\n\\tcurrval=tempval\\n\\twhile(countx<len(arr2)):\\n\\t\\tflag=-1\\n\\t\\tfor i in range(len(arr2)):\\n\\t\\t\\tif(mark[i]==0 and currval>=arr2[i][0]):\\n\\t\\t\\t\\ttempflag=0\\n\\t\\t\\t\\tfor j in range(len(arr2)):\\n\\t\\t\\t\\t\\tif(j!=i and mark[j]==0):\\n\\t\\t\\t\\t\\t\\tif(currval+arr2[i][1]<arr2[j][0]):\\n\\t\\t\\t\\t\\t\\t\\ttempflag=1\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t#print(tempflag)\\n\\t\\t\\t\\tif(tempflag==0):\\n\\t\\t\\t\\t\\tflag=i\\n\\t\\t\\t\\t\\t\\n\\t\\tif(flag==-1):\\n\\t\\t\\tprint(\\\"NO\\\")\\n\\t\\t\\treturn\\n\\t\\t\\tbreak\\n\\t\\telse:\\n\\t\\t\\tcurrval+=arr2[flag][1]\\n\\t\\t\\tmark[flag]=1\\n\\t\\t\\tcountx+=1\\n\\tif(currval<0):\\n\\t\\tprint(\\\"NO\\\")\\n\\telse:\\n\\t\\tprint(\\\"YES\\\")\\n\\n\", \"import math\\nimport sys\\nfrom collections import defaultdict\\n#input = sys.stdin.readline\\nnt = lambda: list(map(int, input().split()))\\n\\n\\ndef main():\\n    n, r = nt()\\n    projects = [tuple(nt()) for _ in range(n)]\\n    positive = [t for t in projects if t[1] > 0]\\n    negative = [t for t in projects if t[1] <= 0]\\n\\n    ok = True\\n    for p in sorted(positive):\\n        if p[0] <= r:\\n            r += p[1]\\n        else:\\n            ok = False\\n            break\\n    if ok:\\n        for p in sorted(negative, key=lambda x: -x[0]-x[1]):\\n            if p[0] <= r:\\n                r += p[1]\\n                if r < 0:\\n                    ok = False\\n                    break\\n            else:\\n                ok = False\\n                break\\n\\n    print('YES' if ok else 'NO')\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"import sys\\ninput = sys.stdin.readline\\nn,r=list(map(int,input().split()))\\nABP,ABN=[],[]\\nfor i in range(n):\\n  a,b=list(map(int,input().split()))\\n  if b>=0:\\n    ABP.append([a,b])\\n  else:\\n    ABN.append([a,b])\\nABP.sort(key=lambda x:(x[0],x[1]))\\nchk=True\\nfor i in range(len(ABP)):\\n  if ABP[i][0]>r:\\n    chk=False\\n  else:\\n    r+=ABP[i][1]\\nif chk==False:\\n  print(\\\"NO\\\")\\nelse:\\n  ABN.sort(key=lambda x:(x[0]+x[1],x[0]),reverse=True)\\n  for i in range(len(ABN)):\\n    a,b=ABN[i]\\n    if r<a:\\n      chk=False\\n    else:\\n      r+=b\\n  if chk==False or r<0:\\n    print(\\\"NO\\\")\\n  else:\\n    print(\\\"YES\\\")\\n\", \"import sys\\ninput = sys.stdin.readline\\nn,r=list(map(int,input().split()))\\nABP,ABN=[],[]\\nfor i in range(n):\\n  a,b=list(map(int,input().split()))\\n  if b>=0:\\n    ABP.append([a,b])\\n  else:\\n    ABN.append([a,b])\\nABP.sort(key=lambda x:(x[0],x[1]))\\nchk=True\\nfor i in range(len(ABP)):\\n  if ABP[i][0]>r:\\n    chk=False\\n  else:\\n    r+=ABP[i][1]\\nif chk==False:\\n  print(\\\"NO\\\")\\nelse:\\n  ABN.sort(key=lambda x:(x[0]+x[1]),reverse=True)\\n  for i in range(len(ABN)):\\n    a,b=ABN[i]\\n    if r<a:\\n      chk=False\\n    else:\\n      r+=b\\n  if chk==False or r<0:\\n    print(\\\"NO\\\")\\n  else:\\n    print(\\\"YES\\\")\\n\", \"n,r=list(map(int,input().split()))\\na=[]\\nb=[]\\nfor _ in range(n):\\n    c,d=list(map(int,input().split()))\\n    if d<0:\\n        b.append([c,d])\\n    else:\\n        a.append([c,d])\\na.sort(key = lambda x: x[0])\\nb.sort(key = lambda x: x[0]+x[1],reverse=True)\\nz=1\\nfor i in a:\\n    if i[0]>r:\\n        z=0\\n        break\\n    r+=i[1]\\nfor i in b:\\n    if i[0]>r:\\n        z=0\\n        break\\n    r+=i[1]\\nif z==0 or r<0:\\n    print('NO')\\nelse:\\n    print('YES')\\n#print(a,b)\\n\", \"n,r = list(map(int,input().split()))\\npl = []\\nmi = []\\nfor _ in range(n):\\n\\ta,b = list(map(int,input().split()))\\n\\tif b >= 0:\\n\\t\\tpl.append((a,b))\\n\\telse:\\n\\t\\tmi.append((a,b))\\npl.sort()\\nmi.sort(key=lambda t:t[0]+t[1])\\nmi.reverse()\\nfor i,j in pl:\\n\\tif(r < i):\\n\\t\\tprint('NO')\\n\\t\\treturn\\n\\telse:\\n\\t\\tr += j\\nfor i,j in mi:\\n\\tif(r<i):\\n\\t\\tprint('NO')\\n\\t\\treturn\\n\\telse:\\n\\t\\tr += j\\nif r < 0:\\n\\tprint('NO')\\nelse:\\n\\tprint('YES')\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nfrom math import gcd, sqrt\\n\\nn, r = map(int, input().split())\\nl = []\\nfor _ in range(n):\\n\\tl.append(list(map(int, input().split())))\\np = 0\\nwhile (p < n):\\n\\tif l[p][0] <= r and l[p][1] >= 0:\\n\\t\\tr += l[p][1]\\n\\t\\tl = l[:p] + l[p + 1:]\\n\\t\\tp = 0\\n\\t\\tn -= 1\\n\\telse:\\n\\t\\tp += 1\\nif l == []:\\n\\tprint(\\\"YES\\\")\\n\\treturn\\nans = True\\nq = len(l)\\nfor i in range(q):\\n\\tl[i][0] = max(l[i][0], -l[i][1])\\nl = sorted(l, key = lambda x: x[0] + x[1])\\nl.reverse()\\n#print(l, r)\\nfor i in range(len(l)):\\n\\tif l[i][0] > r:\\n\\t\\tans = False\\n\\t\\tbreak\\n\\telse:\\n\\t\\tr += l[i][1]\\nif ans and r >= 0:\\n\\tprint(\\\"YES\\\")\\nelse:\\n\\tprint(\\\"NO\\\")\", \"n, r = list(map(int, (input().split())))\\n\\nproj_list = []\\nfor _ in range(n):\\n    a, b = list(map(int, input().split()))\\n    proj_list.append([b, a, True])\\n\\ndef check(proj_list):\\n    nonlocal r\\n\\n    while len(proj_list) > 0:\\n        i = 0\\n        while True:\\n            if i == len(proj_list):\\n                for prj in proj_list:\\n                    if prj[2]:\\n                        return False\\n                return True\\n\\n            proj = proj_list[i]\\n            if r >= proj[1] and proj[2]:\\n                proj[2] = False\\n                r += proj[0]\\n                if r < 0:\\n                    return False\\n                break\\n            i += 1\\n\\n\\n#proj_list.sort(reverse=True)\\nraise_mmr = [x for x in proj_list if x[0] >= 0]\\nhard_work = [x for x in proj_list if x[0] < 0]\\nproj_list = sorted(raise_mmr, key=lambda x: x[0], reverse=True) + sorted(hard_work, key=lambda x: x[1] + x[0], reverse=True)\\n\\nprint(\\\"YES\\\" if check(proj_list) else \\\"NO\\\")\\n\", \"n,r = map(int,input().split())\\n\\npt = []\\nnt = []\\nr2 = r \\nfor _ in range(n):\\n    a,b = map(int,input().split())\\n    r2 += b \\n    if b >= 0:\\n        pt.append((a,b))\\n    else:\\n        nt.append((a,b))\\n\\nif r2<0:\\n    print('NO');return\\n\\npt.sort()\\nnt.sort(key=lambda t:t[0]+t[1])\\n\\nfor a,b in pt:\\n    if r<a:\\n        print('NO');return\\n    r += b \\n\\nfor a,b in nt:\\n    if r2 < a+b:\\n        print('NO');return\\n    r2 -= b \\n\\nprint(\\\"YES\\\")\\n\", \"a,b = map(int,input().split())\\nA = []\\nB = []\\nfor i in range(a):\\n    q,w = map(int,input().split())\\n    if w<0:\\n        q = max(q,-w)\\n        B.append([q+w,q,w])\\n    else:\\n        A.append([q,w])\\nA.sort()\\nB.sort()\\nB.reverse()\\nq = True\\ni = 0\\nw = len(A)\\nwhile q == True and i<w:\\n    if b>=A[i][0]:\\n        b+=A[i][1]\\n        i+=1\\n    else:\\n        q = False\\ni = 0\\nw = len(B)\\nwhile q == True and i<w:\\n    if b>=B[i][1]:\\n        b+=B[i][2]\\n        i+=1\\n    else:\\n        q = False\\nif q == True and b>=0:\\n    print('YES')\\nelse:\\n    print('NO')\"]", "task": "apps", "difficulty": "introductory", "split": "test", "transformation_type": "vanilla"}