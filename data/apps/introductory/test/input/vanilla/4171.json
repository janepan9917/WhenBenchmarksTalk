{"qid": 4171, "orig_input": "The only difference between easy and hard versions is the number of elements in the array.\n\nYou are given an array $a$ consisting of $n$ integers. In one move you can choose any $a_i$ and divide it by $2$ rounding down (in other words, in one move you can set $a_i := \\lfloor\\frac{a_i}{2}\\rfloor$).\n\nYou can perform such an operation any (possibly, zero) number of times with any $a_i$.\n\nYour task is to calculate the minimum possible number of operations required to obtain at least $k$ equal numbers in the array.\n\nDon't forget that it is possible to have $a_i = 0$ after some operations, thus the answer always exists.\n\n\n-----Input-----\n\nThe first line of the input contains two integers $n$ and $k$ ($1 \\le k \\le n \\le 2 \\cdot 10^5$) \u2014 the number of elements in the array and the number of equal numbers required.\n\nThe second line of the input contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 2 \\cdot 10^5$), where $a_i$ is the $i$-th element of $a$.\n\n\n-----Output-----\n\nPrint one integer \u2014 the minimum possible number of operations required to obtain at least $k$ equal numbers in the array.\n\n\n-----Examples-----\nInput\n5 3\n1 2 2 4 5\n\nOutput\n1\n\nInput\n5 3\n1 2 3 4 5\n\nOutput\n2\n\nInput\n5 3\n1 2 3 3 3\n\nOutput\n0", "input": "The only difference between easy and hard versions is the number of elements in the array.\n\nYou are given an array $a$ consisting of $n$ integers. In one move you can choose any $a_i$ and divide it by $2$ rounding down (in other words, in one move you can set $a_i := \\lfloor\\frac{a_i}{2}\\rfloor$).\n\nYou can perform such an operation any (possibly, zero) number of times with any $a_i$.\n\nYour task is to calculate the minimum possible number of operations required to obtain at least $k$ equal numbers in the array.\n\nDon't forget that it is possible to have $a_i = 0$ after some operations, thus the answer always exists.\n\n\n-----Input-----\n\nThe first line of the input contains two integers $n$ and $k$ ($1 \\le k \\le n \\le 2 \\cdot 10^5$) \u2014 the number of elements in the array and the number of equal numbers required.\n\nThe second line of the input contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 2 \\cdot 10^5$), where $a_i$ is the $i$-th element of $a$.\n\n\n-----Output-----\n\nPrint one integer \u2014 the minimum possible number of operations required to obtain at least $k$ equal numbers in the array.\n\n\n-----Examples-----\nInput\n5 3\n1 2 2 4 5\n\nOutput\n1\n\nInput\n5 3\n1 2 3 4 5\n\nOutput\n2\n\nInput\n5 3\n1 2 3 3 3\n\nOutput\n0", "test_cases": {"inputs": ["5 3\n1 2 2 4 5\n", "5 3\n1 2 3 4 5\n", "5 3\n1 2 3 3 3\n", "1 1\n1337\n", "50 2\n72548 51391 1788 171949 148789 151619 19225 8774 52484 74830 20086 51129 151145 87650 108005 112019 126739 124087 158096 59027 34500 87415 115058 194160 171792 136832 1114 112592 171746 199013 101484 182930 185656 154861 191455 165701 140450 3475 160191 122350 66759 93252 60972 124615 119327 108068 149786 8698 63546 187913\n", "50 2\n3 6 10 1 14 5 26 11 6 1 23 43 7 23 20 11 15 11 2 1 8 37 2 19 31 18 2 4 15 84 9 29 38 46 9 21 2 2 13 114 28 9 6 20 14 46 4 20 39 99\n", "50 2\n199995 199977 199982 199979 199998 199991 199999 199976 199974 199971 199966 199999 199978 199987 199989 199995 199968 199987 199988 199987 199987 199998 199988 199958 199985 199999 199997 199939 199992 199999 199985 199994 199987 199965 199947 199991 199993 199997 199998 199994 199971 199999 199999 199990 199993 199983 199983 199999 199970 199952\n", "50 7\n155076 162909 18349 8937 38161 128479 127526 128714 164477 163037 130796 160247 17004 73321 175301 175796 79144 75670 46299 197255 10139 2112 195709 124860 6485 137601 63708 117985 94924 65661 113294 85898 7511 137431 115791 66126 146803 121145 96379 126408 195646 70033 131093 86487 94591 3086 59652 188702 27036 78631\n", "50 7\n1 2 27 54 6 15 24 1 9 28 3 26 8 12 7 6 8 54 23 8 7 13 18 10 1 33 24 10 34 13 12 9 16 11 36 50 39 9 8 10 2 5 6 4 7 67 21 12 6 55\n", "50 7\n199961 199990 199995 199997 199963 199995 199985 199994 199974 199974 199997 199991 199993 199982 199991 199982 199963 200000 199994 199997 199963 199991 199947 199996 199994 199995 199995 199990 199972 199973 199980 199955 199984 199998 199998 199992 199986 199986 199997 199995 199987 199958 199982 199998 199996 199995 199979 199943 199992 199993\n", "50 25\n162847 80339 131433 130128 135933 64805 74277 145697 92574 169638 26992 155045 32254 97675 177503 143802 44012 171388 185307 33652 194764 80214 169507 71832 180118 117737 198279 89826 9941 120250 158894 31871 616 190147 159249 158867 131076 77551 95165 54709 51376 145758 74581 26670 48775 29351 4750 55294 129850 19793\n", "50 25\n19 1 17 6 4 21 9 16 5 21 2 12 17 11 54 18 36 20 34 17 32 1 4 14 26 11 6 2 7 5 2 3 12 16 20 5 16 1 18 55 16 20 2 3 2 12 65 20 7 11\n", "50 25\n199970 199997 199998 199988 199999 199981 200000 199990 199974 199985 199932 200000 199966 199999 199999 199951 199983 199975 199974 199996 199974 199992 199979 199995 199955 199989 199960 199975 199983 199990 199950 199952 199999 199999 199962 199939 199979 199977 199962 199996 199910 199997 199976 200000 199999 199997 199998 199973 199996 199917\n", "50 50\n86175 169571 61423 53837 33228 49923 87369 11875 167105 101762 128203 19011 191596 19500 11213 950 192557 164451 58008 34390 39704 128606 191084 14227 57911 129189 124795 42481 69510 59862 146348 57352 158069 68387 196697 46595 84330 168274 88721 191842 155836 39164 195031 53880 188281 11150 132256 87853 179233 135499\n", "50 50\n8 63 44 78 3 65 7 27 13 45 7 5 18 94 25 17 26 10 21 44 5 13 6 30 10 11 44 14 71 17 10 5 4 9 8 21 4 9 25 18 3 14 15 8 7 11 5 28 9 1\n", "50 50\n199987 199984 199987 199977 199996 199923 199984 199995 199991 200000 199998 199990 199983 199981 199973 199989 199981 199993 199959 199994 199973 199962 199998 199970 199999 199981 199996 199996 199985 199980 199959 199990 199982 199987 199992 199997 199985 199976 199947 199998 199962 199987 199984 199982 199999 199997 199985 199992 199979 199974\n", "50 1\n156420 126738 188531 85575 23728 72842 190346 24786 118328 137944 126942 115577 175247 85409 146194 31398 189417 52337 135886 162083 146559 131125 31741 152481 57935 26624 106893 55028 81626 99143 182257 129556 100261 11429 156642 27997 105720 173400 140250 164944 26466 132034 86679 190160 161138 179688 2975 149862 38336 67959\n"], "outputs": ["1\n", "2\n", "0\n", "0\n", "12\n", "0\n", "0\n", "79\n", "3\n", "7\n", "364\n", "43\n", "125\n", "780\n", "167\n", "450\n", "0\n"]}, "solutions": "[\"# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\\nfrom sys import stdin, stdout\\nfrom collections import defaultdict\\nfrom collections import deque\\nimport math\\nimport copy\\n \\n#T = int(input())\\n#N = int(input())\\n#s1 = input()\\n#s2 = input()\\nN,K = [int(x) for x in stdin.readline().split()]\\narr = [int(x) for x in stdin.readline().split()]\\narr.sort()\\n\\nfreq = {}\\n\\nfor i in range(N):\\n    num = arr[i]\\n    if num not in freq:\\n        freq[num] = []\\n        \\n    round = 0\\n    freq[num].append(0)\\n    while num!=0:\\n        round += 1\\n        num = num//2\\n        if num not in freq:\\n            freq[num] = []\\n            \\n        freq[num].append(round)\\n\\nres = 999999999999\\nfor key in freq:\\n    if len(freq[key])<K:\\n        continue\\n    else:\\n        s = sum(freq[key][:K])\\n        res = min(res,s)\\n        \\nprint(res)\\n        \\n\", \"import math\\nfrom heapq import merge\\nn, k = list(map(int, input().split()))\\nmaxN = 2 * (10 ** 5) + 10\\ncnt = [list() for i in range(0, maxN + 1)]\\na = list(map(int, input().split()))\\nfor c in a:\\n    cnt[c].append(0)\\nbest = 1000000000\\nfor i in range(maxN - 1, -1, -1):\\n    if 2 * i < maxN:\\n        cnt[2 * i] = [x + 1 for x in cnt[2 * i]]\\n        for p in cnt[2 * i]:\\n            p += 1\\n    if 2 * i + 1 < maxN:\\n        cnt[2 * i + 1] = [x + 1 for x in cnt[2 * i + 1]]\\n    if 2 * i < maxN:\\n        cnt[i] = list(merge(cnt[i], list(merge(cnt[2 * i], cnt[2 * i + 1]))))\\n    while len(cnt[i]) > k:\\n        cnt[i].pop()\\n    if len(cnt[i]) == k:\\n        best = min(best, sum(cnt[i]))\\nprint(best)\\n\", \"n, k = map(int, input().split())\\na = sorted(list(map(int, input().split())))\\n\\ncnt = dict()\\nsum = dict()\\n\\nres = n * 20\\n\\nfor x in a:\\n    y = x\\n    cur = 0\\n    while True:\\n        if y == 0:\\n            break\\n        if y not in cnt:\\n            cnt[y] = 0\\n            sum[y] = 0\\n        if cnt[y] < k:\\n            cnt[y] += 1\\n            sum[y] += cur\\n            if cnt[y] == k:\\n                res = min(res, sum[y])\\n        y >>= 1\\n        cur += 1\\nprint(res)\", \"n,k=list(map(int,input().split()))\\nit=list(map(int,input().split()))\\na=[[] for i in range(n)]\\nss={}\\nfor i in range(n):\\n    j=it[i]\\n    a[i]=[j]\\n    try:\\n        ss[j].append(0)\\n    except:\\n        ss[j]=[0]\\n    st=0\\n    while True:\\n        st+=1\\n        j=j//2\\n        try:\\n            ss[j].append(st)\\n        except:\\n            ss[j]=[st]\\n        a[i].append(j)\\n        if j==0:\\n            break\\ntt=ss.copy()\\nmi=10**10\\nfor i in ss:\\n    if len(ss[i])>=k:\\n        tt[i].sort()\\n        mi=min(mi,sum(tt[i][:k]))\\nprint(mi)\\n\\n        \\n        \\n            \\n\", \"\\\"\\\"\\\"\\nuseful stuff \\nx= list(map(int,input().split()))\\nx =[int (e) for e in input().split()]\\n\\nswap x,y=y,x\\nsubstring a[x:y] mean x to y-1\\n\\nprint list\\nprint(*list)\\nprint(' '.join(map(str,listname)))\\n\\nstart from 1 to n\\nfor i in range(1,n+1)\\n\\nDon't froget dumb stuff like:\\nif: \\nfor:\\nwhile: \\nand tab\\ndef doesn't require data type\\n\\\"\\\"\\\"\\nz= []\\na = []\\nfor i in range (200010):\\n    a.append([])\\nn,k = [int (e) for e in input().split()]\\nb = [int (e) for e in input().split()]\\nfor x in b:\\n    c=x\\n    ct=0\\n    a[x].append(0)\\n    while(c!=0):\\n        c>>=1\\n        ct+=1\\n        a[c].append(ct)\\nans=10000000000\\nfor i in range(200000):\\n    if(len(a[i])<k):\\n        continue\\n    a[i].sort()\\n    s=0\\n    for j in range(k):\\n        s+=a[i][j]\\n    ans=min(ans,s)\\nprint(ans)\\n\", \"n, k = [int(x) for x in input().split()]\\nnums = sorted([int(x) for x in input().split()])\\ncount = [0 for _ in range(2 * 100000 + 10)]\\nops = [0 for _ in range(2 * 100000 + 10)]\\nfor num in nums:\\n    op = 0\\n    while (num > 0):\\n        ops[num] += op if count[num] < k else 0\\n        count[num] += 1\\n        num = num // 2\\n        op += 1\\n    ops[num] += op if count[num] < k else 0\\n    count[num] += 1\\n\\nminn = 0\\nminop = ops[0]\\nfor i in range(2 * 100000 + 1):\\n    if (count[i] >= k and ops[i] < minop):\\n        minn = i\\n        minop = ops[i]\\n\\nprint(minop)\\n\", \"n,k=map(int,input().split())\\na=list(map(int,input().split()))\\nans=[[0,0] for i in range(200001)]\\na.sort()\\nfor i in range(n):\\n    ans[a[i]][0]+=1\\nfor i in range(n):\\n    s=a[i]\\n    d=1\\n    while (s>0):\\n        s=s//2\\n        if ans[s][0]<k:\\n            ans[s][0]+=1\\n            ans[s][1]+=d\\n        d+=1\\nmi=100000000\\nfor i in range(len(ans)):\\n    if ans[i][0]>=k:\\n        if ans[i][1]<mi:\\n            mi=ans[i][1]\\nprint(mi)\", \"n, k = [int(i) for i in input().split()]\\na = sorted([int(i) for i in input().split()])\\n\\nnumbers = [[0, 0] for i in range(a[-1]+1)]\\n\\nfor i in range(n):\\n    op = 0\\n    \\n    while a[i] > 0:\\n        if numbers[a[i]][0] < k:\\n            numbers[a[i]][0] += 1\\n            numbers[a[i]][1] += op\\n        \\n        a[i] //= 2\\n        op += 1\\n        \\n    numbers[0][0] += 1\\n    numbers[0][1] += op\\n    \\nans = numbers[0][1]\\n\\nfor number in numbers:\\n    if number[0] >= k and number[1] < ans: ans = number[1]\\n        \\nprint(ans)\", \"MOD = 10**9 + 7\\nI = lambda:list(map(int,input().split()))\\n\\nn, m = I()\\nl = I()\\nl.sort()\\nans = MOD\\no = [0]*300000\\nd = [0]*300000\\nfor i in range(n):\\n\\tk = l[i]\\n\\to[k] += 1\\n\\tif o[k] == m:\\n\\t\\t\\tans = min(ans, d[k])\\n\\ti = 0\\n\\twhile k > 0:\\n\\t\\ti += 1\\n\\t\\tk //= 2\\n\\t\\to[k] += 1\\n\\t\\td[k] += i\\n\\t\\tif o[k] == m:\\n\\t\\t\\tans = min(ans, d[k])\\n\\nprint(ans)\", \"from math import log\\n\\n\\nn, k = list(map(int, input().split()))\\narr = list(map(int, input().split()))\\n\\nans = 0\\na = [[] for i in range(200001)]\\nfor i in range(n):\\n    x = arr[i]\\n    l = 0\\n    while True:\\n        a[x].append(l)\\n        if x == 0:\\n            break\\n        x //= 2\\n        l += 1\\nmn = 1000000000\\nfor i in range(len(a)):\\n    a[i].sort()\\n    if len(a[i]) >= k:\\n        mn = min(mn, sum(a[i][:k]))\\nprint(mn)\\n\", \"import collections\\nn,k=list(map(int,input().split()))\\nA=[int(i) for i in input().split()]\\nans=float(\\\"inf\\\")\\nD1,D2=collections.defaultdict(list),collections.defaultdict(int)\\nfor i in range(n):\\n  a=A[i]\\n  c=0\\n  D1[a].append(c)\\n  D2[a]+=1\\n  while a>0:\\n    a//=2\\n    c+=1\\n    D1[a].append(c)\\n    D2[a]+=1\\nfor i in range(max(A)+1):\\n  if D2[i]>=k:\\n    D1[i].sort()\\n    ans=min(ans,sum(D1[i][:k]))\\nprint(ans)\\n\\n\", \"'''input\\n5 3\\n1 2 3 3 3\\n'''\\nfrom collections import defaultdict as dd\\n\\nn, k = [int(i) for i in input().split()]\\na = [int(i) for i in input().split()]\\n\\nd = dd(list)\\nfor x in a:\\n\\ti = 0\\n\\twhile(x):\\n\\t\\td[x].append(i)\\n\\t\\tx //= 2\\n\\t\\ti += 1\\nans = 999999999999\\nfor i in d:\\n\\tif len(d[i]) >= k:\\n\\t\\td[i].sort()\\n\\t\\tans = min(ans, sum(d[i][0:k]))\\nprint(ans)\", \"from collections import defaultdict as DD\\nimport sys\\nMOD=pow(10,9)+7\\n\\ndef IN(f=0):\\n    if f==0:\\n        return ( [int(i) for i in sys.stdin.readline().split()] )\\n    else:\\n        return ( int(sys.stdin.readline()) )\\n\\nn,k=IN()\\na=IN()\\nb=[]\\n\\nd=DD(list)\\nfor x in a:\\n    i=0\\n    while(x!=0):\\n        d[x].append(i)\\n        x=x//2\\n        i+=1\\n    d[0].append(i)\\n    #print(d)\\n\\nans=9999999999999\\nfor x in d:\\n    if len(d[x])>=k:\\n        r=d[x]\\n        r.sort()\\n        ans=min(ans,sum(r[:k]))\\nprint(ans)\\n        \\n\\n\\n\", \"n, k = list(map(int, input().split()))\\narr = list(map(int, input().split()))\\nvalue_lists = [[] for _ in range(2 * (10**5) + 1)]\\nfor val in arr:\\n    turn = 0\\n    while val != 1:\\n        value_lists[val].append(turn)\\n        val //= 2\\n        turn += 1\\n    value_lists[val].append(turn)\\nmindist = 999999999\\nfor turns_val in value_lists:\\n    if len(turns_val) < k:\\n        continue\\n    turns_val.sort()\\n    mindist = min(mindist, sum(turns_val[:k]))\\nprint(mindist)\\n\", \"n, k = map(int,input().split())\\nl = list(map(int,input().split()))\\nd = {}\\nfor liczba in l:\\n    ll = liczba\\n    while ll > 0:\\n        d[ll] = []\\n        ll //= 2\\nfor liczba in l:\\n    i = 0\\n    ll = liczba\\n    while ll > 0:\\n        d[ll].append(i)\\n        ll //= 2\\n        i += 1\\nwyn = 1000000000\\nfor number in d:\\n    if len(d[number]) < k:\\n        continue\\n    a = d[number].copy()\\n    a.sort()\\n    wyn = min(wyn, sum(a[:k]))\\nprint(wyn)\", \"ans = {}\\nn,k = (int(s) for s in input().split())\\nl = [int(s) for s in input().split()]\\nl.sort()\\n\\nfor i in range(n):\\n    x = l[i]\\n    count = 0\\n    while (x>0):\\n        if x in ans:\\n            if ans[x][0] <k:\\n                ans[x][0]+=1\\n                ans[x][1]+=count\\n        else:\\n            ans[x] = [1, count]\\n        count+=1\\n        x = x//2\\n    if 0 in ans:\\n        if ans[0][0] < k:\\n            ans[0][0] += 1\\n            ans[0][1] += count\\n    else:\\n        ans[x] = [1, count]\\n# print(ans)\\nansm = 1000000000007\\nfor i in ans:\\n    if ans[i][0]>=k:\\n        ansm = min(ansm, ans[i][1])\\nprint(ansm)\\n\", \"b = {}\\nn, k = list(map(int, input().split()))\\na = list(map(int, input().split()))\\nb[0] = []\\nfor x in a:\\n    j = 0\\n    while(x > 0):\\n        if(x in b):\\n            b[x].append(j)\\n        else:\\n            b[x] = [j]\\n        x //= 2\\n        j += 1\\n    b[0].append(j)\\n\\nans = 10**10\\n\\nfor i in b:\\n    b[i].sort()\\n    if(len(b[i]) >= k):\\n        ans = min(sum(b[i][:k]), ans)\\n\\nprint(ans)\\n\", \"n, k = list(map(int, input().split()))\\nA = list(map(int, input().split()))\\nG = []\\nfor _ in range(2 * 10 ** 5 + 100):\\n    G.append([])\\nc = 0\\nfor i in A:\\n    if len(G[i]) < k:\\n        G[i].append(0)\\nwhile True:\\n    c += 1\\n    f = True\\n    for i in range(n):\\n        if A[i]:\\n            A[i] //= 2\\n            if len(G[A[i]]) < k:\\n                G[A[i]].append(c)\\n        if A[i]:\\n            f = False\\n    if f:\\n        break\\nans = 10 ** 9\\nfor t in G:\\n    if len(t) == k:\\n        ans = min(ans, sum(t))\\nprint(ans)\\n\", \"from sys import stdin\\n\\ninput = stdin.readline\\ninf = 1000 * 1000 * 1000\\n\\nn, k = list(map(int, input().split()))\\na = [int(i) for i in input().split()]\\n\\nb = []\\nfor i in range(200001):\\n    b.append([])\\n\\nfor i in a:\\n    ctr = 0\\n    while i > 0:\\n        b[i].append(ctr)\\n        i //= 2\\n        ctr += 1\\n    b[i].append(ctr)\\n\\nres = inf\\nfor i in b:\\n    if len(i) >= k:\\n        i.sort()\\n        tmp = 0\\n        for j in range(k):\\n            tmp += i[j]\\n        res = min(res, tmp)\\n\\n\\nprint(res)\\n\", \"def deep(mas, pref, k):\\n    deepmas = []\\n    s = 0\\n    for el in mas:\\n        if el[:len(pref)] == pref:\\n            deepmas.append(el)\\n            if len(deepmas) <= k:\\n                s += len(el) - len(pref)\\n    if len(deepmas) >= k:\\n        return min(s, deep(deepmas, pref + '0', k), deep(deepmas, pref + '1', k))\\n    else:\\n        return 20000000000000000\\n\\nn, k = list(map(int, input().split()))\\nmas = list(map(int, input().split()))\\nmas.sort()\\nmas = list(map(bin, mas))\\npref = '0b'\\nans = deep(mas, pref, k)\\nprint(ans)\\n\", \"from sys import stdin,stdout\\n\\ndef __starting_point():\\n    n,k=list(map(int,stdin.readline().split()))\\n    a=list(map(int,stdin.readline().split()))\\n    num=[[] for i in range(200005)]\\n    ans=200000*100\\n    for x in a:\\n        cnt=0\\n        while x>0:\\n            num[x].append(cnt)\\n            x//=2\\n            cnt+=1\\n        num[x].append(cnt)\\n    for i in range(200001):\\n        if len(num[i])<k:\\n            continue\\n        num[i].sort()\\n        cnt=0\\n        for j in range(k):\\n            cnt+=num[i][j]\\n        ans=min(ans,cnt)\\n    stdout.write('%d\\\\n'%(ans))\\n\\n\\n\\n__starting_point()\", \"from collections import *\\nn,k = [int(i) for i in input().split()]\\nA = [int(i) for i in input().split()]\\nA.sort()\\nd = defaultdict(lambda: [0,0])\\nfor i in A:\\n\\tnum = i\\n\\tstp = 0\\n\\twhile num>0:\\n\\t\\tif d[num][0]<k:\\n\\t\\t\\td[num][0]+=1\\n\\t\\t\\td[num][1]+=stp\\n\\t\\tnum = num//2\\n\\t\\tstp +=1\\n\\tif d[num][0]<k:\\n\\t\\t\\td[num][0]+=1\\n\\t\\t\\td[num][1]+=stp\\n\\nmn = 10**20\\nfor i in d:\\n\\tif(d[i][0]>=k):\\n\\t\\tmn = min(d[i][1],mn)\\n\\nprint(mn)\", \"MAX = 2 * 10 ** 5\\n\\n\\ndef main():\\n    n, k = list(map(int, input().split()))\\n    a = sorted(map(int, input().split()))\\n\\n    ops = [0] * (MAX + 1)\\n    ks = [0] * (MAX + 1)\\n\\n    for x in a:\\n        c = x\\n        j = 0\\n\\n        while True:\\n            if ks[c] < k:\\n                ops[c] += j\\n                ks[c] += 1\\n\\n            if c == 0:\\n                break\\n\\n            c //= 2\\n            j += 1\\n\\n    min_ops = float('inf')\\n    for i in range(MAX + 1):\\n        if ks[i] == k:\\n            min_ops = min(ops[i], min_ops)\\n\\n    print(min_ops)\\n\\n\\nmain()\\n\", \"def main():\\n    n,k = list(map(int,input().split()))\\n    arr = list(map(int,input().split()))\\n    nums = [[0 for i in range(2)] for j in range(2*10**5+1)]\\n    arr.sort()\\n    for i in arr:\\n        moves = 0\\n        #print('start')\\n        while i >= 0:\\n            if nums[i][0] == k:\\n                break\\n            nums[i][0] += 1\\n            nums[i][1] += moves\\n            moves += 1\\n            i = i//2\\n            if i == 0:\\n                nums[i][0] += 1\\n                nums[i][1] += moves\\n                break\\n\\n    min_moves = float('inf')\\n    for i in range(2*10**5+1):\\n        if nums[i][0] >= k:\\n            min_moves = min(min_moves,nums[i][1])\\n\\n    print(min_moves)\\n\\n\\nmain()\\n\", \"n,k1=map(int,input().split())\\nli=list(map(int,input().split()))\\nd={}\\nfor i in li:\\n    k=0\\n    while i!=0:\\n        try:\\n            d[i].append(k)\\n        except KeyError:\\n            d[i]=[k]\\n            \\n        k+=1\\n        i=i//2\\nmi=100000000\\nfor i in d.values():\\n    if len(i)>=k1:\\n        i.sort()\\n        mi=min(mi,sum(i[:k1]))\\nprint(mi)\"]", "task": "apps", "difficulty": "introductory", "split": "test", "transformation_type": "vanilla"}