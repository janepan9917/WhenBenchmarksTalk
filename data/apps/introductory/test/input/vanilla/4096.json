{"qid": 4096, "orig_input": "The only difference between easy and hard versions is the constraints.\n\nPolycarp has to write a coursework. The coursework consists of $m$ pages.\n\nPolycarp also has $n$ cups of coffee. The coffee in the $i$-th cup has $a_i$ caffeine in it. Polycarp can drink some cups of coffee (each one no more than once). He can drink cups in any order. Polycarp drinks each cup instantly and completely (i.e. he cannot split any cup into several days).\n\nSurely, courseworks are not usually being written in a single day (in a perfect world of Berland, at least). Some of them require multiple days of hard work.\n\nLet's consider some day of Polycarp's work. Consider Polycarp drinks $k$ cups of coffee during this day and caffeine dosages of cups Polycarp drink during this day are $a_{i_1}, a_{i_2}, \\dots, a_{i_k}$. Then the first cup he drinks gives him energy to write $a_{i_1}$ pages of coursework, the second cup gives him energy to write $max(0, a_{i_2} - 1)$ pages, the third cup gives him energy to write $max(0, a_{i_3} - 2)$ pages, ..., the $k$-th cup gives him energy to write $max(0, a_{i_k} - k + 1)$ pages.\n\nIf Polycarp doesn't drink coffee during some day, he cannot write coursework at all that day.\n\nPolycarp has to finish his coursework as soon as possible (spend the minimum number of days to do it). Your task is to find out this number of days or say that it is impossible.\n\n\n-----Input-----\n\nThe first line of the input contains two integers $n$ and $m$ ($1 \\le n \\le 100$, $1 \\le m \\le 10^4$) \u2014 the number of cups of coffee and the number of pages in the coursework.\n\nThe second line of the input contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 100$), where $a_i$ is the caffeine dosage of coffee in the $i$-th cup.\n\n\n-----Output-----\n\nIf it is impossible to write the coursework, print -1. Otherwise print the minimum number of days Polycarp needs to do it.\n\n\n-----Examples-----\nInput\n5 8\n2 3 1 1 2\n\nOutput\n4\n\nInput\n7 10\n1 3 4 2 1 4 2\n\nOutput\n2\n\nInput\n5 15\n5 5 5 5 5\n\nOutput\n1\n\nInput\n5 16\n5 5 5 5 5\n\nOutput\n2\n\nInput\n5 26\n5 5 5 5 5\n\nOutput\n-1\n\n\n\n-----Note-----\n\nIn the first example Polycarp can drink fourth cup during first day (and write $1$ page), first and second cups during second day (and write $2 + (3 - 1) = 4$ pages), fifth cup during the third day (and write $2$ pages) and third cup during the fourth day (and write $1$ page) so the answer is $4$. It is obvious that there is no way to write the coursework in three or less days in this test.\n\nIn the second example Polycarp can drink third, fourth and second cups during first day (and write $4 + (2 - 1) + (3 - 2) = 6$ pages) and sixth cup during second day (and write $4$ pages) so the answer is $2$. It is obvious that Polycarp cannot write the whole coursework in one day in this test.\n\nIn the third example Polycarp can drink all cups of coffee during first day and write $5 + (5 - 1) + (5 - 2) + (5 - 3) + (5 - 4) = 15$ pages of coursework.\n\nIn the fourth example Polycarp cannot drink all cups during first day and should drink one of them during the second day. So during first day he will write $5 + (5 - 1) + (5 - 2) + (5 - 3) = 14$ pages of coursework and during second day he will write $5$ pages of coursework. This is enough to complete it.\n\nIn the fifth example Polycarp cannot write the whole coursework at all, even if he will drink one cup of coffee during each day, so the answer is -1.", "input": "The only difference between easy and hard versions is the constraints.\n\nPolycarp has to write a coursework. The coursework consists of $m$ pages.\n\nPolycarp also has $n$ cups of coffee. The coffee in the $i$-th cup has $a_i$ caffeine in it. Polycarp can drink some cups of coffee (each one no more than once). He can drink cups in any order. Polycarp drinks each cup instantly and completely (i.e. he cannot split any cup into several days).\n\nSurely, courseworks are not usually being written in a single day (in a perfect world of Berland, at least). Some of them require multiple days of hard work.\n\nLet's consider some day of Polycarp's work. Consider Polycarp drinks $k$ cups of coffee during this day and caffeine dosages of cups Polycarp drink during this day are $a_{i_1}, a_{i_2}, \\dots, a_{i_k}$. Then the first cup he drinks gives him energy to write $a_{i_1}$ pages of coursework, the second cup gives him energy to write $max(0, a_{i_2} - 1)$ pages, the third cup gives him energy to write $max(0, a_{i_3} - 2)$ pages, ..., the $k$-th cup gives him energy to write $max(0, a_{i_k} - k + 1)$ pages.\n\nIf Polycarp doesn't drink coffee during some day, he cannot write coursework at all that day.\n\nPolycarp has to finish his coursework as soon as possible (spend the minimum number of days to do it). Your task is to find out this number of days or say that it is impossible.\n\n\n-----Input-----\n\nThe first line of the input contains two integers $n$ and $m$ ($1 \\le n \\le 100$, $1 \\le m \\le 10^4$) \u2014 the number of cups of coffee and the number of pages in the coursework.\n\nThe second line of the input contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 100$), where $a_i$ is the caffeine dosage of coffee in the $i$-th cup.\n\n\n-----Output-----\n\nIf it is impossible to write the coursework, print -1. Otherwise print the minimum number of days Polycarp needs to do it.\n\n\n-----Examples-----\nInput\n5 8\n2 3 1 1 2\n\nOutput\n4\n\nInput\n7 10\n1 3 4 2 1 4 2\n\nOutput\n2\n\nInput\n5 15\n5 5 5 5 5\n\nOutput\n1\n\nInput\n5 16\n5 5 5 5 5\n\nOutput\n2\n\nInput\n5 26\n5 5 5 5 5\n\nOutput\n-1\n\n\n\n-----Note-----\n\nIn the first example Polycarp can drink fourth cup during first day (and write $1$ page), first and second cups during second day (and write $2 + (3 - 1) = 4$ pages), fifth cup during the third day (and write $2$ pages) and third cup during the fourth day (and write $1$ page) so the answer is $4$. It is obvious that there is no way to write the coursework in three or less days in this test.\n\nIn the second example Polycarp can drink third, fourth and second cups during first day (and write $4 + (2 - 1) + (3 - 2) = 6$ pages) and sixth cup during second day (and write $4$ pages) so the answer is $2$. It is obvious that Polycarp cannot write the whole coursework in one day in this test.\n\nIn the third example Polycarp can drink all cups of coffee during first day and write $5 + (5 - 1) + (5 - 2) + (5 - 3) + (5 - 4) = 15$ pages of coursework.\n\nIn the fourth example Polycarp cannot drink all cups during first day and should drink one of them during the second day. So during first day he will write $5 + (5 - 1) + (5 - 2) + (5 - 3) = 14$ pages of coursework and during second day he will write $5$ pages of coursework. This is enough to complete it.\n\nIn the fifth example Polycarp cannot write the whole coursework at all, even if he will drink one cup of coffee during each day, so the answer is -1.", "test_cases": {"inputs": ["5 8\n2 3 1 1 2\n", "7 10\n1 3 4 2 1 4 2\n", "5 15\n5 5 5 5 5\n", "5 16\n5 5 5 5 5\n", "5 26\n5 5 5 5 5\n", "100 10000\n100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100\n", "100 10000\n100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 99 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100\n", "100 133\n1 1 2 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 2 1 1 1 1 1 2 1 1 1 2 1 1 1 1 2 1 1 1 1 1 1 1 1 2 1 1 1 3 1 1 2 1 3 1 1 1 2 1 3 1 1 1 2 2 1 1 1 1 1 1 1 3 1 2 1 1 2\n", "100 550\n12 7 8 16 13 6 12 6 10 12 13 10 6 12 9 8 5 13 7 13 5 14 10 13 9 6 14 14 6 11 13 13 8 3 8 13 12 8 13 8 14 10 15 8 12 8 10 13 13 13 7 8 12 9 7 10 16 10 10 4 9 9 11 8 8 13 8 15 11 8 9 6 6 16 12 11 9 8 10 9 12 8 11 9 8 10 7 13 6 13 10 9 15 9 3 11 5 17 7 13\n", "100 1960\n18 11 82 57 57 53 81 33 89 3 78 61 82 12 23 55 97 3 91 25 38 60 23 65 67 24 57 52 7 61 95 16 60 95 100 42 41 98 72 61 5 77 36 65 58 53 19 100 99 84 55 13 10 10 92 84 58 91 39 39 70 79 73 92 21 1 58 100 56 96 7 94 56 57 56 46 93 3 62 19 51 90 22 90 69 85 92 44 9 4 94 91 85 70 98 17 9 39 3 40\n", "100 1641\n94 59 24 80 3 80 94 45 34 21 35 13 95 66 8 38 75 41 69 76 97 83 18 86 10 16 35 91 86 91 77 42 73 67 92 34 11 23 31 54 12 59 51 6 57 69 7 60 84 25 33 65 17 90 100 45 75 70 92 35 67 70 34 10 90 39 77 73 58 62 58 12 41 50 81 16 41 8 17 11 1 38 96 66 30 9 25 97 55 85 56 75 82 5 89 15 1 88 61 16\n", "100 807\n70 14 71 10 42 8 10 61 78 38 95 73 5 37 85 17 60 82 51 28 49 5 9 11 49 7 18 38 78 20 47 71 82 30 79 34 81 52 93 43 19 44 62 52 68 82 96 20 66 62 15 13 31 61 8 3 89 49 33 30 56 53 99 32 55 82 92 53 67 24 13 17 21 38 5 86 89 21 64 95 46 86 62 38 95 49 61 51 6 58 30 62 71 44 80 21 85 41 15 3\n", "100 2019\n46 74 21 28 88 31 35 69 7 56 56 30 3 96 70 8 38 28 33 87 96 15 91 31 88 87 97 77 54 50 21 97 87 98 78 26 48 77 56 29 18 30 81 97 72 98 76 76 52 100 6 61 42 41 12 65 98 36 82 14 49 39 64 47 31 17 7 29 68 98 56 31 10 26 26 52 29 38 11 87 91 29 27 14 60 77 89 4 60 35 96 46 64 83 63 31 77 90 81 79\n", "100 686\n18 25 67 51 38 62 52 81 51 74 16 90 13 67 47 91 23 70 10 34 48 38 82 48 31 79 76 12 41 84 7 22 95 62 69 26 18 2 18 18 22 11 96 39 83 22 65 36 26 37 88 10 53 13 16 30 15 11 35 10 37 26 25 69 100 51 23 6 77 64 12 45 95 10 59 21 68 51 58 83 45 69 1 94 21 5 21 58 10 17 58 41 52 18 54 32 68 42 39 63\n", "100 3599\n97 74 72 46 41 31 18 51 98 37 18 61 78 30 64 7 47 3 2 36 27 93 7 23 67 61 88 35 47 14 20 9 77 13 54 17 77 24 49 56 60 4 75 45 2 65 83 59 62 38 13 57 98 98 98 10 44 57 82 13 6 32 48 39 79 57 94 48 56 45 58 65 32 35 50 33 36 52 48 11 63 53 67 46 91 75 68 29 59 32 62 19 3 87 23 13 3 60 100 23\n", "100 4344\n25 15 25 23 3 4 2 43 54 23 58 5 72 71 91 24 61 61 20 80 67 75 12 99 24 82 10 100 68 92 34 79 76 42 66 17 7 95 87 67 61 18 60 99 99 53 90 3 80 1 31 8 83 26 94 45 35 74 29 25 9 54 88 12 10 18 79 71 55 79 7 52 51 47 29 63 92 39 1 15 14 2 93 70 26 47 28 72 100 51 96 32 11 56 40 99 11 12 42 47\n", "100 5013\n45 59 71 97 56 73 77 31 9 5 98 44 63 1 2 41 88 15 43 29 16 61 25 78 81 90 31 53 80 58 60 53 67 78 71 25 37 62 36 82 53 41 45 58 91 36 6 47 94 63 41 52 80 47 86 79 22 99 84 30 21 59 31 94 45 75 56 99 46 13 52 42 66 51 4 93 52 22 50 23 60 58 27 85 69 7 100 18 50 74 34 44 22 17 49 1 28 63 76 63\n", "100 3961\n73 3 25 75 14 50 60 19 73 84 37 92 53 42 29 54 2 73 65 70 68 39 42 61 34 98 48 14 100 28 78 28 54 10 80 25 59 32 70 88 58 51 30 4 80 16 14 83 12 26 67 4 62 75 79 17 12 12 39 38 28 80 70 80 76 41 44 19 45 51 9 32 89 66 80 27 12 9 4 39 11 14 54 13 4 83 76 69 4 92 68 61 25 82 59 88 36 10 22 84\n", "100 4916\n1 48 78 56 75 22 48 7 28 70 77 32 43 71 40 72 29 28 83 15 9 16 52 40 91 14 69 75 13 95 5 6 53 47 93 33 92 7 7 95 51 66 11 58 77 3 29 27 34 89 80 60 47 95 79 60 3 32 86 50 39 85 5 58 99 6 29 42 36 77 53 15 8 78 51 58 65 96 49 47 70 70 80 37 47 51 40 12 57 19 5 77 32 47 68 86 44 57 60 96\n", "100 4799\n25 100 32 34 25 99 19 99 84 52 20 83 34 12 59 89 51 86 5 63 57 2 61 23 48 27 90 28 29 65 31 73 40 79 89 29 18 86 49 14 48 84 100 17 65 79 37 71 52 47 98 100 40 20 71 94 90 53 41 54 47 2 40 36 35 63 14 66 35 11 2 97 23 90 26 88 17 79 2 59 12 22 14 61 78 15 7 62 7 38 43 94 43 12 77 80 60 9 2 20\n", "42 12\n28 42 80 47 45 41 13 38 52 66 91 73 84 40 98 37 52 79 63 66 28 79 19 11 34 89 5 62 54 4 20 26 47 58 38 31 88 29 11 18 3 46\n", "69 3483\n60 56 86 28 76 4 96 31 56 49 68 43 28 81 64 84 17 35 13 10 96 18 33 76 19 40 33 71 69 63 35 87 53 56 89 98 15 74 88 35 67 20 18 97 4 20 53 70 26 53 66 68 85 54 63 7 75 8 9 97 78 56 7 96 12 39 9 72 56\n", "100 112\n1 1 1 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 2 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1 2 2 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 2 1\n", "100 10000\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n", "1 5\n6\n", "18 76\n6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 1 1\n"], "outputs": ["4\n", "2\n", "1\n", "2\n", "-1\n", "100\n", "-1\n", "-1\n", "9\n", "1\n", "1\n", "1\n", "1\n", "1\n", "4\n", "9\n", "23\n", "6\n", "93\n", "47\n", "1\n", "35\n", "-1\n", "-1\n", "1\n", "5\n"]}, "solutions": "[\"n, m = [int(x) for x in input().split()]\\na = [int(x) for x in input().split()]\\na.sort(reverse=True)\\n\\ndef check(d):\\n    s=0\\n    for i in range(len(a)):\\n        s+=max(0,a[i]-i//d)\\n    return s>=m\\nif sum(a)<m:\\n    print(-1)\\nelse:\\n    l, r = 1,n\\n    mid = l+r>>1\\n    while l<r:\\n        if check(mid):\\n            r=mid\\n        else:\\n            l=mid+1\\n        mid=l+r>>1\\n    print(l)\\n\", \"''' CODED WITH LOVE BY SATYAM KUMAR '''\\n\\n\\nfrom sys import stdin, stdout\\nimport cProfile, math\\nfrom collections import Counter\\nfrom bisect import bisect_left,bisect,bisect_right\\nimport itertools\\nfrom copy import deepcopy\\nfrom fractions import Fraction\\nimport sys, threading\\nimport operator as op\\nfrom functools import reduce\\nsys.setrecursionlimit(10**6) # max depth of recursion\\nthreading.stack_size(2**27)  # new thread will get stack of such size\\nfac_warmup = False\\nprintHeap = str()\\nmemory_constrained = False\\nP = 10**9+7\\nimport sys\\n\\nclass Operation:\\n    def __init__(self, name, function, function_on_equal, neutral_value=0):\\n        self.name = name\\n        self.f = function\\n        self.f_on_equal = function_on_equal\\ndef add_multiple(x, count):\\n    return x * count\\ndef min_multiple(x, count):\\n    return x\\ndef max_multiple(x, count):\\n    return x\\nsum_operation = Operation(\\\"sum\\\", sum, add_multiple, 0)\\nmin_operation = Operation(\\\"min\\\", min, min_multiple, 1e9)\\nmax_operation = Operation(\\\"max\\\", max, max_multiple, -1e9)\\nclass SegmentTree:\\n    def __init__(self,\\n                 array,\\n                 operations=[sum_operation, min_operation, max_operation]):\\n        self.array = array\\n        if type(operations) != list:\\n            raise TypeError(\\\"operations must be a list\\\")\\n        self.operations = {}\\n        for op in operations:\\n            self.operations[op.name] = op\\n        self.root = SegmentTreeNode(0, len(array) - 1, self)\\n    def query(self, start, end, operation_name):\\n        if self.operations.get(operation_name) == None:\\n            raise Exception(\\\"This operation is not available\\\")\\n        return self.root._query(start, end, self.operations[operation_name])\\n    def summary(self):\\n        return self.root.values\\n    def update(self, position, value):\\n        self.root._update(position, value)\\n    def update_range(self, start, end, value):\\n        self.root._update_range(start, end, value)\\n    def __repr__(self):\\n        return self.root.__repr__()\\nclass SegmentTreeNode:\\n    def __init__(self, start, end, segment_tree):\\n        self.range = (start, end)\\n        self.parent_tree = segment_tree\\n        self.range_value = None\\n        self.values = {}\\n        self.left = None\\n        self.right = None\\n        if start == end:\\n            self._sync()\\n            return\\n        self.left = SegmentTreeNode(start, start + (end - start) // 2,\\n                                    segment_tree)\\n        self.right = SegmentTreeNode(start + (end - start) // 2 + 1, end,\\n                                     segment_tree)\\n        self._sync()\\n    def _query(self, start, end, operation):\\n        if end < self.range[0] or start > self.range[1]:\\n            return None\\n        if start <= self.range[0] and self.range[1] <= end:\\n            return self.values[operation.name]\\n        self._push()\\n        left_res = self.left._query(start, end,\\n                                    operation) if self.left else None\\n        right_res = self.right._query(start, end,\\n                                      operation) if self.right else None\\n        if left_res is None:\\n            return right_res\\n        if right_res is None:\\n            return left_res\\n        return operation.f([left_res, right_res])\\n    def _update(self, position, value):\\n        if position < self.range[0] or position > self.range[1]:\\n            return\\n        if position == self.range[0] and self.range[1] == position:\\n            self.parent_tree.array[position] = value\\n            self._sync()\\n            return\\n        self._push()\\n        self.left._update(position, value)\\n        self.right._update(position, value)\\n        self._sync()\\n    def _update_range(self, start, end, value):\\n        if end < self.range[0] or start > self.range[1]:\\n            return\\n        if start <= self.range[0] and self.range[1] <= end:\\n            self.range_value = value\\n            self._sync()\\n            return\\n        self._push()\\n        self.left._update_range(start, end, value)\\n        self.right._update_range(start, end, value)\\n        self._sync()\\n    def _sync(self):\\n        if self.range[0] == self.range[1]:\\n            for op in self.parent_tree.operations.values():\\n                current_value = self.parent_tree.array[self.range[0]]\\n                if self.range_value is not None:\\n                    current_value = self.range_value\\n                self.values[op.name] = op.f([current_value])\\n        else:\\n            for op in self.parent_tree.operations.values():\\n                result = op.f(\\n                    [self.left.values[op.name], self.right.values[op.name]])\\n                if self.range_value is not None:\\n                    bound_length = self.range[1] - self.range[0] + 1\\n                    result = op.f_on_equal(self.range_value, bound_length)\\n                self.values[op.name] = result\\n    def _push(self):\\n        if self.range_value is None:\\n            return\\n        if self.left:\\n            self.left.range_value = self.range_value\\n            self.right.range_value = self.range_value\\n            self.left._sync()\\n            self.right._sync()\\n            self.range_value = None\\n    def __repr__(self):\\n        ans = \\\"({}, {}): {}\\\\n\\\".format(self.range[0], self.range[1],\\n                                      self.values)\\n        if self.left:\\n            ans += self.left.__repr__()\\n        if self.right:\\n            ans += self.right.__repr__()\\n        return ans\\n\\ndef display(string_to_print):\\n    stdout.write(str(string_to_print) + \\\"\\\\n\\\")\\n\\ndef primeFactors(n): #n**0.5 complex \\n    factors = dict()\\n    for i in range(2,math.ceil(math.sqrt(n))+1):  \\n        while n % i== 0: \\n            if i in factors:\\n                factors[i]+=1\\n            else: factors[i]=1\\n            n = n // i \\n    if n>2:\\n        factors[n]=1\\n    return (factors)\\n\\ndef binary(n,digits = 20):\\n    b = bin(n)[2:]\\n    b = '0'*(20-len(b))+b\\n    return b\\n\\ndef isprime(n):\\n    \\\"\\\"\\\"Returns True if n is prime.\\\"\\\"\\\"\\n    if n < 4:\\n        return True\\n    if n % 2 == 0:\\n        return False\\n    if n % 3 == 0:\\n        return False\\n    i = 5\\n    w = 2\\n    while i * i <= n:\\n        if n % i == 0:\\n            return False\\n        i += w\\n        w = 6 - w\\n    return True\\nfactorial_modP = []\\ndef warm_up_fac(MOD):\\n    nonlocal factorial_modP,fac_warmup\\n    if fac_warmup: return\\n    factorial_modP= [1 for _ in range(fac_warmup_size+1)]\\n    for i in range(2,fac_warmup_size):\\n        factorial_modP[i]= (factorial_modP[i-1]*i) % MOD\\n    fac_warmup = True\\n\\ndef InverseEuler(n,MOD):\\n    return pow(n,MOD-2,MOD)\\n\\ndef nCr(n, r, MOD):\\n    nonlocal fac_warmup,factorial_modP\\n    if not fac_warmup:\\n        warm_up_fac(MOD)\\n        fac_warmup = True\\n    return (factorial_modP[n]*((pow(factorial_modP[r], MOD-2, MOD) * pow(factorial_modP[n-r], MOD-2, MOD)) % MOD)) % MOD\\n\\ndef test_print(*args):\\n    if testingMode:\\n        print(args)\\n\\ndef display_list(list1, sep=\\\" \\\"):\\n    stdout.write(sep.join(map(str, list1)) + \\\"\\\\n\\\")\\n\\ndef get_int():\\n    return int(stdin.readline().strip())\\n\\ndef get_tuple():\\n    return map(int, stdin.readline().split())\\n\\ndef get_list():\\n    return list(map(int, stdin.readline().split()))\\nimport heapq,itertools\\npq = []                         # list of entries arranged in a heap\\nentry_finder = {}               # mapping of tasks to entries\\nREMOVED = '<removed-task>' \\ndef add_task(task, priority=0):\\n    'Add a new task or update the priority of an existing task'\\n    if task in entry_finder:\\n        remove_task(task)\\n    count = next(counter)\\n    entry = [priority, count, task]\\n    entry_finder[task] = entry\\n    heapq.heappush(pq, entry)\\n\\ndef remove_task(task):\\n    'Mark an existing task as REMOVED.  Raise KeyError if not found.'\\n    entry = entry_finder.pop(task)\\n    entry[-1] = REMOVED\\n\\ndef pop_task():\\n    'Remove and return the lowest priority task. Raise KeyError if empty.'\\n    while pq:\\n        priority, count, task = heapq.heappop(pq)\\n        if task is not REMOVED:\\n            del entry_finder[task]\\n            return task\\n    raise KeyError('pop from an empty priority queue')\\nmemory = dict()\\ndef clear_cache():\\n    nonlocal memory\\n    memory = dict()\\ndef cached_fn(fn, *args):\\n    nonlocal memory\\n    if args in memory:\\n        return memory[args]\\n    else:\\n        result = fn(*args)\\n        memory[args] = result\\n        return result\\n\\n\\n# -------------------------------------------------------------- MAIN PROGRAM\\nTestCases = False\\ntestingMode = False\\nfac_warmup_size = 10**5+100\\noptimiseForReccursion = True #Can not be used clubbed with TestCases\\n\\ndef main():\\n    n, m = get_tuple()\\n    li = get_list()\\n    li.sort(reverse=True)\\n    for i in range(1,n+1):\\n        curr = sum(li[:i]) #Replce with prefix sum\\n        c = -1\\n        for j in range(i,n):\\n            if li[j]-j//i>0:\\n                curr+=li[j]-j//i\\n        if curr>=m:\\n            print(i)\\n            return\\n    print(-1)\\n\\n# --------------------------------------------------------------------- END=\\n\\n\\nif TestCases: \\n    for _ in range(get_int()): \\n        cProfile.run('main()') if testingMode else main() \\nelse: (cProfile.run('main()') if testingMode else main()) if not optimiseForReccursion else threading.Thread(target=main).start()\", \"n,m=list(map(int,input().split()))\\narr=list(map(int,input().split()))\\nans=0\\narr.sort(reverse=True)\\nflag=0\\nfor i in range(1,101):\\n\\tdays=i\\n\\tinterval=n//i\\n\\ttemp=n%i\\n\\ttempans=0\\n\\tj=0\\n\\tcount=0\\n\\twhile(j<=n):\\n\\t\\tk=j\\n\\t\\twhile(k<min(j+i,n)):\\n\\t\\t\\ttempans+=max(arr[k]-count,0)\\n\\t\\t\\tk+=1\\n\\t\\tj+=i\\n\\t\\tcount+=1\\n\\tif(tempans>=m):\\n\\t\\t\\tprint(i)\\n\\t\\t\\tflag=1\\n\\t\\t\\treturn\\nif(flag==0):\\n\\tprint(-1)\\n\\n\\n\", \"n, m = map(int, input().split())\\ncoffees = sorted(map(int, input().split()), reverse=True)\\ntotal = sum(coffees)\\n\\nif total < m:\\n    print(-1)\\n    return\\n\\nfor div in range(1, n):\\n    a = [0] * div\\n    index = 0\\n    for pena in range(n):\\n        for d in range(div):\\n            if coffees[index] <= pena:\\n                break\\n            a[d] += coffees[index] - pena\\n            index += 1\\n\\n            if index >= n or coffees[index] <= pena:\\n                break\\n        if index >= n or coffees[index] <= pena:\\n            break\\n\\n    if sum(a) >= m:\\n        print(div)\\n        return\\n\\nprint(n)\", \"n, m = map(int, input().split())\\na = input().split()\\na = [int(i) for i in a]\\n\\ns = sum(a)\\nif s < m:\\n    print(-1)\\nelif s == m:\\n    print(n)\\nelse:\\n    a.sort(reverse=True)\\n    # print(a)\\n    for day in range(1, n + 1):\\n        coffee = [0 for _ in range(day)]\\n        paper = [0 for _ in range(day)]\\n        i = 0\\n        while i < n:\\n            if a[i] - coffee[i % day] > 0:\\n                paper[i % day] += a[i] - coffee[i % day]\\n                coffee[i % day] += 1\\n            i += 1\\n        # print(coffee, paper)\\n        if sum(paper) >= m:\\n            print(day)\\n            return\", \"n, m = map(int, input().split())\\naa = list(map(int, input().split()))\\naa.sort()\\n# n^3\\u3067\\u3067\\u304d\\u308b(\\u4e00\\u5fdc)\\n# i\\u65e5\\u3067\\u3067\\u304d\\u308b\\u304b\\u3069\\u3046\\u304b\\n# \\u3067\\u304d\\u308b\\u3060\\u3051\\u5747\\u4e00\\u306b\\u4e26\\u3079\\u305f\\u307b\\u3046\\u304c\\u826f\\u3044\\n# j\\u500b\\u4f7f\\u3063\\u3066\\u3067\\u304d\\u308b\\u304b\\nfor i in range(1,n+1):\\n    for j in range(1,n+1):\\n        ans = 0\\n        cnt = 0\\n        for k in range(j):\\n            now = aa[n-j+k]\\n            ans += max(0, now - cnt//i)\\n            cnt += 1\\n        # m\\u30da\\u30fc\\u30b8\\u3092\\u8d85\\u3048\\u305f\\u3068\\u304d\\n        if ans >= m:\\n            print(i)\\n            return\\nprint(-1)\", \"n, m = list(map(int, input().split()))\\na = list(map(int, input().split()))\\n\\n\\ndef proc(n, m, a):\\n    # if m > sum(a):\\n    #     return -1\\n    a = list(sorted(a, reverse=True))\\n    for i in range(1, n + 1):  # check if i is valid days\\n\\n        sub_m = [0] * i\\n        sub_c = [0] * i\\n        # sub_l = [list() for _ in range(i)]\\n        for j in range(n):\\n            pos = j % i\\n            sub_m[pos] += max(0, a[j] - sub_c[pos])\\n            # sub_l[pos].append(max(0, a[j] - sub_c[pos]))\\n            sub_c[pos] += 1\\n\\n        if sum(sub_m) >= m:\\n            return i\\n    return -1\\n\\n\\nprint(proc(n, m, a))\\n\", \"n, m = [int(n) for n in input().split()]\\na = sorted([int(n) for n in input().split()])\\n\\nans = 0\\nif m > sum(a):\\n        ans = -1\\nelse:\\n        for i in range(1, n + 1):\\n                for j in range(1, n + 1):\\n                        fold = j // i\\n                        amari = j % i\\n                        suma = sum(a[-1*j:]) - ((fold - 1) * fold // 2) * i - amari * fold\\n                        if suma >= m:\\n                                ans = i\\n                                break\\n                if ans > 0:\\n                        break\\n\\nprint(ans)\\n\\n\\n\\n\", \"# -*- coding: utf-8 -*-\\n# @Time    : 2019/2/20 0:12\\n# @Author  : LunaFire\\n# @Email   : gilgemesh2012@gmail.com\\n# @File    : D1. Coffee and Coursework (Easy version).py\\n\\n\\ndef main():\\n    n, m = map(int, input().split())\\n    a = list(map(int, input().split()))\\n    a.sort(reverse=True)\\n    c = a.copy()\\n    for i in range(1, n):\\n        c[i] = c[i] + c[i - 1]\\n    # print(c)\\n\\n    dp = [[0] * n for _ in range(n)]\\n    # print('1st:')\\n    for i in range(n):\\n        dp[0][i] = max(0, c[i] - (1 + i) * i // 2)\\n        if dp[0][i] >= m:\\n            print(1)\\n            return\\n    # print(*dp[0])\\n\\n    for i in range(1, n):\\n        for j in range(i, n):\\n            for k in range(i - 1, j):\\n                num = j - k - 1\\n                dp[i][j] = max(dp[i][j], dp[i - 1][k] + c[j] - c[k] - (1 + num) * num // 2)\\n            if dp[i][j] >= m:\\n                print(i + 1)\\n                return\\n\\n    print(-1)\\n\\n\\ndef __starting_point():\\n    main()\\n__starting_point()\", \"n, m = map(int, input().split())\\na = list(map(int, input().split()))\\na.sort()\\na.reverse()\\na = a + [0] * 100\\nif sum(a) < m:\\n    print(-1)\\nelse:\\n    for ans in range(1, n + 1):\\n        p = 0\\n        for i in range((n+ans-1)//ans):\\n            for j in range(ans):\\n                p += max(0, a[i * ans + j] - i)\\n        if p >= m:\\n            print(ans)\\n            break\", \"n,m = list(map(int,input().split()))\\na = list(map(int,input().split()))\\nans=1\\nsu = sum(a)\\na.sort(reverse=True)\\ns = [0]*n\\ns[0] = a[0]\\nfor i in range(1,n):\\n    s[i] = s[i-1]+a[i]\\n\\ndef pos(d):\\n    i=d\\n    while i<=n:\\n        k = i//d\\n        neg = k*i-((k*(k+1))//2)*d\\n        if(s[i-1]-neg >= m):\\n            return True\\n        i+=1\\n    return False\\n\\n\\n\\nif(su < m):\\n    ans = -1\\n    print(ans)\\n\\nelse:\\n    first = 0\\n    last = n\\n\\n    while first<last-1:\\n        midpoint = (first + last)//2\\n        if pos(midpoint):\\n            last = midpoint\\n        else:\\n            first = midpoint\\n\\n    print(last)\\n\", \"n, m=(int(i) for i in input().split())\\nL=[int(i) for i in input().split()]\\np=0\\nt=1\\nL.sort()\\nfor i in L:\\n   p+=i\\nif p<m:\\n    print(-1)\\n    t=0\\nelse:\\n    for i in range(n):\\n        s=0\\n        for j in range(n//(i+1)):\\n            s+=j\\n            g=j\\n        s=s*(i+1)+(g+1)*(n%(i+1))\\n        if s+m<=p:\\n            mm=i+1\\n            break\\nfor u in range(len(L)):\\n    L=L[1:]\\n    n=n-1\\n    p=0\\n    #print(L)\\n    for i in L:\\n        p+=i\\n    if p>=m:\\n        for i in range(n):\\n            s=0\\n            for j in range(n//(i+1)):\\n                s+=j\\n                g=j\\n            s=s*(i+1)+(g+1)*(n%(i+1))\\n            if s+m<=p:\\n                if i+1<mm:\\n                    mm=i+1\\n                break\\nif t:\\n    print(mm)\\n\\n\\n        \\n    \\n\", \"n, m = list(map(int, input().split()))\\na = list(map(int, input().split()))\\nasum = sum(a)\\nif m > asum:\\n    print(-1)\\nelse:\\n    a.sort(reverse = True)\\n    for i in range(1, 101):\\n        task = 0\\n        for j in range(n):\\n            task += max(0, a[j] - j//i)\\n        if task >= m:\\n            print(i)\\n            break\\n\", \"def check(arr,d,mm):\\n\\tss=0\\n\\tk=-1\\n\\tfor i in range(n):\\n\\t\\tif (i)%d==0:\\n\\t\\t\\t# print(\\\"i is \\\",i)\\n\\t\\t\\tk+=1\\n\\t\\t# print(\\\"k is \\\",k)\\n\\t\\tss+=max(0,arr[i]-k)\\n\\tif ss>=mm:\\n\\t\\treturn True\\n\\telse:\\n\\t\\treturn False\\nn,m=map(int,input().split())\\narr=list(map(int,input().split()))\\narr.sort(reverse=True)\\ns=1 \\ne=n \\nans=1000000000000000000000\\nwhile s<=e:\\n\\tmid=(s+e)//2\\n\\tif check(arr,mid,m):\\n\\t\\tans=min(ans,mid)\\n\\t\\te=mid-1\\n\\telse:\\n\\t\\ts=mid+1\\nif ans==1000000000000000000000:\\n\\tans=-1\\nprint(ans)\", \"import io, sys, atexit, os\\n\\nimport math as ma\\nfrom decimal import Decimal as dec\\nfrom itertools import permutations\\n\\n\\ndef li ():\\n\\treturn list (map (int, input ().split ()))\\n\\n\\ndef num ():\\n\\treturn map (int, input ().split ())\\n\\n\\ndef nu ():\\n\\treturn int (input ())\\n\\n\\ndef find_gcd ( x, y ):\\n\\twhile (y):\\n\\t\\tx, y = y, x % y\\n\\treturn x\\n\\n\\ndef solve ():\\n\\tt = 1\\n\\tfor it in range (t):\\n\\t\\tn,m = num ()\\n\\t\\ta = li ()\\n\\t\\ta.sort(reverse = True)\\n\\t\\tlo=1\\n\\t\\thi=n\\n\\t\\tans=-1\\n\\t\\twhile(lo<=hi):\\n\\t\\t\\tmid=(lo+hi)//2\\n\\t\\t\\tpp=0\\n\\t\\t\\tss=0\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tif (i % mid == 0 and i != 0):\\n\\t\\t\\t\\t\\tpp += 1\\n\\t\\t\\t\\tss+=max(a[i]-pp,0)\\n\\t\\t\\tif(ss>=m):\\n\\t\\t\\t\\thi=mid-1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tlo=mid+1\\n\\t\\tif(lo==n+1):\\n\\t\\t\\tprint(-1)\\n\\t\\telse:\\n\\t\\t\\tprint(lo)\\n\\n\\ndef __starting_point():\\n\\tsolve ()\\n__starting_point()\", \"\\nn,m = list(map(int,input().strip().split()))\\n\\narr = list(map(int,input().strip().split()))\\n\\narr = sorted(arr,reverse=True)\\n\\nlow = 1\\nhigh = n\\n#print(arr)\\ndef check(k,m):\\n    #print(m)\\n    #print(m)\\n    if m>0:\\n        l = 0\\n        z = 0\\n        for i in range(n):\\n            m-=max(0,arr[i]-(l))\\n            z+=1\\n            if z==k:\\n                z = 0\\n                l+=1\\n            \\n    #print(m)\\n    if m<=0:\\n        return 1\\n    else:\\n        return 0\\nans = []\\nwhile high >= low:\\n    \\n    mid = low+(high-low)//2\\n    #print(low,high,mid)\\n    if check(mid,m):\\n        ans.append(mid)\\n        high = mid-1\\n    else:\\n        low = mid+1\\n#print(ans)\\nif len(ans)>0:\\n    print(min(ans))\\nelse:\\n    print(-1)\\n\", \"import sys\\n\\nn,m=list(map(int,input().split()))\\nA=list(map(int,input().split()))\\n\\nif sum(A)<m:\\n    print(-1)\\n    return\\n\\nA.sort(reverse=True)\\n\\nMIN=1\\nMAX=n\\n\\nwhile MIN!=MAX:\\n    d=(MIN+MAX)//2\\n\\n\\n    ANS=0\\n    j=0\\n    count=0\\n    for a in A:\\n        if a<=j:\\n            continue\\n        \\n        ANS+=(a-j)\\n        count+=1\\n\\n        if count==d:\\n            j+=1\\n            count=0\\n\\n    #print(d,ANS)\\n\\n    if ANS>=m:\\n        MAX=d\\n    else:\\n        MIN=d+1\\nprint(MIN)\\n            \\n\", \"nb_cups, nb_task = [int(x) for x in input().split()]\\ncaffines = sorted([int(x) for x in input().split()], reverse=True)\\nif nb_task > sum(caffines):\\n    print(-1)\\nelse:    \\n    for days in range(1, 101):\\n        task_done = 0\\n        for curr in range(nb_cups):\\n            task_done += max(0, caffines[curr] - curr // days)\\n        if task_done >= nb_task:\\n            print(days)\\n            break\\n\", \"n,m = [int(x) for x in input().split()]\\n\\nl = [int(x) for x in input().split()]\\nsumm = sum(l)\\nresult = 0\\n\\ndef find(x) :\\n    # x\\u00e9t n\\u1ebfu u\\u1ed1ng trong x ng\\u00e0y k\\u1ecbp l\\u00e0m\\n    # th\\u1ee9 t\\u1ef1 u\\u1ed1ng trong m\\u1ed7i ng\\u00e0y \\u01b0u ti\\u00ean c\\u1ed1c l\\u1edbn tr\\u01b0\\u1edbc . ex : v\\u1edbi x = 2 : a1x1 > a1x2 > a2x1 >a2x2 >...\\n    s = 0\\n    pos_count = 0\\n    day_count = 0\\n\\n    for i in l :\\n        s += max(0,i-pos_count)\\n        day_count+=1\\n        if day_count == x :\\n            day_count = 0\\n            pos_count+=1\\n\\n    if s < m :\\n        return 0\\n    else :\\n        return x\\n\\ndef binary_search(lf,r) :\\n    nonlocal result\\n    mid = int((lf+r)/2)\\n\\n    rs = find(mid)\\n\\n    if lf==r :\\n        result = rs\\n    elif lf == r-1 :\\n        if rs :\\n            result = rs\\n        else :\\n            binary_search(r,r)\\n    else :\\n        if rs :\\n            binary_search(lf,mid)\\n        else :\\n            binary_search(mid,r)\\n\\n\\nif summ<m:\\n    print('-1')\\nelif summ == m :\\n    print(n)\\n# elif summ - sum(range(n)) == m:\\n#     print('1')\\nelse :\\n    l= sorted(l,reverse=True)\\n    binary_search(1,n)\\n    print(result)\\n\", \"def check_possibility(days, m, coffee):\\n    sum_coffee = 0\\n    for i, cup in enumerate(coffee):\\n        tax = i // days\\n        if sum_coffee >= m or tax >= cup:\\n            break\\n        sum_coffee += cup - tax\\n    return sum_coffee >= m\\n\\n\\nn, m = list(map(int, input().split()))\\ncoffee = sorted(map(int, input().split()), reverse=True)\\n\\nbad = 0\\ngood = len(coffee)\\n\\nwhile good - bad > 1:\\n    days = (bad + good) // 2\\n    if check_possibility(days, m, coffee):\\n        good = days\\n    else:\\n        bad = days\\n\\npossible = check_possibility(good, m, coffee)\\nprint(good if possible else -1)\\n\", \"import sys\\nn , m = map(int,input().split())\\nl = list(map(int,input().split()))\\nl.sort(reverse = True)\\n\\nleft = 1\\nright = n+1\\n\\nans = 10**18 + 1\\nwhile left != right:\\n    mid = (left+right)//2\\n    #print(mid,left,right)\\n    din = 0\\n    kaam = 0\\n    c = 0\\n    for i in l:\\n        if i - din <=0:\\n            break\\n        kaam += i - din\\n        c += 1\\n        if c == mid:\\n            c = 0\\n            din += 1\\n    if kaam >= m:\\n        ans = min(ans,mid)\\n        right = mid\\n    else:\\n        left = mid+1\\n\\nif ans == 10**18+1:\\n    print(-1)\\nelse:\\n    print(ans)\", \"n, m = list(map(int, input().split()))\\n\\nl = list(map(int,input().split()))\\n\\nl.sort(reverse = True)\\n\\nleft = 1\\nright = n\\n\\ndef check(k,m):\\n  if m > 0:\\n    lef = 0\\n    z = 0\\n    for i in range(n):\\n      m -= max(0, l[i]-lef)\\n      z += 1\\n      if z == k:\\n        z = 0\\n        lef += 1\\n  if m <= 0:\\n    return 1\\n  else:\\n    return 0\\n\\nres = []\\n\\nwhile left <= right:\\n  mid = int((left+right)/2)\\n  if check(mid, m):\\n    res.append(mid)\\n    right = mid - 1\\n  else:\\n    left = mid + 1\\nif len(res) > 0:\\n  print(min(res))\\nelse:\\n  print(\\\"-1\\\")\\n\\n\\\"\\\"\\\"\\nn, m = map(int, input().split())\\n\\nl = list(map(int,input().split()))\\n\\ns = sum(l)\\nans = 0\\n\\ndef find(x):\\n  su = 0\\n  days = 0\\n  z = 0\\n\\n  for i in l:\\n    su += max(0, i-z)\\n    days += 1\\n    if days == x:\\n      days = 0\\n      z += 1\\n  if su < m:\\n    return 0\\n  return x\\n\\ndef binary(left, right):\\n  nonlocal ans\\n  mid = int((left+right)/2)\\n  r = find(mid)\\n  if right == left:\\n    ans = r\\n  elif left == right - 1:\\n    if r:\\n      ans = r\\n    else:\\n      binary(r, r)\\n  else:\\n    if r:\\n      binary(left, mid)\\n    else:\\n      binary(mid, right)\\n\\nif s < m:\\n  print(\\\"-1\\\")\\nelif s == m:\\n  print(n)\\nelse:\\n  l.sort(reverse = True)\\n  binary(1,n)\\n  print(ans)\\nprint(ans)\\n\\\"\\\"\\\"\\n\", \"from math import ceil\\ndef check(p):\\n    sm = 0\\n    k = 0\\n    d = 0\\n    for i in range(ceil(len(a)/p)):\\n        for j in range(p):\\n            if k < len(a):\\n                sm += max(0, a[k]-d)\\n                k+=1\\n        d += 1\\n    return sm >= m\\n\\nn,m=list(map(int,input().split()))\\na=[int(x) for x in input().split()]\\na.sort(reverse=True)\\n\\nl=1\\nr=len(a)\\nif sum(a) < m:\\n    print(-1)\\nelse:\\n    while(l < r):\\n        mid = (l + r) // 2\\n\\n        if check(mid):\\n            r = mid\\n        else:\\n            l = mid+1\\n    print(l)\\n\", \"n, m = list(map(int, input().split()))\\nl = list(map(int, input().split()))\\nl.sort(reverse=True)\\nans = []\\ndef bin(s):\\n    tmp = [[] for k in range(s)]\\n    cur = s\\n    tr = 0\\n    for i in range(n):\\n        if (cur == s):\\n            cur = 0\\n        tmp[cur].append(l[i])\\n        cur += 1\\n    for i in range(s):\\n        for k in range(len(tmp[i])):\\n            tr += max(tmp[i][k] - k, 0)\\n    if tr >= m:\\n        return 1\\n    else:\\n        return 0\\nuk2 = n\\nuk1 = 1\\nwhile (uk2 - uk1 > 1):\\n    if bin((uk2 + uk1) // 2):\\n        uk2 = (uk2 + uk1) // 2\\n    else:\\n        uk1 = (uk2 + uk1) // 2\\nif bin(uk1):\\n    print(uk1)\\nelif bin(uk2):\\n    print(uk2)\\nelse:\\n    print(-1)\"]", "task": "apps", "difficulty": "introductory", "split": "test", "transformation_type": "vanilla"}