{"qid": 4037, "orig_input": "The only difference between easy and hard versions is that you should complete all the projects in easy version but this is not necessary in hard version.\n\nPolycarp is a very famous freelancer. His current rating is $r$ units.\n\nSome very rich customers asked him to complete some projects for their companies. To complete the $i$-th project, Polycarp needs to have at least $a_i$ units of rating; after he completes this project, his rating will change by $b_i$ (his rating will increase or decrease by $b_i$) ($b_i$ can be positive or negative). Polycarp's rating should not fall below zero because then people won't trust such a low rated freelancer.\n\nPolycarp can choose the order in which he completes projects. Furthermore, he can even skip some projects altogether.\n\nTo gain more experience (and money, of course) Polycarp wants to choose the subset of projects having maximum possible size and the order in which he will complete them, so he has enough rating before starting each project, and has non-negative rating after completing each project.\n\nYour task is to calculate the maximum possible size of such subset of projects.\n\n\n-----Input-----\n\nThe first line of the input contains two integers $n$ and $r$ ($1 \\le n \\le 100, 1 \\le r \\le 30000$) \u2014 the number of projects and the initial rating of Polycarp, respectively.\n\nThe next $n$ lines contain projects, one per line. The $i$-th project is represented as a pair of integers $a_i$ and $b_i$ ($1 \\le a_i \\le 30000$, $-300 \\le b_i \\le 300$) \u2014 the rating required to complete the $i$-th project and the rating change after the project completion.\n\n\n-----Output-----\n\nPrint one integer \u2014 the size of the maximum possible subset (possibly, empty) of projects Polycarp can choose.\n\n\n-----Examples-----\nInput\n3 4\n4 6\n10 -2\n8 -1\n\nOutput\n3\n\nInput\n5 20\n45 -6\n34 -15\n10 34\n1 27\n40 -45\n\nOutput\n5\n\nInput\n3 2\n300 -300\n1 299\n1 123\n\nOutput\n3", "input": "The only difference between easy and hard versions is that you should complete all the projects in easy version but this is not necessary in hard version.\n\nPolycarp is a very famous freelancer. His current rating is $r$ units.\n\nSome very rich customers asked him to complete some projects for their companies. To complete the $i$-th project, Polycarp needs to have at least $a_i$ units of rating; after he completes this project, his rating will change by $b_i$ (his rating will increase or decrease by $b_i$) ($b_i$ can be positive or negative). Polycarp's rating should not fall below zero because then people won't trust such a low rated freelancer.\n\nPolycarp can choose the order in which he completes projects. Furthermore, he can even skip some projects altogether.\n\nTo gain more experience (and money, of course) Polycarp wants to choose the subset of projects having maximum possible size and the order in which he will complete them, so he has enough rating before starting each project, and has non-negative rating after completing each project.\n\nYour task is to calculate the maximum possible size of such subset of projects.\n\n\n-----Input-----\n\nThe first line of the input contains two integers $n$ and $r$ ($1 \\le n \\le 100, 1 \\le r \\le 30000$) \u2014 the number of projects and the initial rating of Polycarp, respectively.\n\nThe next $n$ lines contain projects, one per line. The $i$-th project is represented as a pair of integers $a_i$ and $b_i$ ($1 \\le a_i \\le 30000$, $-300 \\le b_i \\le 300$) \u2014 the rating required to complete the $i$-th project and the rating change after the project completion.\n\n\n-----Output-----\n\nPrint one integer \u2014 the size of the maximum possible subset (possibly, empty) of projects Polycarp can choose.\n\n\n-----Examples-----\nInput\n3 4\n4 6\n10 -2\n8 -1\n\nOutput\n3\n\nInput\n5 20\n45 -6\n34 -15\n10 34\n1 27\n40 -45\n\nOutput\n5\n\nInput\n3 2\n300 -300\n1 299\n1 123\n\nOutput\n3", "test_cases": {"inputs": ["3 4\n4 6\n10 -2\n8 -1\n", "5 20\n45 -6\n34 -15\n10 34\n1 27\n40 -45\n", "3 2\n300 -300\n1 299\n1 123\n", "20 15000\n57 -299\n354 -298\n156 -298\n102 -298\n862 -300\n134 -300\n1446 -289\n23 -298\n1012 -298\n901 -300\n97 -300\n172 -297\n108 -265\n209 -294\n307 -300\n28 -295\n1021 -295\n666 -296\n83 -298\n469 -298\n", "20 1000\n37 -298\n112 -288\n29 -298\n27 -298\n334 -295\n723 -298\n139 -286\n375 -296\n19 -296\n319 -300\n323 -295\n44 -300\n237 -296\n100 -296\n370 -300\n285 -299\n359 -300\n71 -297\n459 -299\n745 -298\n", "20 30000\n129 -290\n86 -295\n540 -300\n814 -294\n705 -290\n194 -300\n332 -297\n670 -299\n64 -299\n32 -295\n507 -295\n302 -299\n493 -289\n175 -295\n312 -286\n337 -300\n200 -292\n274 -300\n86 -285\n559 -299\n", "20 15000\n61 65\n160 -175\n40 -283\n285 278\n58 -298\n3 20\n232 146\n226 -97\n349 37\n462 -37\n372 13\n1949 -122\n58 233\n306 -29\n327 -213\n306 134\n136 259\n398 101\n794 -90\n613 232\n", "20 1000\n176 -209\n12 -75\n355 -101\n407 -43\n574 78\n11 164\n40 44\n64 110\n83 132\n606 262\n958 -63\n791 -249\n93 -253\n704 218\n104 -289\n258 -1\n20 46\n332 -132\n454 -220\n390 159\n", "20 30000\n636 -231\n284 -28\n154 -175\n90 -127\n277 159\n272 -87\n136 -253\n233 181\n488 275\n56 -90\n280 132\n340 12\n151 117\n150 -232\n92 -284\n328 -113\n248 -53\n99 211\n609 166\n13 -35\n", "20 15000\n74 292\n68 300\n384 296\n1788 297\n58 292\n39 296\n160 278\n155 297\n106 299\n100 289\n137 295\n629 298\n387 284\n320 295\n252 300\n12 294\n103 300\n143 298\n247 296\n243 288\n", "20 1000\n543 293\n215 297\n472 294\n8 295\n74 295\n183 300\n205 296\n361 290\n129 300\n237 298\n494 299\n798 299\n324 297\n37 294\n195 287\n164 295\n90 292\n6 299\n1486 299\n533 291\n", "20 30000\n162 299\n302 297\n114 299\n263 287\n147 300\n754 296\n471 299\n156 297\n407 288\n11 291\n104 291\n196 298\n95 296\n163 282\n164 299\n155 285\n201 298\n200 296\n587 294\n208 296\n", "20 15000\n21696 -290\n24040 -298\n11031 -299\n16426 -294\n26726 -300\n8368 -289\n29904 -296\n17421 -288\n12459 -297\n22433 -300\n6511 -297\n21230 -295\n2628 -299\n3478 -296\n1050 -293\n12981 -294\n27731 -300\n28750 -295\n17774 -299\n21041 -293\n", "20 1000\n11767 -298\n7517 -297\n8012 -296\n17583 -299\n11054 -299\n16840 -286\n28570 -298\n27763 -295\n8165 -290\n20499 -300\n2898 -289\n11552 -299\n7625 -299\n21133 -295\n21327 -298\n28698 -300\n18854 -299\n16349 -300\n17969 -298\n2799 -296\n", "20 30000\n21211 -289\n17405 -277\n15448 -296\n24657 -299\n9058 -293\n24218 -299\n2418 -290\n25590 -289\n6026 -299\n13401 -296\n23863 -297\n6650 -297\n22253 -294\n19099 -300\n14879 -286\n3074 -299\n12613 -293\n21154 -297\n11003 -295\n6709 -294\n", "20 15000\n25338 11\n13574 158\n28567 -110\n4353 -225\n17875 198\n5269 -58\n17354 -275\n367 -176\n17344 65\n5940 57\n14439 -22\n23218 212\n4334 -195\n7842 -59\n22867 169\n13610 -263\n11528 190\n3151 -166\n17123 168\n647 272\n", "20 1000\n9691 -32\n1732 -46\n18638 155\n14421 -125\n14839 244\n2249 77\n13780 4\n2467 232\n1673 -239\n19626 202\n8133 251\n21885 25\n1555 -52\n2851 166\n24925 -222\n6767 36\n29642 -8\n29538 -153\n18088 106\n2075 -232\n", "20 30000\n18658 -168\n24791 -241\n28082 -195\n9979 -78\n25428 217\n3334 9\n18041 -80\n24291 -207\n23325 232\n1004 -113\n5221 151\n25733 -155\n59 83\n15477 -106\n16434 275\n23393 285\n2760 255\n20503 -294\n776 -234\n22836 -82\n", "20 15000\n20035 297\n29425 285\n22551 293\n27098 300\n26229 298\n11006 300\n22593 298\n7933 296\n15862 296\n10588 294\n17897 300\n21301 296\n8547 291\n29214 292\n2391 292\n15630 284\n23472 295\n9369 295\n9044 300\n12731 299\n", "20 1000\n27120 300\n9493 289\n5224 294\n17172 298\n24185 298\n24692 299\n26925 300\n28803 296\n20749 293\n3745 299\n5204 298\n22266 291\n14650 282\n11211 299\n7343 297\n20836 298\n10382 299\n848 300\n23155 298\n29281 293\n", "20 30000\n23518 297\n5050 298\n20780 288\n27784 296\n6581 300\n6070 296\n20219 282\n3658 293\n29433 296\n26723 276\n1985 294\n4954 296\n22409 295\n7859 293\n22800 287\n8468 289\n21913 298\n8355 299\n9086 295\n29422 300\n", "20 15000\n29965 -288\n29788 -295\n29752 -288\n29891 -286\n29802 -295\n29751 -299\n29603 -289\n29907 -296\n29940 -287\n29870 -296\n29757 -298\n29627 -295\n29789 -290\n29841 -279\n29563 -288\n29900 -298\n29901 -297\n29288 -295\n29773 -298\n29886 -288\n", "20 1000\n29609 -290\n29489 -279\n29700 -300\n29879 -300\n29776 -297\n29301 -290\n29493 -297\n29751 -287\n29921 -290\n29715 -300\n29999 -300\n29567 -296\n29826 -298\n29398 -300\n29663 -293\n29669 -298\n29914 -299\n29765 -297\n29027 -300\n29731 -291\n", "20 30000\n29889 -298\n29133 -283\n29949 -296\n29323 -297\n29642 -287\n29863 -299\n29962 -300\n29906 -297\n29705 -295\n29967 -296\n29804 -295\n29886 -295\n29984 -297\n29943 -298\n29711 -300\n29685 -295\n29805 -293\n29994 -292\n29472 -297\n29909 -296\n", "20 15000\n29875 -256\n29935 9\n29852 30\n29474 -175\n29880 -244\n29642 245\n29962 79\n29800 84\n29328 277\n29410 268\n29269 -86\n29280 -30\n29854 89\n29953 -190\n29987 194\n29747 -18\n29694 21\n29972 -268\n29923 288\n29782 187\n", "20 1000\n29531 141\n29892 277\n29544 141\n29825 -194\n29846 164\n29595 25\n28975 -249\n29926 -108\n29920 -99\n29232 -238\n29892 -284\n29757 270\n29828 122\n29925 256\n29656 -128\n29052 -165\n29648 -65\n29713 226\n29903 -110\n29893 117\n", "20 30000\n29872 -55\n29432 182\n29578 50\n29856 -210\n29238 -274\n29988 -110\n29834 252\n29821 220\n29644 230\n29838 -103\n29309 43\n29603 -124\n29464 -265\n29610 261\n29914 -35\n29963 -60\n29916 -121\n29175 264\n29746 293\n29817 105\n", "2 4\n2 -3\n4 -3\n", "3 1\n3 -4\n3 4\n3 4\n", "56 15\n2 -20\n9 14\n33 14\n18 -29\n36 -32\n13 -32\n19 26\n18 -4\n8 -32\n25 -32\n20 -9\n34 -14\n4 -1\n7 -12\n32 -36\n30 -30\n10 -35\n17 -18\n11 -32\n30 -7\n25 30\n1 -11\n13 -6\n15 -1\n38 29\n19 -23\n38 -2\n2 10\n36 23\n12 -28\n36 -38\n15 -33\n25 -34\n7 2\n38 -13\n16 -5\n5 -37\n1 -24\n15 -36\n6 -8\n23 22\n31 13\n37 29\n8 0\n14 28\n34 -30\n24 31\n20 -16\n1 -21\n12 24\n8 -15\n21 16\n4 12\n11 8\n7 -10\n17 -10\n", "11 12\n10 -10\n19 12\n19 -10\n5 -14\n18 -1\n8 -17\n4 -1\n19 0\n13 2\n8 2\n6 -3\n", "9 8\n6 -1\n6 -4\n7 -5\n1 -3\n6 -8\n6 -5\n1 3\n3 -1\n3 -2\n", "20 15000\n30000 288\n29729 296\n29760 292\n29654 300\n29735 293\n29987 297\n29800 299\n29638 300\n29928 300\n29543 290\n29934 281\n29326 299\n29975 296\n29992 300\n29855 293\n29369 298\n29991 300\n29625 300\n29822 298\n29908 295\n", "20 1000\n29965 300\n29944 297\n29787 298\n29608 292\n29944 296\n29917 299\n29762 292\n29106 297\n29861 292\n29414 286\n29486 294\n29780 294\n29720 299\n29375 298\n29896 297\n29832 297\n29805 295\n29690 290\n29858 294\n29901 300\n", "20 30000\n29682 295\n29376 294\n29917 298\n29992 296\n29841 298\n29984 297\n29986 298\n29728 293\n29986 285\n29862 300\n29533 300\n29685 291\n29217 292\n28980 295\n29941 295\n29854 298\n29937 294\n29907 295\n29978 300\n29927 295\n", "50 15000\n142 -300\n20 -298\n560 -300\n1815 -292\n282 -297\n92 -293\n34 -284\n555 -299\n408 -293\n504 -284\n278 -284\n139 -291\n64 -298\n311 -293\n130 -293\n89 -298\n129 -294\n385 -295\n136 -288\n41 -293\n112 -290\n416 -295\n178 -294\n154 -300\n110 -300\n346 -299\n209 -294\n1394 -295\n209 -299\n16 -297\n592 -298\n298 -299\n159 -298\n405 -297\n434 -300\n247 -299\n691 -299\n578 -300\n638 -294\n404 -288\n309 -284\n297 -299\n228 -299\n517 -300\n196 -297\n270 -299\n11 -291\n300 -294\n1617 -286\n253 -284\n", "50 1000\n520 -285\n84 -296\n186 -300\n333 -298\n396 -299\n125 -293\n26 -293\n42 -290\n163 -300\n85 -299\n232 -294\n152 -298\n231 -299\n326 -298\n30 -294\n459 -296\n40 -292\n57 -300\n327 -299\n132 -300\n894 -299\n350 -286\n153 -295\n465 -287\n904 -299\n638 -299\n43 -298\n128 -298\n215 -290\n378 -298\n332 -300\n36 -298\n124 -293\n146 -299\n141 -299\n208 -287\n102 -300\n122 -300\n93 -295\n423 -289\n114 -297\n25 -292\n443 -299\n625 -298\n177 -294\n17 -300\n570 -293\n64 -300\n153 -296\n321 -289\n", "50 30000\n241 -293\n284 -295\n99 -293\n307 -300\n254 -299\n143 -293\n457 -296\n332 -300\n1046 -296\n975 -296\n49 -296\n253 -296\n355 -299\n264 -294\n132 -296\n554 -290\n604 -290\n170 -299\n140 -296\n60 -294\n127 -298\n331 -298\n81 -300\n310 -297\n397 -299\n449 -290\n72 -292\n166 -294\n453 -300\n98 -299\n117 -277\n219 -297\n483 -299\n423 -296\n123 -299\n418 -295\n334 -294\n591 -296\n6 -292\n25 -300\n216 -292\n253 -289\n84 -290\n632 -300\n17 -299\n1017 -288\n107 -298\n748 -289\n130 -293\n122 -299\n", "50 15000\n744 -169\n42 -98\n36 -296\n163 -73\n284 96\n271 -61\n949 -226\n683 2\n268 -138\n205 297\n328 130\n281 -259\n912 -170\n79 -62\n275 -227\n601 95\n107 220\n387 263\n1260 53\n215 -188\n191 279\n459 5\n284 -246\n123 -242\n858 77\n162 78\n219 2\n52 230\n312 72\n114 -10\n179 25\n319 61\n11 28\n94 -271\n153 173\n212 -272\n3 -26\n115 172\n273 -292\n24 195\n42 291\n66 248\n27 -287\n478 -242\n17 130\n591 267\n55 -39\n287 156\n498 -119\n138 119\n", "50 1000\n48 74\n684 197\n134 237\n37 -20\n79 37\n197 -212\n370 54\n577 -195\n329 -50\n963 -81\n85 135\n365 93\n293 -178\n503 -31\n126 -136\n709 -52\n118 153\n19 -260\n305 -260\n619 -35\n72 29\n352 163\n366 -175\n1186 101\n147 268\n235 -225\n591 195\n317 57\n102 244\n255 -204\n135 -21\n9 296\n164 185\n310 -70\n168 -212\n712 24\n299 -224\n401 193\n98 117\n168 -217\n476 -76\n273 -135\n45 61\n55 -40\n1137 84\n278 -89\n120 184\n105 265\n414 152\n69 204\n", "50 30000\n287 135\n119 48\n148 -252\n20 123\n16 16\n63 -232\n452 -25\n716 280\n367 165\n623 244\n247 249\n105 -61\n59 251\n1201 -266\n67 -298\n666 -216\n206 -91\n95 -229\n768 -229\n338 146\n194 271\n52 -252\n442 -68\n203 80\n314 99\n375 -120\n190 -286\n177 269\n343 264\n98 172\n688 -51\n76 -138\n98 -114\n591 172\n9 -27\n1137 -195\n372 273\n623 -11\n190 -265\n1 -17\n132 159\n141 -38\n103 45\n291 -162\n175 85\n125 -143\n124 -87\n182 173\n3 -259\n320 -70\n", "50 15000\n796 297\n44 293\n32 298\n262 297\n81 298\n236 289\n40 291\n501 293\n318 291\n608 285\n85 294\n47 296\n377 295\n13 297\n890 294\n70 300\n370 293\n125 280\n175 296\n1662 295\n157 298\n23 300\n98 300\n110 299\n178 293\n400 287\n130 295\n44 295\n423 295\n248 291\n203 297\n327 296\n19 299\n522 294\n289 293\n106 289\n116 291\n124 300\n53 298\n495 298\n466 292\n15 284\n72 297\n288 299\n548 299\n251 300\n314 287\n374 289\n525 297\n63 275\n", "50 1000\n363 297\n207 294\n180 300\n191 300\n301 298\n17 290\n263 297\n319 283\n377 287\n182 300\n408 300\n106 295\n16 297\n55 296\n28 300\n37 298\n122 284\n39 295\n252 300\n81 285\n138 288\n121 288\n167 298\n7 296\n520 296\n587 298\n240 300\n243 287\n215 293\n454 299\n672 291\n185 298\n41 294\n252 283\n382 296\n53 296\n51 300\n20 289\n112 300\n392 286\n181 300\n662 299\n170 300\n35 297\n325 300\n15 286\n367 290\n25 297\n181 290\n798 286\n", "50 30000\n43 290\n252 300\n349 279\n59 288\n178 294\n128 288\n209 300\n505 293\n34 297\n290 288\n56 289\n407 295\n91 300\n479 291\n480 289\n255 299\n720 300\n178 300\n402 294\n833 299\n4 294\n12 282\n29 293\n159 292\n14 297\n73 298\n481 300\n353 281\n1090 281\n479 293\n331 299\n264 300\n106 300\n109 299\n105 300\n2 293\n280 299\n325 300\n518 293\n8 299\n811 295\n262 290\n26 289\n451 297\n375 298\n265 297\n132 300\n335 299\n70 300\n347 296\n", "14 560\n7020 -160\n9308 -105\n3488 -299\n5875 -244\n564 -22\n1658 -175\n1565 -294\n3371 -295\n365 -28\n9654 -251\n532 -229\n854 -142\n5100 -188\n937 -288\n", "10 10\n1 1\n9 -5\n9 -6\n10 -2\n2 0\n5 5\n2 8\n10 -9\n5 -2\n4 4\n"], "outputs": ["3\n", "5\n", "3\n", "20\n", "3\n", "20\n", "20\n", "20\n", "20\n", "20\n", "20\n", "20\n", "8\n", "0\n", "20\n", "12\n", "0\n", "20\n", "11\n", "1\n", "20\n", "0\n", "0\n", "3\n", "0\n", "0\n", "20\n", "1\n", "0\n", "43\n", "5\n", "6\n", "0\n", "0\n", "20\n", "50\n", "3\n", "50\n", "50\n", "50\n", "50\n", "50\n", "50\n", "50\n", "2\n", "10\n"]}, "solutions": "[\"'''input\\n5 20\\n45 -6\\n34 -15\\n10 34\\n1 27\\n40 -45\\n\\n\\n'''\\nimport sys\\nfrom collections import defaultdict as dd\\n\\nmod=10**9+7\\n\\ndef ri(flag=0):\\n\\tif flag==0:\\n\\t\\treturn [int(i) for i in sys.stdin.readline().split()]\\n\\telse:\\n\\t\\treturn int(sys.stdin.readline())\\n\\n\\nn, r = ri()\\n\\neventspos = []\\neventsneg = []\\nfor i in range(n):\\n\\ttemp =ri()\\n\\tif temp[1]>=0:\\n\\t\\teventspos.append(temp)\\n\\telse:\\n\\t\\teventsneg.append(temp)\\n\\neventspos.sort()\\neventsneg.sort(key = lambda x: x[0]+x[1])\\neventsneg.reverse()\\n\\nstatus =1\\n\\nans=0 \\n\\nfor i in range(len(eventspos)):\\n\\tif eventspos[i][0] <= r:\\n\\t\\tr+= eventspos[i][1]\\n\\t\\tans+=1\\n\\telse:\\n\\t\\tstatus = 0\\n\\n\\ncheck = [0 for i in range(r+1)]\\n\\n#print(eventsneg)\\n\\nfor i in range(len(eventsneg)):\\n\\tfor j in range(eventsneg[i][0] , r+1):\\n\\t\\tif j+eventsneg[i][1]>=0:\\n\\t\\t\\tcheck[j+eventsneg[i][1]] = max(check[j+eventsneg[i][1]] , check[j]+1) \\n\\n\\n\\n# if status and r>=0 and sum(check)==len(check):\\n# \\tprint(\\\"YES\\\")\\n# else:\\n# \\tprint(\\\"NO\\\")\\n\\n#print(eventsneg,eventspos)\\n\\nprint(max(check) + ans\\t)\\n\", \"import sys\\nfrom collections import defaultdict as dd\\n \\nmod=10**9+7\\n \\ndef ri(flag=0):\\n\\tif flag==0:\\n\\t\\treturn [int(i) for i in sys.stdin.readline().split()]\\n\\telse:\\n\\t\\treturn int(sys.stdin.readline())\\n \\n \\nn, r = ri()\\n \\neventspos = []\\neventsneg = []\\nfor i in range(n):\\n\\ttemp =ri()\\n\\tif temp[1]>=0:\\n\\t\\teventspos.append(temp)\\n\\telse:\\n\\t\\teventsneg.append(temp)\\n \\neventspos.sort()\\neventsneg.sort(key = lambda x: x[0]+x[1])\\neventsneg.reverse()\\n \\nstatus =1\\n \\nans=0 \\n \\nfor i in range(len(eventspos)):\\n\\tif eventspos[i][0] <= r:\\n\\t\\tr+= eventspos[i][1]\\n\\t\\tans+=1\\n\\telse:\\n\\t\\tstatus = 0\\n \\n \\ncheck = [0 for i in range(r+1)]\\n \\n#print(eventsneg)\\n \\nfor i in range(len(eventsneg)):\\n\\tfor j in range(eventsneg[i][0] , r+1):\\n\\t\\tif j+eventsneg[i][1]>=0:\\n\\t\\t\\tcheck[j+eventsneg[i][1]] = max(check[j+eventsneg[i][1]] , check[j]+1) \\n \\n \\n \\n# if status and r>=0 and sum(check)==len(check):\\n# \\tprint(\\\"YES\\\")\\n# else:\\n# \\tprint(\\\"NO\\\")\\n \\n#print(eventsneg,eventspos)\\n \\nprint(max(check) + ans)\", \"N, R = [int(x) for x in input().split()]\\nprojects = [[int(x) for x in input().split()] for _ in range(N)]\\npos = []\\nneg = []\\nfor a, b in projects:\\n    if b < 0:\\n        neg.append((a, b))\\n    else:\\n        pos.append((a, b))\\npos.sort()\\nans = 0\\nfor a, b in pos:\\n    if R >= a:\\n        R += b\\n        ans += 1\\nneg.sort(key=sum, reverse=True)\\nmemo = {}\\ndef dp(i, r):\\n    if(i, r) in memo:\\n        return memo[i, r]\\n    if i == len(neg):return 0\\n    a, b = neg[i]\\n    ans  = dp(i+1, r)\\n    if r >= a and r + b >= 0:\\n        ans = max(ans, dp(i+1, r + b) + 1)\\n    memo[i, r] = ans\\n    return ans\\nprint( dp(0, R) + ans  )  \\n\", \"from bisect import bisect_right\\n\\nn,r = map(int, input().split())\\naa = [0]*n\\nbb = [0]*n\\nfor i in range(n):\\n    aa[i], bb[i] = map(int, input().split())\\nppi = [(aa[i], bb[i]) for i in range(n) if bb[i] >= 0]\\nppd = [(max(aa[i], -bb[i]), bb[i]) for i in range(n) if bb[i] < 0]\\nppi.sort()\\ncount = 0\\nfor (a,b) in ppi:\\n    if a > r:\\n        break\\n    r += b\\n    count+=1\\nppd.sort(reverse=True,key=lambda p: p[0] + p[1] )\\ndp = [[0]*(r+1) for _ in range(len(ppd)+1)]\\ndp[0][r] = count\\nfor i,(a,b) in enumerate(ppd):\\n    for v in range(r+1):\\n        if v >= a and v+b >= 0:\\n            dp[i+1][v + b] = max(dp[i+1][v + b], dp[i][v] + 1)\\n        dp[i+1][v] = max(dp[i+1][v], dp[i][v])\\nprint(max(dp[len(ppd)]))\", \"import sys\\ninput = sys.stdin.readline\\n\\nn, r = map(int, input().split())\\nl = []\\nfor _ in range(n):\\n\\tl.append(list(map(int, input().split())))\\np = 0\\nans = 0\\nwhile (p < n):\\n\\tif l[p][0] <= r and l[p][1] >= 0:\\n\\t\\tr += l[p][1]\\n\\t\\tl = l[:p] + l[p + 1:]\\n\\t\\tp = 0\\n\\t\\tn -= 1\\n\\t\\tans += 1\\n\\telse:\\n\\t\\tp += 1\\nif l == []:\\n\\tprint(ans)\\n\\treturn\\nq = len(l)\\nfor i in range(q):\\n\\tl[i][0] = max(l[i][0], -l[i][1])\\nl = sorted(l, key = lambda x: x[0] + x[1])\\nl.reverse()\\n#print(l, r)\\ndp = [[0 for _ in range(r + 1)] for _ in range(q + 1)]\\nfor i in range(q):\\n\\tfor j in range(r + 1):\\n\\t\\t#dp[i][j] = dp[i][j-1]\\n\\t\\tif j >= l[i][0] and 0 <= j + l[i][1] <= r:\\n\\t\\t\\tdp[i+1][j+l[i][1]] = max(dp[i+1][j+l[i][1]], dp[i][j] + 1)\\n\\t\\tdp[i+1][j] = max(dp[i+1][j], dp[i][j])\\n# for i,x in enumerate(dp):\\n# \\tprint(i, *x)\\nprint(max(dp[-1]) + ans)\", \"from sys import stdin\\nfrom sys import setrecursionlimit as SRL; SRL(10**7)\\nrd = stdin.readline\\nrrd = lambda: list(map(int, rd().strip().split()))\\n\\nn,r = rrd()\\n\\n\\npos = []\\nneg = []\\n\\nfor i in range(n):\\n    a,b = rrd()\\n    if b < 0:\\n        neg.append([a,b])\\n    else:\\n        pos.append([a,b])\\n\\npos.sort(key=lambda x: x[0])\\nneg.sort(key=lambda x: x[0]+x[1])\\n\\nans = 0\\n\\nfor a,b in pos:\\n\\n    if r>=a:\\n        r += b\\n        ans += 1\\n    else:\\n        break\\n\\ndp = [[0]*105 for _i in range(60005)]\\n\\nfor i in range(r+10):\\n    for j in range(len(neg)):\\n        if i >= neg[j][0] and i+neg[j][1] >= 0:\\n            if j:\\n                dp[i][j] = max(dp[i][j], dp[i + neg[j][1]][j - 1] + 1,dp[i][j-1])\\n            else:\\n                dp[i][j] = 1\\n        else:\\n            if j:\\n                dp[i][j] = dp[i][j-1]\\n\\n\\nprint(dp[r][len(neg)-1] + ans)\\n\", \"# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\\nfrom sys import stdin, stdout\\nimport math\\nimport copy\\n \\n#T = int(input())\\n#N = int(input())\\n#print(N)\\nN,r = [int(x) for x in stdin.readline().split()]\\n#arr = [int(x) for x in stdin.readline().split()]\\n \\nvisited = [0]*N\\n \\na = [0]*N\\nb = [0]*N\\n \\npos = 0\\n\\ndp = {}\\n \\nfor i in range(N):\\n    arr = [int(x) for x in stdin.readline().split()]\\n    a[i] = arr[0]\\n    b[i] = arr[1]\\n    \\n    if b[i]>=0:\\n        pos += 1\\n\\nvalid = 0\\nfor i in range(pos):\\n    idx = -1\\n    start = 0\\n    gain = -50000\\n    for j in range(N):\\n        # find available and largest gain\\n        # if gain tie, find largest start r\\n        if visited[j]==1 or b[j]<0:\\n            continue\\n            \\n        if b[j]>gain and r>=a[j]:\\n            gain = b[j]\\n            idx = j\\n            start = a[j]\\n        elif b[j]==gain and r>=a[j]:\\n            if a[j]>start:\\n                idx = j\\n                start = a[j]\\n                \\n    if idx==-1:\\n        break\\n    else:\\n        visited[idx] = 1\\n        r += b[idx]\\n        valid = i+1\\n        #print(idx,r)\\n        \\ndp[r] = valid\\ntmp = []\\nfor i in range(N):\\n    if visited[i]==1 or b[i]>=0:\\n        continue\\n    tmp.append((a[i],b[i],i))\\n    \\ntmp.sort(key=lambda e: (e[0]+e[1],e[0]),reverse=True)\\n\\n#print(dp)\\nfor i in range(len(tmp)):\\n    dp_tmp = copy.deepcopy(dp)\\n    \\n    for threshold in dp:\\n        if threshold>=tmp[i][0]:\\n            new_r = threshold + tmp[i][1]\\n            if new_r in dp_tmp:\\n                dp_tmp[new_r] = max(dp[new_r],dp[threshold]+1)\\n            else:\\n                dp_tmp[new_r] = dp[threshold]+1\\n    \\n    #print(dp_tmp)\\n    dp = dp_tmp\\n    \\nres = 0\\n#print(dp)\\nfor key in dp:\\n    if key>=0:\\n        res = max(res,dp[key])\\n    \\nprint(res)\\n    \\n        \\n \\n\", \"n, r = map(int, input().split())\\n\\npt = []\\nnt = []\\nr2 = r\\nresult = 0\\n\\nfor _ in range(n):\\n    a, b = map(int, input().split())\\n    r2 += b\\n    if b >= 0:\\n        pt.append((a, b))\\n    else:\\n        nt.append((a, b))\\n\\npt.sort()\\nnt.sort(key=lambda t: t[1]+t[0], reverse=True)\\n\\nfor a, b in pt:\\n    if r < a:\\n        break\\n    result += 1\\n    r += b\\n\\nk = len(nt)\\nws = [[0]*(k+1) for i in range(r+1)]\\n\\nfor i in range(1, k+1):\\n    for w in range(1, r+1):\\n        a, b = nt[i-1]\\n        if w+b >= 0 and a <= r and ws[r-a][i-1] >= ws[w][i-1]:\\n            ws[w][i] = max(ws[w][i-1], 1+ws[w+b][i-1])\\n        else:\\n            ws[w][i] = ws[w][i-1]\\n\\n\\nresult += ws[r][k]\\n'''\\nprint(*enumerate(nt))\\nprint(r, k)\\nprint(*enumerate(ws), sep='\\\\n')\\n'''\\nprint(result)\", \"n,r=list(map(int,input().split()))\\na=[list(map(int,input().split())) for i in range(n)]\\npos = []\\nneg = []\\nans=0\\nfor x in a:\\n\\tif x[1]>0:\\n\\t\\tpos.append(x)\\n\\telse:\\n\\t\\tneg.append(x)\\npos.sort(key=lambda k: k[0])\\nflag=True\\nfor x in pos:\\n\\tif r>=x[0]:\\n\\t\\tr+=x[1]\\n\\t\\tans+=1\\n\\nneg.sort(key=lambda i: i[0]+i[1],reverse=True)\\narr=[0]*(r+1)\\nfor i in range(len(neg)):\\n\\tfor j in range(neg[i][0],r+1):\\n\\t\\tif j+neg[i][1]>=0:\\n\\t\\t\\tarr[j+neg[i][1]]=max(arr[j+neg[i][1]],arr[j]+1)\\nans+=max(arr)\\nprint(ans)\\n\", \"from collections import namedtuple\\n\\nn, r = list(map(int, input().split()))\\nplus = []\\nminus = []\\nProject = namedtuple('Project', 'value a b')\\nfor _ in range(n):\\n    a, b = list(map(int, input().split()))\\n    if b >= 0:\\n        plus.append((a, b))\\n    else:\\n        minus.append(Project(max(0, a + b), a, b))\\nplus.sort()\\nminus.sort(reverse=True)\\nans = 0\\nfor a, b in plus:\\n    if r >= a:\\n        r += b\\n        ans += 1\\ndp = [[-1 for _ in range(60001)] for _ in range(len(minus) + 1)]\\ndp[0][r] = 0\\nfor i in range(len(dp) - 1):\\n    for j in range(len(dp[0])):\\n        if dp[i][j] == -1:\\n            continue\\n        dp[i + 1][j] = max(dp[i + 1][j], dp[i][j])\\n        if j + minus[i].b >= 0 and minus[i].a <= j:\\n            dp[i + 1][j + minus[i].b] = max(dp[i + 1][j + minus[i].b], dp[i][j] + 1)\\nans += max(dp[-1])\\nprint(ans)\\n\", \"from functools import cmp_to_key\\nfrom operator import itemgetter\\n\\n\\ndef main():\\n    n, r = list(map(int, input().split()))\\n    ps = [tuple(map(int, input().split())) for _ in range(n)]\\n\\n    pos_ps = [(a, b) for a, b in ps if b >= 0]\\n    neg_ps = [(a, b) for a, b in ps if b < 0]\\n\\n    def cmp(a, b):\\n        (aa, ab), (ba, bb) = a, b\\n        return max(aa, max(*b) - ab) - max(ba, max(*a) - bb)\\n\\n    pos_ps.sort(key=itemgetter(0))\\n    neg_ps.sort(key=cmp_to_key(cmp))\\n    del cmp\\n\\n    res = 0\\n    for a, b in pos_ps:\\n        if r >= a:\\n            res += 1\\n            r += b\\n\\n    cur = [r]\\n    for a, b in neg_ps:\\n        nxt = [-1]*(len(cur)+1)\\n        for i, r in enumerate(cur):\\n            if r >= 0:\\n                nxt[i] = max(nxt[i], r)\\n                if r >= a:\\n                    nxt[i+1] = r + b\\n        while nxt[-1] < 0:\\n            nxt.pop()\\n        cur = nxt\\n\\n    print(res + len(cur) - 1)\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"from functools import cmp_to_key\\nfrom operator import itemgetter\\n\\n\\ndef main():\\n    n, r = list(map(int, input().split()))\\n    ps = [tuple(map(int, input().split())) for _ in range(n)]\\n\\n    pos_ps = [(a, b) for a, b in ps if b >= 0]\\n    neg_ps = [(a, b) for a, b in ps if b < 0]\\n\\n    def cmp(a, b):\\n        (aa, ab), (ba, bb) = a, b\\n        return max(aa, max(*b) - ab) - max(ba, max(*a) - bb)\\n\\n    pos_ps.sort(key=itemgetter(0))\\n    neg_ps.sort(key=cmp_to_key(cmp))\\n    del cmp\\n\\n    res = 0\\n    for a, b in pos_ps:\\n        if r >= a:\\n            res += 1\\n            r += b\\n\\n    cur = [r]\\n    for a, b in neg_ps:\\n        nxt = [-1]*(len(cur)+1)\\n        for i, r in enumerate(cur):\\n            if r >= 0:\\n                nxt[i] = max(nxt[i], r)\\n                if r >= a:\\n                    nxt[i+1] = r + b\\n        while nxt[-1] < 0:\\n            nxt.pop()\\n        cur = nxt\\n\\n    print(res + len(cur) - 1)\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"from functools import reduce\\n\\ndef doProject(r, proj, nproj):\\n    count=0\\n    for i in range(len(proj)):\\n        if(proj[i][0]<=r):\\n            r+=proj[i][1]\\n            count+=1\\n        else:\\n            pass\\n\\n    dp=[[0 for j in range(r+1)] for i in range(len(nproj)+1)]\\n    dp[0][r] = count\\n\\n    for i in range(len(nproj)):\\n        for cr in range(r+1):\\n            if(nproj[i][0] <= cr and cr + nproj[i][1] >= 0):\\n                dp[i+1][cr + nproj[i][1]] = max(dp[i+1][cr + nproj[i][1]], dp[i][cr]+1)\\n\\n            dp[i+1][cr] = max(dp[i+1][cr], dp[i][cr])\\n\\n    count = reduce(lambda x,y: max(x,y) , dp[len(nproj)])\\n    \\n    return count\\n\\ndef main():\\n\\n    n, r = map(int, input().rstrip().split())\\n    \\n    proj, nproj = [], []\\n    for _ in range(n):\\n\\n        temp = list(map(int, input().rstrip().split()))\\n\\n        if(temp[1]<0):\\n            nproj.append(temp)\\n        else:\\n            proj.append(temp)\\n\\n    proj.sort()\\n    nproj.sort(reverse=True, key=lambda x: x[0]+x[1])\\n    \\n    ans = doProject(r,proj, nproj)\\n    print(ans)\\n\\n\\ndef __starting_point():\\n    main()\\n__starting_point()\", \"import math\\nimport sys\\nfrom collections import defaultdict\\n\\n# input = sys.stdin.readline\\nnt = lambda: map(int, input().split())\\n\\n\\ndef main():\\n    n, r = nt()\\n    projects = [tuple(nt()) for _ in range(n)]\\n    positive = [t for t in projects if t[1] > 0]\\n    negative = [t for t in projects if t[1] <= 0]\\n\\n    max_pos = 0\\n    for p in sorted(positive):\\n        if p[0] <= r:\\n            r += p[1]\\n            max_pos += 1\\n        else:\\n            break\\n    negative.sort(key=lambda x: -x[0] - x[1])\\n    MAX = 60001\\n    dp = [[-1 for _ in range(MAX)] for _ in range(len(negative)+1)]\\n    dp[0][r] = 0\\n    for i in range(len(negative)):\\n        for j in range(MAX):\\n            if dp[i][j] == -1:\\n                continue\\n            dp[i+1][j] = max(dp[i+1][j], dp[i][j])\\n            if j >= negative[i][0] and j+negative[i][1] >= 0:\\n                dp[i+1][j+negative[i][1]] = max(dp[i+1][j+negative[i][1]], dp[i][j]+1)\\n    max_neg = 0\\n    for i in range(MAX):\\n        max_neg = max(max_neg, dp[len(negative)][i])\\n\\n    print(max_pos + max_neg)\\n\\n\\ndef __starting_point():\\n    main()\\n__starting_point()\", \"from math import *\\n\\nMOD = int(1e9)+7\\n\\ndef nextInt():\\n    return int(input())\\n\\ndef nextInts():\\n    return list(map(int,input().split()))\\n\\ndef YN(x):\\n    return \\\"YES\\\" if x else \\\"NO\\\"\\n\\ndef solve():\\n    n,r = nextInts()\\n    pos = []\\n    neg = []\\n    for i in range(n):\\n        a,b = nextInts()\\n        a = max(a,-b)\\n        if b >= 0:\\n            pos.append((a,b))\\n        else:\\n            neg.append((a,b))\\n    pos.sort(key = lambda x:x[0])\\n    neg.sort(key = lambda x:-(x[0]+x[1]))\\n    ans = 0\\n    for t in pos:\\n        if r >= t[0]:\\n            r += t[1]\\n            ans += 1\\n\\n    dp = [-MOD]*60001\\n    dp[r] = ans\\n\\n    for t in neg:\\n        for j in range(t[0],60001):\\n            dp[j+t[1]] = max(dp[j+t[1]],dp[j]+1)\\n    return max(dp)\\n\\nprint(solve())\\n\\n# q = nextInt()\\n# for i in range(q):\\n#     print(YN(solve()))\\n\", \"# -*- coding: utf-8 -*-\\n\\\"\\\"\\\"\\nCreated on Thu Jan  9 11:12:02 2020\\n\\n@author: Rodro\\n\\\"\\\"\\\"\\n\\ninp = str(input()).split()\\nsize = int(inp[0])\\nr = int(inp[1])\\n\\npos = []\\nneg = []\\nfor i in range(size):\\n    inp = str(input()).split()\\n    a = int(inp[0])\\n    b = int(inp[1])\\n    if b >= 0: pos.append((a, b))\\n    else: neg.append((a,b))\\npos = sorted(pos)\\nprojects = 0\\nfor ab in pos:\\n    a, b = ab\\n    if r >= a:\\n        r += b\\n        projects += 1\\n    else: break\\n\\nneg = sorted(neg, key = lambda ab: ab[0] + ab[1], reverse = True)\\nn = len(neg)\\ndp = [[0]*(r + 1) for _ in range(n + 1)]\\ndp[0][r] = projects\\nfor i in range(0, n):\\n    for j in range(0, r + 1):\\n        if j >= neg[i][0] and j + neg[i][1] >= 0:\\n            dp[i + 1][j + neg[i][1]] = max(dp[i + 1][j + neg[i][1]], dp[i][j] + 1)\\n        dp[i + 1][j] = max(dp[i + 1][j], dp[i][j])\\n\\nprint(max(dp[n]))\", \"#https://codeforces.com/contest/1203/problem/F2 \\n\\nn, r = list(map(int, input().split()))\\narr  = [list(map(int, input().split())) for _ in range(n)] \\n\\ndef solve1(cur, arr):\\n    cnt=0\\n\\n    while len(arr) > 0:\\n        max_inc = -9999\\n        choose  = None \\n        for a, b in arr:\\n            if cur >= a and max_inc < b:\\n                max_inc = b\\n                choose  = a\\n                \\n        if choose is None:\\n            flg=False\\n            break\\n        \\n        cnt+=1\\n        cur+=max_inc\\n        arr.remove([choose, max_inc])\\n\\n    return cur, cnt\\n\\narr1 = [[x, y] for x, y in arr if y >= 0]\\narr2 = [[x, y] for x, y in arr if y <  0]\\n\\nr, cnt = solve1(r, arr1) \\nn      = len(arr2) \\narr2   = [[]] + sorted(arr2, key=lambda x:x[0]+x[1], reverse=True) \\ndp     = [[-1] * (n+1) for _ in range(n+1)]\\n\\nfor i in range(n+1):\\n    dp[i][0] = r\\n    \\nfor i in range(1, n+1):\\n    for j in range(1, i+1):\\n        dp[i][j] = dp[i-1][j]\\n        if dp[i-1][j-1] >= arr2[i][0] and dp[i-1][j-1] + arr2[i][1] >= 0:\\n            dp[i][j] = max(dp[i][j], dp[i-1][j-1]+arr2[i][1])\\n            \\nans = 0            \\nfor j in range(n+1):\\n    if dp[n][j] >= 0:\\n        ans = j\\n\\nprint(ans+cnt)        \\n\\n#3 4\\n#4 6\\n#10 -2\\n#8 -1\\n\", \"n, r = list(map(int, input().split()))\\na = []\\ncnt = 0\\nfor i in range(n):\\n    a.append([int(j) for j in input().split()])\\nflag = True\\nwhile flag:\\n    flag = False\\n    for i in a:\\n        if r >= i[0] and i[1] >= 0:\\n            flag = True\\n            r += i[1]\\n            cnt += 1\\n            a.remove(i)\\n            break\\na = sorted(a, key=lambda x: x[0] + x[1])\\ndp = [[0] * (r + 1) for i in range(len(a) + 1)]\\nfor i in range(len(a)):\\n\\tfor j in range(r + 1):\\n\\t\\tdp[i][j] = dp[i - 1][j]\\n\\t\\tif j >= a[i][0] and j + a[i][1] >= 0:\\n\\t\\t\\tdp[i][j] = max(dp[i][j], dp[i - 1][j + a[i][1]] + 1)\\nprint(cnt + dp[len(a) - 1][r])\\n#print(dp, a)\\n\", \"n, r = list(map(int, input().split()))\\na = []\\ncnt = 0\\nfor i in range(n):\\n    a.append([int(j) for j in input().split()])\\nflag = True\\nwhile flag:\\n    flag = False\\n    for i in a:\\n        if r >= i[0] and i[1] >= 0:\\n            flag = True\\n            r += i[1]\\n            cnt += 1\\n            a.remove(i)\\n            break\\na = sorted(a, key=lambda x: x[0] + x[1])\\ndp = [[0] * (r + 1) for i in range(len(a) + 1)]\\nfor i in range(len(a)):\\n\\tfor j in range(r + 1):\\n\\t\\tdp[i][j] = dp[i - 1][j]\\n\\t\\tif j >= a[i][0] and j + a[i][1] >= 0:\\n\\t\\t\\tdp[i][j] = max(dp[i][j], dp[i - 1][j + a[i][1]] + 1)\\nprint(cnt + dp[len(a) - 1][r])\\n#print(dp, a)\\n\", \"z, r = list(map(int, input().split()))\\na = []\\ncnt = 0\\nfor i in range(z):\\n    a.append([int(j) for j in input().split()])\\nflag = True\\nwhile flag:\\n    flag = False\\n    for i in a:\\n        if r >= i[0] and i[1] >= 0:\\n            flag = True\\n            r += i[1]\\n            cnt += 1\\n            a.remove(i)\\n            break\\na = sorted(a, key=lambda x: x[0] + x[1])\\ndp = [[0] * (r + 1) for i in range(len(a) + 1)]\\nfor i in range(len(a)):\\n\\tfor j in range(r + 1):\\n\\t\\tdp[i][j] = dp[i - 1][j]\\n\\t\\tif j >= a[i][0] and j + a[i][1] >= 0:\\n\\t\\t\\tdp[i][j] = max(dp[i][j], dp[i - 1][j + a[i][1]] + 1)\\nprint(cnt + dp[len(a) - 1][r])\\n#print(dp, a)\\n\", \"N, R = [int(x) for x in input().split()]\\nprojects = [[int(x) for x in input().split()] for _ in range(N)]\\npos = []\\nneg = []\\nfor a, b in projects:\\n    if b < 0:\\n        neg.append((a, b))\\n    else:\\n        pos.append((a, b))\\npos.sort()\\nans = 0\\nfor a, b in pos:\\n    if R >= a:\\n        R += b\\n        ans += 1\\nneg.sort(key=sum, reverse=True)\\nmemo = {}\\ndef dp(i, r):\\n    if(i, r) in memo:\\n        return memo[i, r]\\n    if i == len(neg):return 0\\n    a, b = neg[i]\\n    ans  = dp(i+1, r)\\n    if r >= a and r + b >= 0:\\n        ans = max(ans, dp(i+1, r + b) + 1)\\n    memo[i, r] = ans\\n    return ans\\nprint( dp(0, R) + ans  ) \\n#JSR\\n\", \"N, R = [int(x) for x in input().split()]\\nprojects = [[int(x) for x in input().split()] for _ in range(N)]\\npos = []\\nneg = []\\nfor a, b in projects:\\n    if b < 0:\\n        neg.append((a, b))\\n    else:\\n        pos.append((a, b))\\npos.sort()\\nans = 0\\nfor a, b in pos:\\n    if R >= a:\\n        R += b\\n        ans += 1\\nneg.sort(key=sum, reverse=True)\\nmemo = {}\\ndef dp(i, r):\\n    if(i, r) in memo:\\n        return memo[i, r]\\n    if i == len(neg):return 0\\n    a, b = neg[i]\\n    ans  = dp(i+1, r)\\n    if r >= a and r + b >= 0:\\n        ans = max(ans, dp(i+1, r + b) + 1)\\n    memo[i, r] = ans\\n    return ans\\nprint( dp(0, R) + ans  ) \\n#purvikaurraina\\n\", \"\\nN, R = [int(x) for x in input().split()]\\nprojects = [[int(x) for x in input().split()] for _ in range(N)]\\npos = []\\nneg = []\\nfor a, b in projects:\\n    if b < 0:\\n        neg.append((a, b))\\n    else:\\n        pos.append((a, b))\\npos.sort()\\nans = 0\\nfor a, b in pos:\\n    if R >= a:\\n        R += b\\n        ans += 1\\nneg.sort(key=sum, reverse=True)\\nmemo = {}\\ndef dp(i, r):\\n    if(i, r) in memo:\\n        return memo[i, r]\\n    if i == len(neg):return 0\\n    a, b = neg[i]\\n    ans  = dp(i+1, r)\\n    if r >= a and r + b >= 0:\\n        ans = max(ans, dp(i+1, r + b) + 1)\\n    memo[i, r] = ans\\n    return ans\\nprint( dp(0, R) + ans  )\\n\", \"def myFunc(e):\\n    return e[0] + e[1]\\n\\ncount, rating = list(map(int, input().split()))\\ngoodJob = []\\nbadJob = []\\n\\ntaken = 0\\n\\nfor i in range(count):\\n    a, b = list(map(int, input().split()))\\n    if b >= 0:\\n        goodJob.append([a, b])\\n    else:\\n        badJob.append([a, b])\\n\\ngoodJob.sort()\\nbadJob.sort(reverse=True, key=myFunc)\\n\\nfor job in goodJob:\\n    if job[0] <= rating:\\n        rating += job[1]\\n        taken += 1\\n    else:\\n        break\\n\\ndp = []\\n\\nfor i in range(len(badJob) + 1):\\n    row = []\\n    for j in range(rating + 2):\\n        row.append(0)\\n    dp.append(row)\\n\\ndp[0][rating] = taken\\n\\nfor i in range(len(badJob)):\\n    for curRating in range(rating + 1):\\n        if curRating >= badJob[i][0] and curRating + badJob[i][1] >= 0: \\n            dp[i + 1][curRating + badJob[i][1]] = max(dp[i + 1][curRating + badJob[i][1]], dp[i][curRating] + 1)\\n        dp[i + 1][curRating] = max(dp[i + 1][curRating], dp[i][curRating])\\n\\nans = 0\\n\\nfor curRating in range(rating + 1): \\n    ans = max(ans, dp[len(badJob)][curRating])\\n\\nprint(ans)\\n\\n\\n\\n\", \"from operator import itemgetter, attrgetter\\nn,r=list(map(int,input().split()))\\nps,neg=[],[]\\nfor i in range(n):\\n    a,b=list(map(int,input().split()))\\n    if(b>=0):\\n        ps.append([a,b,-a-b])\\n    else:\\n        neg.append([a,b,-a-b])\\nps=sorted(ps)\\nneg=sorted(neg,key=itemgetter(2))\\nps=ps+neg\\n#print(*ps)\\ndp=[-float('inf')]*(n+1)\\ndp[0]=r\\nfor i in range(n):\\n    for j in range(n-1,-1,-1):\\n        if(dp[j]>=ps[i][0]):\\n            dp[j+1]=max(dp[j+1],dp[j]+ps[i][1])\\nfor j in range(n,-1,-1):\\n    if(dp[j]>=0):\\n        print(j)\\n        break\\n\"]", "task": "apps", "difficulty": "introductory", "split": "test", "transformation_type": "vanilla"}