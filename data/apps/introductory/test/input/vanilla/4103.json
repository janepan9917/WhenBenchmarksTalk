{"qid": 4103, "orig_input": "There is a robot staying at $X=0$ on the $Ox$ axis. He has to walk to $X=n$. You are controlling this robot and controlling how he goes. The robot has a battery and an accumulator with a solar panel.\n\nThe $i$-th segment of the path (from $X=i-1$ to $X=i$) can be exposed to sunlight or not. The array $s$ denotes which segments are exposed to sunlight: if segment $i$ is exposed, then $s_i = 1$, otherwise $s_i = 0$.\n\nThe robot has one battery of capacity $b$ and one accumulator of capacity $a$. For each segment, you should choose which type of energy storage robot will use to go to the next point (it can be either battery or accumulator). If the robot goes using the battery, the current charge of the battery is decreased by one (the robot can't use the battery if its charge is zero). And if the robot goes using the accumulator, the current charge of the accumulator is decreased by one (and the robot also can't use the accumulator if its charge is zero).\n\nIf the current segment is exposed to sunlight and the robot goes through it using the battery, the charge of the accumulator increases by one (of course, its charge can't become higher than it's maximum capacity).\n\nIf accumulator is used to pass some segment, its charge decreases by 1 no matter if the segment is exposed or not.\n\nYou understand that it is not always possible to walk to $X=n$. You want your robot to go as far as possible. Find the maximum number of segments of distance the robot can pass if you control him optimally.\n\n\n-----Input-----\n\nThe first line of the input contains three integers $n, b, a$ ($1 \\le n, b, a \\le 2 \\cdot 10^5$) \u2014 the robot's destination point, the battery capacity and the accumulator capacity, respectively.\n\nThe second line of the input contains $n$ integers $s_1, s_2, \\dots, s_n$ ($0 \\le s_i \\le 1$), where $s_i$ is $1$ if the $i$-th segment of distance is exposed to sunlight, and $0$ otherwise.\n\n\n-----Output-----\n\nPrint one integer \u2014 the maximum number of segments the robot can pass if you control him optimally.\n\n\n-----Examples-----\nInput\n5 2 1\n0 1 0 1 0\n\nOutput\n5\n\nInput\n6 2 1\n1 0 0 1 0 1\n\nOutput\n3\n\n\n\n-----Note-----\n\nIn the first example the robot can go through the first segment using the accumulator, and charge levels become $b=2$ and $a=0$. The second segment can be passed using the battery, and charge levels become $b=1$ and $a=1$. The third segment can be passed using the accumulator, and charge levels become $b=1$ and $a=0$. The fourth segment can be passed using the battery, and charge levels become $b=0$ and $a=1$. And the fifth segment can be passed using the accumulator.\n\nIn the second example the robot can go through the maximum number of segments using battery two times and accumulator one time in any order.", "input": "There is a robot staying at $X=0$ on the $Ox$ axis. He has to walk to $X=n$. You are controlling this robot and controlling how he goes. The robot has a battery and an accumulator with a solar panel.\n\nThe $i$-th segment of the path (from $X=i-1$ to $X=i$) can be exposed to sunlight or not. The array $s$ denotes which segments are exposed to sunlight: if segment $i$ is exposed, then $s_i = 1$, otherwise $s_i = 0$.\n\nThe robot has one battery of capacity $b$ and one accumulator of capacity $a$. For each segment, you should choose which type of energy storage robot will use to go to the next point (it can be either battery or accumulator). If the robot goes using the battery, the current charge of the battery is decreased by one (the robot can't use the battery if its charge is zero). And if the robot goes using the accumulator, the current charge of the accumulator is decreased by one (and the robot also can't use the accumulator if its charge is zero).\n\nIf the current segment is exposed to sunlight and the robot goes through it using the battery, the charge of the accumulator increases by one (of course, its charge can't become higher than it's maximum capacity).\n\nIf accumulator is used to pass some segment, its charge decreases by 1 no matter if the segment is exposed or not.\n\nYou understand that it is not always possible to walk to $X=n$. You want your robot to go as far as possible. Find the maximum number of segments of distance the robot can pass if you control him optimally.\n\n\n-----Input-----\n\nThe first line of the input contains three integers $n, b, a$ ($1 \\le n, b, a \\le 2 \\cdot 10^5$) \u2014 the robot's destination point, the battery capacity and the accumulator capacity, respectively.\n\nThe second line of the input contains $n$ integers $s_1, s_2, \\dots, s_n$ ($0 \\le s_i \\le 1$), where $s_i$ is $1$ if the $i$-th segment of distance is exposed to sunlight, and $0$ otherwise.\n\n\n-----Output-----\n\nPrint one integer \u2014 the maximum number of segments the robot can pass if you control him optimally.\n\n\n-----Examples-----\nInput\n5 2 1\n0 1 0 1 0\n\nOutput\n5\n\nInput\n6 2 1\n1 0 0 1 0 1\n\nOutput\n3\n\n\n\n-----Note-----\n\nIn the first example the robot can go through the first segment using the accumulator, and charge levels become $b=2$ and $a=0$. The second segment can be passed using the battery, and charge levels become $b=1$ and $a=1$. The third segment can be passed using the accumulator, and charge levels become $b=1$ and $a=0$. The fourth segment can be passed using the battery, and charge levels become $b=0$ and $a=1$. And the fifth segment can be passed using the accumulator.\n\nIn the second example the robot can go through the maximum number of segments using battery two times and accumulator one time in any order.", "test_cases": {"inputs": ["5 2 1\n0 1 0 1 0\n", "6 2 1\n1 0 0 1 0 1\n", "100 1 1\n0 0 0 1 1 0 1 0 1 0 1 0 0 1 0 0 1 1 0 0 1 0 1 1 1 1 1 1 1 0 1 1 1 0 0 0 0 0 0 1 1 0 0 0 1 0 1 0 0 1 0 1 1 0 0 1 0 0 0 1 1 1 1 1 0 0 0 0 0 1 0 0 0 0 1 0 0 0 1 1 0 1 1 0 1 1 1 0 1 1 0 1 1 0 0 1 1 0 1 1\n", "100 1 1\n0 0 1 0 0 0 0 0 1 1 0 0 1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 1 1 0 0 1 0 0 0 1 1 1 0 0 0 1 0 1 1 0 1 0 0 1 1 0 1 0 1 0 1 1 0 0 0 1 0 0 1 0 1 0 1 1 1 0 1 0 1 1 1 0 1 1 0 0 0 0 1 1 1 1 1 1 1 0 0 0 1 0 1 0 0 1\n", "100 2 1\n0 0 1 1 1 0 0 1 0 1 0 1 0 1 1 0 0 1 1 0 1 0 1 1 1 1 1 1 1 1 1 1 1 0 0 1 1 1 1 0 1 1 1 1 1 0 1 1 0 1 1 0 0 0 1 1 0 1 1 1 1 1 1 0 1 0 0 0 0 1 0 1 1 0 1 0 1 0 0 1 1 0 1 0 1 0 1 1 1 0 0 1 0 1 1 1 1 1 1 1\n", "100 5 5\n1 1 0 0 0 0 1 1 1 0 1 1 0 0 0 1 0 0 0 1 0 0 1 0 1 1 0 0 0 0 1 0 0 0 1 1 0 1 1 1 1 0 0 0 0 0 1 0 1 1 1 1 0 1 1 0 0 1 0 1 1 1 0 0 1 1 0 0 1 0 0 1 1 1 0 0 1 0 1 1 1 0 1 0 0 1 0 1 0 1 0 1 0 1 1 0 1 1 1 1\n", "100 7 4\n0 0 1 1 0 1 0 0 1 0 1 1 1 1 1 1 0 0 1 0 1 1 1 1 0 0 0 0 0 1 1 0 1 1 0 0 1 0 1 0 1 1 0 0 1 1 1 0 0 0 1 1 1 0 1 0 1 1 1 1 0 1 1 0 0 1 1 1 0 0 0 1 1 0 0 1 0 1 0 1 0 0 1 1 1 1 1 0 0 0 1 1 1 1 1 1 1 1 0 1\n", "100 20 13\n1 1 0 1 1 0 0 1 0 1 1 1 0 1 0 0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 1 1 0 0 0 1 1 1 1 0 0 0 0 0 1 0 1 0 1 1 0 1 0 0 1 0 0 1 1 1 0 0 0 1 1 0 1 1 0 0 0 0 1 0 1 1 0 1 1 1 1 0 0 1 1 1 1 0 0 0 0 0 0 1 1 0 1 1 0 1\n", "100 11 39\n1 0 1 1 1 1 0 1 0 0 1 0 0 0 1 0 1 0 1 1 1 1 1 1 1 1 0 0 1 1 1 0 0 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 1 1 1 0 0 0 1 0 0 1 0 0 0 0 0 1 1 0 0 1 0 0 0 0 1 1 1 0 1 0 0 1 0 1\n", "100 8 9\n1 0 0 0 0 0 1 0 0 0 1 1 1 1 0 1 1 0 0 0 0 0 0 1 0 0 1 1 0 0 1 0 0 1 1 0 0 0 0 1 1 1 0 0 1 0 0 0 1 0 0 1 0 0 1 1 1 0 0 0 0 1 0 0 0 0 0 1 0 1 1 1 0 1 0 1 1 0 0 0 1 1 0 1 0 0 1 1 0 1 0 1 0 0 0 1 1 0 1 1\n", "100 18 14\n0 0 1 0 0 0 1 1 0 1 0 1 0 0 1 0 1 0 1 0 0 1 1 0 1 1 0 0 1 1 0 1 0 0 0 0 1 0 1 0 0 0 0 1 1 0 0 0 1 1 0 0 0 1 1 0 0 1 0 0 1 1 1 0 1 1 0 1 1 0 1 0 0 1 0 0 1 0 0 1 0 1 1 1 1 1 0 1 0 0 0 0 0 1 1 1 1 1 1 0\n", "100 25 5\n1 0 0 1 1 0 1 1 0 0 0 0 1 1 0 0 1 1 0 1 1 1 0 0 1 0 1 1 1 1 1 0 1 0 0 1 1 1 0 1 1 0 1 0 1 0 0 1 0 1 1 0 0 0 0 1 1 1 1 1 0 1 1 1 1 1 1 1 0 1 0 0 0 0 1 1 0 0 0 1 0 1 0 1 1 0 0 0 1 1 1 1 1 1 1 0 1 1 0 0\n", "100 3 49\n1 0 1 0 0 0 1 1 1 0 0 0 0 1 0 1 0 0 1 0 1 1 0 0 1 1 0 0 1 1 0 1 1 1 0 0 1 0 1 1 0 0 1 1 0 1 0 0 1 0 1 1 0 0 0 0 1 0 1 0 1 0 0 0 1 0 0 0 1 0 1 0 0 0 0 1 1 0 0 1 1 1 1 1 0 1 0 0 1 1 0 0 0 1 1 0 1 1 0 1\n", "100 25 40\n1 0 0 1 1 0 1 1 0 0 1 1 0 1 1 0 1 0 0 0 0 0 1 1 0 0 0 1 1 0 1 1 0 1 1 0 1 0 1 0 0 0 1 1 1 0 0 1 1 0 0 0 0 0 1 1 0 1 1 0 0 0 1 1 0 1 1 1 0 1 1 0 1 1 1 0 0 0 1 1 0 0 0 0 0 0 1 1 1 1 1 1 0 0 0 1 0 0 1 1\n", "1 1 1\n0\n", "2 1 1\n0 0\n", "3 1 1\n1 1 1\n", "4 1 1\n1 1 1 0\n", "4 2 1\n1 1 1 0\n", "5 2 1\n0 1 1 1 0\n", "5 1 2\n0 1 1 1 0\n", "47 4 9\n0 1 1 0 0 0 0 1 1 0 0 0 0 0 0 0 0 1 1 1 1 0 1 0 0 0 1 0 0 0 1 1 0 0 1 1 0 1 0 0 0 1 1 1 0 0 0\n", "78 14 2\n0 1 0 0 0 0 0 0 1 1 0 1 0 1 1 1 0 0 1 1 0 0 0 1 0 0 1 0 1 0 1 1 1 1 0 0 0 1 1 0 1 0 1 1 0 0 1 1 1 1 0 1 0 0 0 1 0 1 1 1 1 1 1 1 0 0 0 1 0 0 1 1 0 0 0 1 0 1\n", "11 3 1\n1 1 0 0 1 0 0 1 1 0 0\n", "81 36 6\n1 1 1 1 0 1 0 0 0 1 0 0 1 0 1 0 0 0 1 0 1 0 0 0 1 0 1 1 0 1 0 1 1 0 1 0 1 0 0 0 0 0 1 1 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 1 1 1 1 0 0 0 1 0 0 0 1 1 1 1 0 0 1 0 1 1\n"], "outputs": ["5\n", "3\n", "2\n", "2\n", "4\n", "15\n", "18\n", "53\n", "61\n", "25\n", "50\n", "55\n", "55\n", "90\n", "1\n", "2\n", "3\n", "3\n", "4\n", "5\n", "4\n", "16\n", "25\n", "6\n", "71\n"]}, "solutions": "[\"n, b, a = map(int, input().split())\\nA = list(map(int, input().split()))\\na0 = a\\nans = 0\\nfor elem in A:\\n\\tif a + b == 0:\\n\\t\\tbreak\\n\\tif elem == 0:\\n\\t\\tif a > 0:\\n\\t\\t\\ta -= 1\\n\\t\\t\\tans += 1\\n\\t\\telse:\\n\\t\\t\\tb -= 1\\n\\t\\t\\tans += 1\\n\\telse:\\n\\t\\tif a == a0:\\n\\t\\t\\ta -= 1\\n\\t\\t\\tans += 1\\n\\t\\telif b > 0:\\n\\t\\t\\tb -= 1\\n\\t\\t\\ta += 1\\n\\t\\t\\tans += 1\\n\\t\\telse:\\n\\t\\t\\ta -= 1\\n\\t\\t\\tans += 1\\nprint(ans)\", \"def main():\\n    n, b, a = map(int, input().split())\\n    arr = list(map(int, input().split()))\\n    B = b\\n    A = a\\n    for i in range(n + 1):\\n        if (A == 0 and B == 0) or i == n:\\n            print(i)\\n            break\\n        if arr[i]:\\n            if A == a:\\n                A -= 1\\n            elif B:\\n                B -= 1\\n                A += 1\\n            else:\\n                A -= 1\\n        else:\\n            if A:\\n                A -= 1\\n            else:\\n                B -= 1\\n    return 0\\n\\nmain()\", \"IN = input\\nrint = lambda: int(IN())\\nrmint = lambda: list(map(int, IN().split()))\\nrlist = lambda: list(rmint())\\n\\nn, b, a = rmint()\\ny = a\\nx = b\\nd = 0\\n\\n\\ndef ex():\\n    print(d)\\n    return\\n\\n\\nfor s in rlist():\\n    if s:\\n        if x and y < a:\\n            y += 1\\n            x -= 1\\n        else:\\n            if y:\\n                y -= 1\\n            else:\\n                if x:\\n                    x -= 1\\n                else:\\n                    ex()\\n    else:\\n        if y:\\n            y -= 1\\n        else:\\n            if x:\\n                x -= 1\\n            else:\\n                ex()\\n    d += 1\\n\\nprint(d)\\n\", \"\\n\\n\\ndef main():\\n    dest, battmax, accumax = list(map(int, input().split()))\\n    batt = battmax\\n    accum = accumax\\n    \\n    light = list([bool(int(x)) for x in input().split()])\\n    path = 0\\n    for i in range(len(light)):\\n        if not batt and not accum:\\n            break\\n        if accum == accumax:\\n            # if accum is full\\n            accum -= 1\\n            path += 1\\n        elif batt > 0 and light[i]:\\n            batt -= 1\\n            accum += 1\\n            path += 1\\n        elif accum > 0:\\n            accum -= 1\\n            path += 1\\n        else:\\n            batt -= 1\\n            path += 1\\n    print(path)\\n        \\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"N, B, A = list(map(int, input().split()))\\nmaxA = A\\nS = [int(a) for a in input().split()]\\n\\nfor i in range(N):\\n    # print(B, A)\\n    s = S[i]\\n    if A + B == 0:\\n        print(i)\\n        break\\n    else:\\n        if s > 0 and A < maxA and B > 0:\\n            B -= 1\\n            A += 1\\n        elif A > 0:\\n            A -= 1\\n        else:\\n            B -= 1\\nelse:\\n    print(N)\\n\", \"nn, bb, aa = map(int, input().split())\\nn, b, a = nn, bb, aa\\nS = list(map(int, input().split()))\\nfor i in range(n):\\n    if a == 0 and b == 0:\\n        print(i)\\n        return\\n    if S[i] == 1:\\n        if b > 0 and a < aa:\\n            b -= 1\\n            a += 1\\n        else:\\n            a -= 1\\n    else:\\n        if a > 0:\\n            a -= 1\\n        else:\\n            b -= 1\\nprint(n)\", \"n, b, a = map(int, input().split())\\n\\npath = map(int, input().split())\\n\\nmax_a = a\\ncurrent_a = a\\n\\ncount = 0\\nfor segment in path:\\n\\n\\tif segment == 0:\\n\\t\\tif current_a > 0:\\n\\t\\t\\tcurrent_a -= 1\\n\\t\\telse:\\n\\t\\t\\tb -= 1\\n\\n\\telse:\\n\\t\\tif current_a == max_a or b == 0:\\n\\t\\t\\tcurrent_a -= 1\\n\\n\\t\\telse:\\n\\t\\t\\tb -= 1\\n\\t\\t\\tcurrent_a += 1\\n\\n\\tcount += 1\\n\\tif current_a == 0 and b == 0:\\n\\t\\tbreak\\n\\nprint(count)\", \"n, mb, ma = [int(i) for i in input().split()]\\nl = [int(i) for i in input().split()]\\n\\na, b = ma, mb\\nfor i in range(n):\\n    if a + b == 0:\\n        print(i)\\n        return\\n    elif a != ma and b > 0 and l[i] == 1:\\n        b -= 1\\n        a += 1\\n    elif a > 0:\\n        a -= 1\\n    else:\\n        b -= 1\\nprint(n)\\n\", \"n,a,b=list(map(int,input().split()))\\nmab=b\\nl=list(map(int,input().split()))\\nans=0\\nfor x in l :\\n    if x==0 :\\n        if b>0 :\\n            b-=1\\n            ans+=1\\n        else :\\n            if a>0 :\\n                a-=1\\n                ans+=1\\n            else :\\n                break\\n    else :\\n        if mab==b :\\n            b-=1\\n            ans+=1\\n        else :\\n            if a>0 :\\n                a-=1\\n                b+=1\\n                ans+=1\\n            else :\\n                if b>0 :\\n                    ans+=1\\n                    b-=1\\n                else :\\n                    break\\nprint(ans)\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nn,b,a=list(map(int,input().split()))\\nS=list(map(int,input().split()))\\n\\nbn=b\\nan=a\\n\\nfor i in range(n):\\n    #print(bn,an)\\n    if bn==0 and an==0:\\n        print(i)\\n        return\\n    if S[i]==1 and bn>0 and an<a:\\n        bn-=1\\n        an+=1\\n    elif an>0:\\n        an-=1\\n    else:\\n        bn-=1\\n\\nprint(n)\\n\\n\", \"n,b,a = list(map(int,input().split()))\\nsi = list(map(int,input().split()))\\na2 = a\\nans = n\\nfor i in range(n):\\n    if b != 0:\\n        if a2 == a:\\n            a2 -= 1\\n        else:\\n            if a2 != 0:\\n                if si[i] == 1:\\n                    b -= 1\\n                    a2 += 1\\n                else:\\n                    a2 -= 1\\n            else:\\n                b -= 1\\n                if si[i] == 1:\\n                    a2 += 1\\n    else:\\n        if a2 == 0:\\n            ans = i\\n            break\\n        a2 -= 1\\nprint(ans)\\n        \\n\", \"n, battery, accumulator = list(map(int, input().split()))\\ns = list(map(int, input().split()))\\n\\nb = battery\\na = accumulator\\nans = 0\\nfor i in range(n):\\n    if a == 0 and b == 0:\\n        break\\n    elif s[i] == 0:\\n        if a > 0:\\n            a -= 1\\n            ans += 1\\n        else:\\n            b -= 1\\n            ans += 1\\n    else:\\n        if a == accumulator:\\n            a -= 1\\n            ans += 1\\n        elif b > 0:\\n            b -= 1\\n            a += 1\\n            ans += 1\\n        else:\\n            a -= 1\\n            ans += 1\\nprint(ans)\\n\", \"n, b, a = list(map(int, input().split()))\\n\\n\\ns = list(map(int, input().split()))\\n\\nb1, a1 = b, a\\n\\nk = 0\\n\\nfor c in s:\\n\\tif a1 == 0 and b1 == 0:\\n\\t\\tbreak\\n\\t\\t\\n\\tif c == 0:\\n\\t\\tif a1 > 0:\\n\\t\\t\\ta1 -= 1\\n\\t\\telif b1 > 0:\\n\\t\\t\\tb1 -= 1\\n\\t\\telse:\\n\\t\\t\\tbreak\\n\\telse:\\n\\t\\t\\n\\t\\tif a1 != a:\\n\\t\\t\\tif b1 > 0:\\n\\t\\t\\t\\tb1 -= 1\\n\\t\\t\\t\\ta1 += 1\\n\\t\\t\\telif a1 > 0:\\n\\t\\t\\t\\ta1 -= 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tbreak\\n\\t\\telse:\\n\\t\\t\\ta1 -= 1\\n\\tk += 1\\n\\n\\nprint(k)\\n\", \"n, b, a = list(map(int, input().split()))\\nl = list(map(int, input().split()))\\naa = a\\nfor i in range(n):\\n\\tif a == 0 and b == 0:\\n\\t\\tprint(i)\\n\\t\\tbreak\\n\\tif l[i] == 0:\\n\\t\\tif a > 0:\\n\\t\\t\\ta -= 1\\n\\t\\telse:\\n\\t\\t\\tb -= 1\\n\\tif l[i] == 1:\\n\\t\\tif a == aa:\\n\\t\\t\\ta -= 1\\n\\t\\telse:\\n\\t\\t\\tif b > 0:\\n\\t\\t\\t\\tb -= 1\\n\\t\\t\\t\\ta = min(aa, a + 1)\\n\\t\\t\\telse:\\n\\t\\t\\t\\ta -= 1\\n\\tif i == n - 1:\\n\\t\\tprint(n)\", \"n,b,a = map(int, input().split())\\n\\ns = list(map(int, input().split()))\\n\\ncb, ca = b, a\\n\\ni = 0\\n\\nwhile (cb or ca) and i < len(s):\\n\\n\\tif s[i] == 1:\\n\\n\\t\\tif ca < a:\\n\\t\\t\\tif cb:\\n\\n\\t\\t\\t\\tcb -= 1\\n\\n\\t\\t\\t\\tca += 1\\n\\n\\t\\t\\telse:\\n\\t\\t\\t\\tca -= 1\\n\\t\\telse:\\n\\n\\t\\t\\tca -= 1\\n\\n\\telse:\\n\\n\\t\\tif ca:\\n\\n\\t\\t\\tca -= 1\\n\\n\\t\\telse:\\n\\n\\t\\t\\tcb -= 1\\n\\n\\ti += 1\\n\\nprint(i)\", \"n,b,a=map(int,input().split())\\nl1=list(map(int,input().split()))\\nmaxa=a\\ndist=0\\nx=0\\nwhile ( b!=0 or a!=0 ) and dist<n:\\n    if a==maxa:\\n        a-=1\\n        x+=1\\n        dist+=1\\n    elif l1[x]==0:\\n        if a>0:\\n            dist+=1\\n            a-=1\\n            x+=1\\n        else :\\n            x+=1\\n            dist+=1\\n            b-=1\\n    else :\\n        if b>0:\\n            dist+=1\\n            b-=1\\n            a+=1\\n            x+=1\\n        else :\\n            dist+=1\\n            a-=1\\n            x+=1\\nprint(dist)\", \"n, b, a = [int(item) for item in input().split()]\\ns = [int(item) for item in input().split()]\\n\\nmax_a = a\\nans = 0\\n\\nrem = [0] * n\\nrem[-1] = s[-1]\\nfor i in range(n - 2, -1, -1):\\n    rem[i] = rem[i + 1] + s[i]\\n\\nfor i, sun in enumerate(s):\\n    # print(b, a, sun)\\n    if b == 0 and a == 0:\\n        break\\n    if b == 0:\\n        a -= 1\\n    elif a == 0:\\n        b -= 1\\n        if sun and a < max_a:\\n            a += 1\\n    else:\\n        if a == max_a:\\n            a -= 1\\n        else:\\n            if sun:\\n                a += 1\\n                b -= 1\\n            else:\\n                if max_a - a < rem[i]:\\n                    a -= 1\\n                else:\\n                    b -= 1\\n\\n    ans += 1\\n\\nprint(ans)\\n\", \"''' CODED WITH LOVE BY SATYAM KUMAR '''\\n\\nfrom sys import stdin, stdout\\nimport cProfile, math\\nfrom collections import Counter,defaultdict\\nfrom bisect import bisect_left,bisect,bisect_right\\nimport itertools\\nfrom copy import deepcopy\\nfrom fractions import Fraction\\nimport sys, threading\\nimport operator as op\\nfrom functools import reduce\\nsys.setrecursionlimit(10**6) # max depth of recursion\\nthreading.stack_size(2**27)  # new thread will get stack of such size\\nfac_warmup = False\\nprintHeap = str()\\nmemory_constrained = False\\nP = 10**9+7\\nimport sys\\n\\nclass merge_find:\\n    def __init__(self,n):\\n        self.parent = list(range(n))\\n        self.size = [1]*n\\n        self.num_sets = n\\n        self.lista = [[_] for _ in range(n)]\\n    def find(self,a):\\n        to_update = []\\n        while a != self.parent[a]:\\n            to_update.append(a)\\n            a = self.parent[a]\\n        for b in to_update:\\n            self.parent[b] = a\\n        return self.parent[a]\\n    def merge(self,a,b):\\n        a = self.find(a)\\n        b = self.find(b)\\n        if a==b:\\n            return\\n        if self.size[a]<self.size[b]:\\n            a,b = b,a\\n        self.num_sets -= 1\\n        self.parent[b] = a\\n        self.size[a] += self.size[b]\\n        self.lista[a] += self.lista[b]\\n    def set_size(self, a):\\n        return self.size[self.find(a)]\\n    def __len__(self):\\n        return self.num_sets\\n\\ndef display(string_to_print):\\n    stdout.write(str(string_to_print) + \\\"\\\\n\\\")\\n\\ndef primeFactors(n): #n**0.5 complex \\n    factors = dict()\\n    for i in range(2,math.ceil(math.sqrt(n))+1):  \\n        while n % i== 0: \\n            if i in factors:\\n                factors[i]+=1\\n            else: factors[i]=1\\n            n = n // i \\n    if n>2:\\n        factors[n]=1\\n    return (factors)\\n\\ndef fibonacci_modP(n,MOD):\\n    if n<2: return 1\\n    #print (n,MOD)\\n    return (cached_fn(fibonacci_modP, (n+1)//2, MOD)*cached_fn(fibonacci_modP, n//2, MOD) + cached_fn(fibonacci_modP, (n-1) // 2, MOD)*cached_fn(fibonacci_modP, (n-2) // 2, MOD)) % MOD\\n\\ndef factorial_modP_Wilson(n , p): \\n    if (p <= n): \\n        return 0\\n    res = (p - 1) \\n    for i in range (n + 1, p): \\n        res = (res * cached_fn(InverseEuler,i, p)) % p \\n    return res \\n\\ndef binary(n,digits = 20):\\n    b = bin(n)[2:]\\n    b = '0'*(20-len(b))+b\\n    return b\\n\\ndef isprime(n):\\n    \\\"\\\"\\\"Returns True if n is prime.\\\"\\\"\\\"\\n    if n < 4:\\n        return True\\n    if n % 2 == 0:\\n        return False\\n    if n % 3 == 0:\\n        return False\\n    i = 5\\n    w = 2\\n    while i * i <= n:\\n        if n % i == 0:\\n            return False\\n        i += w\\n        w = 6 - w\\n    return True\\nfactorial_modP = []\\ndef warm_up_fac(MOD):\\n    nonlocal factorial_modP,fac_warmup\\n    if fac_warmup: return\\n    factorial_modP= [1 for _ in range(fac_warmup_size+1)]\\n    for i in range(2,fac_warmup_size):\\n        factorial_modP[i]= (factorial_modP[i-1]*i) % MOD\\n    fac_warmup = True\\n\\ndef InverseEuler(n,MOD):\\n    return pow(n,MOD-2,MOD)\\n\\ndef nCr(n, r, MOD):\\n    nonlocal fac_warmup,factorial_modP\\n    if not fac_warmup:\\n        warm_up_fac(MOD)\\n        fac_warmup = True\\n    return (factorial_modP[n]*((pow(factorial_modP[r], MOD-2, MOD) * pow(factorial_modP[n-r], MOD-2, MOD)) % MOD)) % MOD\\n\\ndef test_print(*args):\\n    if testingMode:\\n        print(args)\\n\\ndef display_list(list1, sep=\\\" \\\"):\\n    stdout.write(sep.join(map(str, list1)) + \\\"\\\\n\\\")\\n\\ndef display_2D_list(li):\\n    for i in li:\\n        print(i)\\ndef prefix_sum(li):\\n    sm = 0\\n    res = []\\n    for i in li:\\n        sm+=i\\n        res.append(sm)\\n    return res\\n\\ndef get_int():\\n    return int(stdin.readline().strip())\\n\\ndef get_tuple():\\n    return map(int, stdin.readline().split())\\n\\ndef get_list():\\n    return list(map(int, stdin.readline().split()))\\nimport heapq,itertools\\npq = []                         # list of entries arranged in a heap\\nentry_finder = {}               # mapping of tasks to entries\\nREMOVED = '<removed-task>' \\ndef add_task(task, priority=0):\\n    'Add a new task or update the priority of an existing task'\\n    if task in entry_finder:\\n        remove_task(task)\\n    count = next(counter)\\n    entry = [priority, count, task]\\n    entry_finder[task] = entry\\n    heapq.heappush(pq, entry)\\n\\ndef remove_task(task):\\n    'Mark an existing task as REMOVED.  Raise KeyError if not found.'\\n    entry = entry_finder.pop(task)\\n    entry[-1] = REMOVED\\n\\ndef pop_task():\\n    'Remove and return the lowest priority task. Raise KeyError if empty.'\\n    while pq:\\n        priority, count, task = heapq.heappop(pq)\\n        if task is not REMOVED:\\n            del entry_finder[task]\\n            return task\\n    raise KeyError('pop from an empty priority queue')\\nmemory = dict()\\ndef clear_cache():\\n    nonlocal memory\\n    memory = dict()\\ndef cached_fn(fn, *args):\\n    nonlocal memory\\n    if args in memory:\\n        return memory[args]\\n    else:\\n        result = fn(*args)\\n        memory[args] = result\\n        return result\\n\\ndef ncr (n,r):\\n    return math.factorial(n)/(math.factorial(n-r)*math.factorial(r))\\ndef binary_serach(i,li):\\n    #print(\\\"Search for \\\",i)\\n    fn = lambda x: li[x]-x//i\\n    x = -1\\n    b = len(li)\\n    while b>=1:\\n        #print(b,x)\\n        while b+x<len(li) and fn(b+x)>0: #Change this condition 2 to whatever you like\\n            x+=b\\n        b=b//2\\n    return x\\n\\n# -------------------------------------------------------------- MAIN PROGRAM\\nTestCases = False\\ntestingMode = False\\nfac_warmup_size = 10**5+100\\noptimiseForReccursion = True #Can not be used clubbed with TestCases # WHen using recursive functions, use Python 3\\nfrom math import factorial\\n\\n\\ndef main():\\n    n,b,a = get_tuple()\\n    b_fuel, a_fuel = b,a\\n    li = get_list()\\n    for i,ele in enumerate(li):\\n        if a_fuel==0 and b_fuel==0:\\n            print(i)\\n            return\\n        if (ele==1):\\n            if b_fuel>0 and a_fuel<a:\\n                b_fuel-=1\\n                a_fuel+=1\\n            elif (b_fuel>0 and a_fuel==a) or b_fuel==0:\\n                a_fuel-=1\\n            else:\\n                b_fuel-=1\\n        else:\\n            if a_fuel>0:\\n                a_fuel-=1\\n            else: b_fuel-=1\\n\\n    print(n)\\n\\n\\n    \\n\\n\\n# --------------------------------------------------------------------- END=\\n\\n\\nif TestCases: \\n    for i in range(get_int()): \\n        cProfile.run('main()') if testingMode else main(i) \\nelse: (cProfile.run('main()') if testingMode else main()) if not optimiseForReccursion else threading.Thread(target=main).start()\", \"n,b,a=list(map(int,input().split()))\\narr=list(map(int,input().split()))\\narr1=[b]\\nval=b\\nfor i in range(1,n):\\n\\tif(arr[i]==1):\\n\\t\\tval-=1\\n\\tarr1.append(val)\\nval=b\\narr2=[a-1]\\nval2=a-1\\nans=-1\\nfor i in range(1,n):\\n\\tif(arr[i]==1):\\n\\t\\tif(val>0):\\n\\t\\t\\tif(val2==a):\\n\\t\\t\\t\\tval2-=1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tval-=1\\n\\t\\t\\t\\tval2=min(val2+1,a)\\n\\t\\telse:\\n\\t\\t\\tif(val2==0):\\n\\t\\t\\t\\tans=i\\n\\t\\t\\t\\tbreak\\n\\t\\t\\telse:\\n\\t\\t\\t\\tval2-=1\\n\\t\\t\\n\\telse:\\n\\t\\tif(val2==0):\\n\\t\\t\\tif(val>0):\\n\\t\\t\\t\\tval-=1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tans=i\\n\\t\\t\\t\\tbreak\\n\\t\\telse:\\n\\t\\t\\tval2-=1\\nif(ans==-1):\\n\\tprint(n)\\nelse:\\n\\tprint(ans)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\", \"n, b, a = (int(x) for x in input().split())\\ns = [int(x) for x in input().split()]\\n\\ncharge = a\\nfor ans, t in enumerate(s):\\n    if t:\\n        if charge < a and b:\\n            b -= 1\\n            charge += 1\\n        elif charge:\\n            charge -= 1\\n        elif b:\\n            b -= 1\\n        else:\\n            print(ans)\\n            raise SystemExit(0)\\n    else:\\n        if charge:\\n            charge -= 1\\n        elif b:\\n            b -= 1\\n        else:\\n            print(ans)\\n            raise SystemExit(0)\\nprint(ans + 1)\\n\", \"def main():\\n    n, b, a = map(int, input().split())\\n    cb, ca = b, a\\n    p = 0\\n    for s in input().split():\\n        if ca == 0 and cb == 0:\\n            break\\n        \\n        if int(s):\\n            if ca < a and cb > 0:\\n                ca += 1\\n                cb -= 1\\n            else:\\n                ca -= 1\\n        else:\\n            if ca > 0:\\n                ca -= 1\\n            else:\\n                cb -= 1\\n        p += 1\\n    \\n    print(p)\\n\\nmain()\", \"import collections\\n\\ndef solve():\\n    n,b,a=list(map(int,input().split()))\\n    a_max=a\\n    S=list(map(int,input().split()))\\n    ans=0\\n    for i in range(n):\\n        #print(i,b,a)\\n        if S[i]==1:\\n            if a<a_max and b>0:\\n                b-=1\\n                a+=1\\n            elif a>0:\\n                a-=1\\n            elif b>0:\\n                b-=1\\n            else:\\n                return i\\n        else:\\n            if a>0:\\n                a-=1\\n            elif b>0:\\n                b-=1\\n            else:\\n                return i\\n    return n\\n\\nprint(solve())\\n\", \"n,b,a=[int(x) for x in input().split()]\\nsun=[int(x) for x in input().split()]\\na_max=a\\ncur_len=0\\nfor element in sun:\\n    if(b==0 and a==0):\\n        break\\n    else:\\n        if(b>0 and a<a_max and element==1):\\n            b-=1\\n            a+=1\\n        else:\\n            if(a>0):\\n                a-=1\\n            else:\\n                b-=1\\n    cur_len+=1\\nprint(cur_len)\\n\\n    \\n\", \"n, b, a = list(map(int, input().split()))\\nline = list(map(int, input().split()))\\nb1, a1 = b, a\\ndist = 0\\nfor cell in line:\\n    if cell == 1:\\n        if a1 < a and b1 > 0:\\n            b1 -= 1\\n            a1 += 1\\n            dist += 1\\n        elif a1 > 0:\\n            a1 -= 1\\n            dist += 1\\n        else:\\n            break\\n    else:\\n        if a1 > 0:\\n            a1 -= 1\\n            dist += 1\\n        elif b1 > 0:\\n            b1 -= 1\\n            dist += 1\\n        else:\\n            break\\nprint(dist)\\n\", \"n,b,a = list(map(int,input().split()))\\nam = a\\ns = list(map(int,input().split()))\\ndist = 0\\nfor i in s:\\n    if i == 0:\\n        if a > 0:\\n            a -= 1\\n            dist += 1\\n        elif b > 0:\\n            b -= 1\\n            dist += 1\\n        else:\\n            break\\n    else:\\n        if a == am:\\n            a -= 1\\n            dist += 1\\n        elif b > 0:\\n            b -= 1\\n            a += 1\\n            dist += 1\\n        elif a > 0:\\n            a -= 1\\n            dist += 1\\nprint(dist)\\n\"]", "task": "apps", "difficulty": "introductory", "split": "test", "transformation_type": "vanilla"}