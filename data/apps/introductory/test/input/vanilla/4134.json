{"qid": 4134, "orig_input": "There is a rectangular grid of size $n \\times m$. Each cell has a number written on it; the number on the cell ($i, j$) is $a_{i, j}$. Your task is to calculate the number of paths from the upper-left cell ($1, 1$) to the bottom-right cell ($n, m$) meeting the following constraints:\n\n  You can move to the right or to the bottom only. Formally, from the cell ($i, j$) you may move to the cell ($i, j + 1$) or to the cell ($i + 1, j$). The target cell can't be outside of the grid.  The xor of all the numbers on the path from the cell ($1, 1$) to the cell ($n, m$) must be equal to $k$ (xor operation is the bitwise exclusive OR, it is represented as '^' in Java or C++ and \"xor\" in Pascal). \n\nFind the number of such paths in the given grid.\n\n\n-----Input-----\n\nThe first line of the input contains three integers $n$, $m$ and $k$ ($1 \\le n, m \\le 20$, $0 \\le k \\le 10^{18}$) \u2014 the height and the width of the grid, and the number $k$.\n\nThe next $n$ lines contain $m$ integers each, the $j$-th element in the $i$-th line is $a_{i, j}$ ($0 \\le a_{i, j} \\le 10^{18}$).\n\n\n-----Output-----\n\nPrint one integer \u2014 the number of paths from ($1, 1$) to ($n, m$) with xor sum equal to $k$.\n\n\n-----Examples-----\nInput\n3 3 11\n2 1 5\n7 10 0\n12 6 4\n\nOutput\n3\n\nInput\n3 4 2\n1 3 3 3\n0 3 3 2\n3 0 1 1\n\nOutput\n5\n\nInput\n3 4 1000000000000000000\n1 3 3 3\n0 3 3 2\n3 0 1 1\n\nOutput\n0\n\n\n\n-----Note-----\n\nAll the paths from the first example:   $(1, 1) \\rightarrow (2, 1) \\rightarrow (3, 1) \\rightarrow (3, 2) \\rightarrow (3, 3)$;  $(1, 1) \\rightarrow (2, 1) \\rightarrow (2, 2) \\rightarrow (2, 3) \\rightarrow (3, 3)$;  $(1, 1) \\rightarrow (1, 2) \\rightarrow (2, 2) \\rightarrow (3, 2) \\rightarrow (3, 3)$. \n\nAll the paths from the second example:   $(1, 1) \\rightarrow (2, 1) \\rightarrow (3, 1) \\rightarrow (3, 2) \\rightarrow (3, 3) \\rightarrow (3, 4)$;  $(1, 1) \\rightarrow (2, 1) \\rightarrow (2, 2) \\rightarrow (3, 2) \\rightarrow (3, 3) \\rightarrow (3, 4)$;  $(1, 1) \\rightarrow (2, 1) \\rightarrow (2, 2) \\rightarrow (2, 3) \\rightarrow (2, 4) \\rightarrow (3, 4)$;  $(1, 1) \\rightarrow (1, 2) \\rightarrow (2, 2) \\rightarrow (2, 3) \\rightarrow (3, 3) \\rightarrow (3, 4)$;  $(1, 1) \\rightarrow (1, 2) \\rightarrow (1, 3) \\rightarrow (2, 3) \\rightarrow (3, 3) \\rightarrow (3, 4)$.", "input": "There is a rectangular grid of size $n \\times m$. Each cell has a number written on it; the number on the cell ($i, j$) is $a_{i, j}$. Your task is to calculate the number of paths from the upper-left cell ($1, 1$) to the bottom-right cell ($n, m$) meeting the following constraints:\n\n  You can move to the right or to the bottom only. Formally, from the cell ($i, j$) you may move to the cell ($i, j + 1$) or to the cell ($i + 1, j$). The target cell can't be outside of the grid.  The xor of all the numbers on the path from the cell ($1, 1$) to the cell ($n, m$) must be equal to $k$ (xor operation is the bitwise exclusive OR, it is represented as '^' in Java or C++ and \"xor\" in Pascal). \n\nFind the number of such paths in the given grid.\n\n\n-----Input-----\n\nThe first line of the input contains three integers $n$, $m$ and $k$ ($1 \\le n, m \\le 20$, $0 \\le k \\le 10^{18}$) \u2014 the height and the width of the grid, and the number $k$.\n\nThe next $n$ lines contain $m$ integers each, the $j$-th element in the $i$-th line is $a_{i, j}$ ($0 \\le a_{i, j} \\le 10^{18}$).\n\n\n-----Output-----\n\nPrint one integer \u2014 the number of paths from ($1, 1$) to ($n, m$) with xor sum equal to $k$.\n\n\n-----Examples-----\nInput\n3 3 11\n2 1 5\n7 10 0\n12 6 4\n\nOutput\n3\n\nInput\n3 4 2\n1 3 3 3\n0 3 3 2\n3 0 1 1\n\nOutput\n5\n\nInput\n3 4 1000000000000000000\n1 3 3 3\n0 3 3 2\n3 0 1 1\n\nOutput\n0\n\n\n\n-----Note-----\n\nAll the paths from the first example:   $(1, 1) \\rightarrow (2, 1) \\rightarrow (3, 1) \\rightarrow (3, 2) \\rightarrow (3, 3)$;  $(1, 1) \\rightarrow (2, 1) \\rightarrow (2, 2) \\rightarrow (2, 3) \\rightarrow (3, 3)$;  $(1, 1) \\rightarrow (1, 2) \\rightarrow (2, 2) \\rightarrow (3, 2) \\rightarrow (3, 3)$. \n\nAll the paths from the second example:   $(1, 1) \\rightarrow (2, 1) \\rightarrow (3, 1) \\rightarrow (3, 2) \\rightarrow (3, 3) \\rightarrow (3, 4)$;  $(1, 1) \\rightarrow (2, 1) \\rightarrow (2, 2) \\rightarrow (3, 2) \\rightarrow (3, 3) \\rightarrow (3, 4)$;  $(1, 1) \\rightarrow (2, 1) \\rightarrow (2, 2) \\rightarrow (2, 3) \\rightarrow (2, 4) \\rightarrow (3, 4)$;  $(1, 1) \\rightarrow (1, 2) \\rightarrow (2, 2) \\rightarrow (2, 3) \\rightarrow (3, 3) \\rightarrow (3, 4)$;  $(1, 1) \\rightarrow (1, 2) \\rightarrow (1, 3) \\rightarrow (2, 3) \\rightarrow (3, 3) \\rightarrow (3, 4)$.", "test_cases": {"inputs": ["3 3 11\n2 1 5\n7 10 0\n12 6 4\n", "3 4 2\n1 3 3 3\n0 3 3 2\n3 0 1 1\n", "3 4 1000000000000000000\n1 3 3 3\n0 3 3 2\n3 0 1 1\n", "1 1 1000000000000000000\n1000000000000000000\n", "1 1 1000000000000000000\n999999999999999999\n", "1 1 1\n1\n", "1 2 3\n1 2\n", "1 10 1023\n1 2 4 8 16 32 64 128 256 512\n", "1 20 1048575\n1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192 16384 32768 65536 131072 262144 524288\n", "2 1 3\n1\n2\n", "2 2 7\n1 2\n2 4\n", "2 10 2047\n1 2 4 8 16 32 64 128 256 512\n2 4 8 16 32 64 128 256 512 1024\n", "2 20 2097151\n1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192 16384 32768 65536 131072 262144 524288\n2 4 8 16 32 64 128 256 512 1024 2048 4096 8192 16384 32768 65536 131072 262144 524288 1048576\n", "10 1 1023\n1\n2\n4\n8\n16\n32\n64\n128\n256\n512\n", "10 2 2047\n1 2\n2 4\n4 8\n8 16\n16 32\n32 64\n64 128\n128 256\n256 512\n512 1024\n", "10 10 524287\n1 2 4 8 16 32 64 128 256 512\n2 4 8 16 32 64 128 256 512 1024\n4 8 16 32 64 128 256 512 1024 2048\n8 16 32 64 128 256 512 1024 2048 4096\n16 32 64 128 256 512 1024 2048 4096 8192\n32 64 128 256 512 1024 2048 4096 8192 16384\n64 128 256 512 1024 2048 4096 8192 16384 32768\n128 256 512 1024 2048 4096 8192 16384 32768 65536\n256 512 1024 2048 4096 8192 16384 32768 65536 131072\n512 1024 2048 4096 8192 16384 32768 65536 131072 262144\n", "20 1 1048575\n1\n2\n4\n8\n16\n32\n64\n128\n256\n512\n1024\n2048\n4096\n8192\n16384\n32768\n65536\n131072\n262144\n524288\n", "20 2 2097151\n1 2\n2 4\n4 8\n8 16\n16 32\n32 64\n64 128\n128 256\n256 512\n512 1024\n1024 2048\n2048 4096\n4096 8192\n8192 16384\n16384 32768\n32768 65536\n65536 131072\n131072 262144\n262144 524288\n524288 1048576\n", "1 1 982347923479\n1\n", "1 2 1\n1 1\n"], "outputs": ["3\n", "5\n", "0\n", "1\n", "0\n", "1\n", "1\n", "1\n", "1\n", "1\n", "2\n", "10\n", "20\n", "1\n", "10\n", "48620\n", "1\n", "20\n", "0\n", "0\n"]}, "solutions": "[\"from collections import*\\nn, m, k = map(int, input().split())\\nb = [[int(v) for v in input().split()] for _ in range(n)]\\nif m < n:\\n    a = [[b[j][i] for j in range(n)] for i in range(m)]\\n    b = a\\n    m, n = n, m\\ncntrs = [Counter() for _ in range(n)]\\nd = (n + m-1) // 2\\nfor i in range(1<<d):\\n    ones = bin(i).count('1')\\n    z = d - ones\\n    if ones >= n or z >= m: continue\\n    xor = b[0][0]\\n    x, y = 0, 0\\n    for j in range(d):\\n        if i&(1<<j):\\n            x += 1\\n        else:\\n            y += 1\\n        xor ^= b[x][y]\\n    cntrs[x][xor] += 1\\nsm = 0\\nsleft = n + m - 2 - d\\nfor i in range(1<<sleft):\\n    ones = bin(i).count('1')\\n    z = sleft - ones\\n    if ones >= n or z >= m: continue\\n    xor = b[n-1][m-1]\\n    x, y = n-1, m-1\\n    for j in range(sleft):\\n        if i&(1<<j):\\n            x -= 1\\n        else:\\n            y -= 1\\n        xor ^= b[x][y]\\n    xor ^= b[x][y] ^ k\\n    sm += cntrs[x][xor]\\nprint(sm)\", \"n,m,k = list(map(int, input().split()))\\nb = [list(map(int, input().split())) for i in range(n)]\\nt = [[None for i in range(m)] for j in range(n)]\\nt2 = [[None for i in range(m)] for j in range(n)]\\n\\nt[0][0] = {b[0][0]: 1}\\nfor i in range(1,m):\\n\\tt[0][i] = {list(t[0][i-1].keys())[0]^b[0][i]: 1}\\nfor i in range(1,n):\\n\\tt[i][0] = {list(t[i-1][0].keys())[0]^b[i][0]: 1}\\n\\n\\n\\nlimit = (n+m-2)//2\\n\\nfor i in range(1,n):\\n\\tfor j in range(1,m):\\n\\t\\tif i+j>limit:\\n\\t\\t\\tcontinue\\n\\t\\tt[i][j] = {}\\n\\t\\tfor num,cnt in list(t[i-1][j].items()):\\n\\t\\t\\tt[i][j][num^b[i][j]] = cnt\\n\\t\\tfor num,cnt in list(t[i][j-1].items()):\\n\\t\\t\\tif num^b[i][j] in list(t[i][j].keys()):\\n\\t\\t\\t\\tt[i][j][num^b[i][j]] += cnt\\n\\t\\t\\telse:\\n\\t\\t\\t\\tt[i][j][num^b[i][j]] = cnt\\n\\nfor i in range(n):\\n\\tfor j in range(m):\\n\\t\\tif i+j == limit:\\n\\t\\t\\tb[i][j] = 0\\n#print(b)\\n\\nt2[n-1][m-1] = {b[n-1][m-1]: 1}\\nfor i in range(m-2, -1, -1):\\n\\tt2[n-1][i] = {list(t2[n-1][i+1].keys())[0]^b[n-1][i]: 1}\\nfor i in range(n-2, -1, -1):\\n\\tt2[i][m-1] = {list(t2[i+1][m-1].keys())[0]^b[i][m-1]: 1}\\n\\t\\n\\nfor i in range(n-2, -1, -1):\\n\\tfor j in range(m-2, -1, -1):\\n\\t\\tif i+j<limit:\\n\\t\\t\\tcontinue\\n\\t\\tt2[i][j] = {}\\n\\t\\tfor num,cnt in list(t2[i+1][j].items()):\\n\\t\\t\\tt2[i][j][num^b[i][j]] = cnt\\n\\t\\tfor num,cnt in list(t2[i][j+1].items()):\\n\\t\\t\\tif num^b[i][j] in list(t2[i][j].keys()):\\n\\t\\t\\t\\tt2[i][j][num^b[i][j]] += cnt\\n\\t\\t\\telse:\\n\\t\\t\\t\\tt2[i][j][num^b[i][j]] = cnt\\n\\nres = 0\\n\\n#print(t)\\n#print(t2)\\n\\nfor i in range(n):\\n\\tfor j in range(m):\\n\\t\\tif i+j != limit:\\n\\t\\t\\tcontinue\\n\\t\\ttk = set(t[i][j].keys())\\n\\t\\tfor k2 in list(t2[i][j].keys()):\\n\\t\\t\\tif (k2^k) in tk:\\n\\t\\t\\t\\tres += t2[i][j][k2] * t[i][j][k2^k]\\n#\\t\\t\\t\\tprint(k2, t2[i][j][k2], t[i][j][k2^k])\\n\\nprint(res)\\n\\n#print(t)\\n#try:\\t\\n#\\tprint(t[n-1][m-1][k])\\n#except KeyError:\\n#\\tprint(0)\\n\", \"\\ncnt = {}\\nfor i in range(22):\\n    cnt[i] = {}\\n\\n#print(cnt)\\n\\nn,m,k = list(map(int, input().split()))\\narr = [list(map(int, input().split())) for i in range(n)]\\n\\n\\n\\ndef check(x,y):\\n    if x < 0 or x >= n or y < 0 or y >= m:\\n        return False\\n    else:\\n        return True\\n\\n\\ndef go(x,y,now):\\n    if check(x,y) == False:\\n        return\\n\\n    now ^= arr[x][y]\\n    if x + y == m - 1:\\n        #print('yes')\\n        if now in cnt[x]:\\n            cnt[x][now] += 1\\n        else:\\n            cnt[x][now] = 1\\n        return\\n\\n    go(x+1,y,now)\\n    go(x,y+1,now)\\n\\nans = 0\\n\\ndef goRev(x,y,now):\\n    if check(x,y) == False:\\n        return\\n\\n    if x + y == m - 1:\\n        cur = k ^ now\\n        if cur in cnt[x]:\\n            nonlocal ans\\n            #print(ans)\\n            ans += cnt[x][cur]\\n        return\\n\\n    now ^= arr[x][y]\\n    goRev(x-1,y,now)\\n    goRev(x,y-1,now)\\n\\n\\ngo(0,0,0)\\ngoRev(n-1,m-1,0)\\n\\nprint(ans)\\n    \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\", \"cnt = {}\\nfor i in range(22):\\n    cnt[i] = {}\\n\\n#print(cnt)\\n\\nn,m,k = list(map(int, input().split()))\\narr = [list(map(int, input().split())) for i in range(n)]\\n\\n\\n\\ndef check(x,y):\\n    if x < 0 or x >= n or y < 0 or y >= m:\\n        return False\\n    else:\\n        return True\\n\\n\\ndef go(x,y,now):\\n    if check(x,y) == False:\\n        return\\n\\n    now ^= arr[x][y]\\n    if x + y == m - 1:\\n        #print('yes')\\n        if now in cnt[x]:\\n            cnt[x][now] += 1\\n        else:\\n            cnt[x][now] = 1\\n        return\\n\\n    go(x+1,y,now)\\n    go(x,y+1,now)\\n\\nans = 0\\n\\ndef goRev(x,y,now):\\n    if check(x,y) == False:\\n        return\\n\\n    if x + y == m - 1:\\n        cur = k ^ now\\n        if cur in cnt[x]:\\n            nonlocal ans\\n            #print(ans)\\n            ans += cnt[x][cur]\\n        return\\n\\n    now ^= arr[x][y]\\n    goRev(x-1,y,now)\\n    goRev(x,y-1,now)\\n\\n\\ngo(0,0,0)\\ngoRev(n-1,m-1,0)\\n\\nprint(ans)\", \"d = {}\\nfor i in range(22):\\n    d[i] = {}\\n\\n#print(cnt)\\n\\nn,m,k = list(map(int, input().split()))\\narr = [list(map(int, input().split())) for i in range(n)]\\n\\n\\n\\ndef check(x,y):\\n    if x < 0 or x >= n or y < 0 or y >= m:\\n        return False\\n    else:\\n        return True\\n\\n\\ndef go(x,y,now):\\n    if check(x,y) == False:\\n        return\\n\\n    now ^= arr[x][y]\\n    if x + y == m - 1:\\n        #print('yes')\\n        if now in d[x]:\\n            d[x][now] += 1\\n        else:\\n            d[x][now] = 1\\n        return\\n\\n    go(x+1,y,now)\\n    go(x,y+1,now)\\n\\nans = 0\\n\\ndef goRev(x,y,now):\\n    if check(x,y) == False:\\n        return\\n\\n    if x + y == m - 1:\\n        cur = k ^ now\\n        if cur in d[x]:\\n            nonlocal ans\\n            #print(ans)\\n            ans += d[x][cur]\\n        return\\n\\n    now ^= arr[x][y]\\n    goRev(x-1,y,now)\\n    goRev(x,y-1,now)\\n\\n\\ngo(0,0,0)\\ngoRev(n-1,m-1,0)\\n\\nprint(ans)\", \"d = {}\\nans = 0\\nfor i in range(22):\\n    d[i] = {}\\n\\n#print(cnt)\\n\\nn,m,k = list(map(int, input().split()))\\narr = [list(map(int, input().split())) for i in range(n)]\\n\\n\\n\\ndef check(x,y):\\n    if x < 0 or x >= n or y < 0 or y >= m:\\n        return False\\n    else:\\n        return True\\n\\n\\ndef go(x,y,now):\\n    if check(x,y) == False:\\n        return\\n\\n    now ^= arr[x][y]\\n    if x + y == m - 1:\\n        #print('yes')\\n        if now in d[x]:\\n            d[x][now] += 1\\n        else:\\n            d[x][now] = 1\\n        return\\n\\n    go(x+1,y,now)\\n    go(x,y+1,now)\\n\\ndef goRev(x,y,now):\\n    if check(x,y) == False:\\n        return\\n\\n    if x + y == m - 1:\\n        cur = k ^ now\\n        if cur in d[x]:\\n            nonlocal ans\\n            #print(ans)\\n            ans += d[x][cur]\\n        return\\n\\n    now ^= arr[x][y]\\n    goRev(x-1,y,now)\\n    goRev(x,y-1,now)\\n\\n\\ngo(0,0,0)\\ngoRev(n-1,m-1,0)\\n\\nprint(ans)\", \"d = {}\\nans = 0\\nfor i in range(22):\\n    d[i] = {}\\n\\n#print(cnt)\\n\\nn,m,k = list(map(int, input().split()))\\narr = [list(map(int, input().split())) for i in range(n)]\\n\\n\\n\\ndef check(x,y):\\n    if x < 0 or x >= n or y < 0 or y >= m:\\n        return False\\n    else:\\n        return True\\n\\n\\ndef go(x,y,now):\\n    if check(x,y) == False:\\n        return\\n\\n    now ^= arr[x][y]\\n    if x + y == m - 1:\\n        #print('yes')\\n        if now in d[x]:\\n            d[x][now] += 1\\n        else:\\n            d[x][now] = 1\\n        return\\n\\n    go(x+1,y,now)\\n    go(x,y+1,now)\\n\\ndef goRev111(x,y,now):\\n    if check(x,y) == False:\\n        return\\n\\n    if x + y == m - 1:\\n        cur = k ^ now\\n        if cur in d[x]:\\n            nonlocal ans\\n            #print(ans)\\n            ans += d[x][cur]\\n        return\\n\\n    now ^= arr[x][y]\\n    goRev111(x-1,y,now)\\n    goRev111(x,y-1,now)\\n\\n\\ngo(0,0,0)\\ngoRev111(n-1,m-1,0)\\n\\nprint(ans)\", \"d = {}\\nans = 0\\nfor i in range(22):\\n    d[i] = {}\\n\\n#print(cnt)\\n\\nn,m,k = list(map(int, input().split()))\\narr = [list(map(int, input().split())) for i in range(n)]\\n\\n\\n\\ndef check(x,y):\\n    if x < 0 or x >= n or y < 0 or y >= m:\\n        return False\\n    else:\\n        return True\\n\\n\\ndef go(x,y,now):\\n    if check(x,y) == False:\\n        return\\n\\n    now ^= arr[x][y]\\n    if x + y == m - 1:\\n        #print('yes')\\n        if now in d[x]:\\n            d[x][now] += 1\\n        else:\\n            d[x][now] = 1\\n        return\\n\\n    go(x+1,y,now)\\n    go(x,y+1,now)\\n\\ndef goRev(i,j,now):\\n    if check(i,j) == False:\\n        return\\n\\n    if i + j == m - 1:\\n        cur = k ^ now\\n        if cur in d[i]:\\n            nonlocal ans\\n            #print(ans)\\n            ans += d[i][cur]\\n        return\\n\\n    now ^= arr[i][j]\\n    goRev(i-1,j,now)\\n    goRev(i,j-1,now)\\n\\n\\ngo(0,0,0)\\ngoRev(n-1,m-1,0)\\n\\nprint(ans)\", \"\\n\\nd = {}\\nfor i in range(22):\\n    d[i] = {}\\nn,m,k = list(map(int, input().split()))\\nl = [list(map(int, input().split())) for i in range(n)]\\ndef check(x,y):\\n    if x < 0 or x >= n or y < 0 or y >= m:\\n        return False\\n    else:\\n        return True\\n\\ndef go(x,y,now):\\n    if check(x,y) == False:\\n        return\\n\\n    now ^= l[x][y]\\n    if x + y == m - 1:\\n        #print('yes')\\n        if now in d[x]:\\n            d[x][now] += 1\\n        else:\\n            d[x][now] = 1\\n        return\\n\\n    go(x+1,y,now)\\n    go(x,y+1,now)\\n\\nre = 0\\ndef goRev(i,j,now):\\n    if check(i,j) == False:\\n        return\\n\\n    if i + j == m - 1:\\n        cur = k ^ now\\n        if cur in d[i]:\\n            nonlocal re\\n            #print(ans)\\n            re += d[i][cur]\\n        return\\n\\n    now ^= l[i][j]\\n    goRev(i-1,j,now)\\n    goRev(i,j-1,now)\\n\\n\\ngo(0, 0, 0)\\ngoRev(n-1, m-1, 0)\\n#print(d)\\nprint(re)\", \"n, m, k = map(int, input().split())\\nl = [list(map(int, input().split())) for _ in range(n)]\\nre = 0\\nhalf = (m + n - 2) // 2\\nd = [dict() for _ in range(22)]\\n\\n\\ndef forward(i, j, value):\\n    if i >= n or j >= m:\\n        return\\n    value ^= l[i][j]\\n    if i + j == half:\\n        if value in d[i]:\\n            d[i][value] += 1\\n        else:\\n            d[i][value] = 1\\n        return None\\n    forward(i+1, j, value)\\n    forward(i, j+1, value)\\n\\n\\ndef backward(i, j, value):\\n    if i < 0 or j < 0:\\n        return\\n    if i + j == half:\\n        tmp = k^value\\n        #print(tmp)\\n        if tmp in d[i]:\\n            nonlocal re\\n            re += d[i][tmp]\\n        return None\\n    value ^= l[i][j]\\n    backward(i-1, j, value)\\n    backward(i, j-1, value)\\n\\n\\nforward(0, 0, 0)\\nbackward(n-1, m-1, 0)\\n#print(d)\\nprint(re)\", \"from collections import defaultdict\\nn, m, aim = list(map(int, input().split()))\\n\\ng = [[0 for i in range(m + 1)] for j in range(n + 1)]\\n\\nfor i in range(n):\\n    ls = [int(i) for i in input().split()]\\n    for j in range(m):\\n        g[i + 1][j + 1] = ls[j]\\n\\nans = 0\\ndp = defaultdict(int)\\n\\ndef search(x, y, is_l, mk):\\n    if x < 1 or y < 1 or x > n or y > m:\\n        return\\n\\n    if is_l:\\n        mk ^= g[x][y]\\n        if x + y - 1 == n:\\n            dp[(x, y, mk)] += 1\\n        else:\\n            search(x + 1, y, is_l, mk)\\n            search(x, y + 1, is_l, mk)\\n    else:\\n        if abs(x - n) + abs(y - m) + 1 == m:\\n            # print(x, y, mk)\\n            nonlocal ans\\n            ans += dp[(x, y, mk)]\\n        else:\\n            mk ^= g[x][y]\\n            search(x - 1, y, is_l, mk)\\n            search(x, y - 1, is_l, mk)\\n\\nsearch(1, 1, True, 0)\\nsearch(n, m, False, aim)\\n\\nprint(ans)\\n\", \"n, m, k = list(map(int,input().split()))\\nmatrix = []\\nfor _ in range(n):\\n    row = list(map(int, input().split()))\\n    matrix.append(row)\\n# print(matrix)\\nd = [[{} for _ in range(m)] for _ in range(n)]\\n# print(d)\\nmiddle = (n + m - 2) // 2\\n# print(middle)\\nanswer = 0\\n\\ndef upleft(x,y,acc,count):\\n    val = matrix[y][x]^acc\\n    if count == middle:\\n        if d[y][x].get(val) == None:\\n            d[y][x][val] = 1\\n            return\\n        else:\\n            d[y][x][val] += 1\\n            return\\n    else:\\n        if x + 1 < m:\\n            upleft(x+1,y,val,count+1)\\n        if y + 1 < n:\\n            upleft(x,y+1,val,count+1)\\n\\ndef downright(x,y,acc,count):\\n    nonlocal answer\\n    if count == n + m - 2 - middle:\\n        complement = k ^ acc\\n        if d[y][x].get(complement) != None:\\n            answer += d[y][x][complement]\\n        return\\n    else:\\n        val = matrix[y][x]^acc\\n        if x - 1 >= 0:\\n            downright(x-1,y,val,count+1)\\n        if y - 1 >= 0:\\n            downright(x,y-1,val,count+1)\\n\\nupleft(0,0,0,0)\\ndownright(m-1,n-1,0,0)\\n# print(d)\\nprint(answer)\\n\", \"def go_up_to_down(w, h, value, steps):\\n    value ^= matrix[h][w]\\n    if steps == half_steps:\\n        if value not in counts[h][w]:\\n            counts[h][w][value] = 0\\n\\n        counts[h][w][value] += 1\\n        return\\n\\n    if w < width - 1:\\n        go_up_to_down(w + 1, h, value, steps + 1)\\n    if h < height - 1:\\n        go_up_to_down(w, h + 1, value, steps + 1)\\n\\n\\ndef go_down_to_up(w, h, value, steps, count_ways):\\n    if steps == width + height - 2 - half_steps:\\n        if (value ^ res_find) in counts[h][w]:\\n            count_ways += counts[h][w][value ^ res_find]\\n        return count_ways\\n\\n    delta = 0\\n    if w > 0:\\n        delta += go_down_to_up(w - 1, h, value ^ matrix[h][w], steps + 1, count_ways)\\n    if h > 0:\\n        delta += go_down_to_up(w, h - 1, value ^ matrix[h][w], steps + 1, count_ways)\\n\\n    return count_ways + delta\\n\\n\\nheight, width, res_find = [int(num) for num in input().split()]\\nmatrix = []\\n\\nfor h in range(height):\\n    row = [int(num) for num in input().split()]\\n    matrix.append(row)\\n\\ncounts = [[dict()] * width for h in range(height)]\\nhalf_steps = (width + height - 2) // 2\\n\\ngo_up_to_down(0, 0, 0, 0)\\ncount_ways = go_down_to_up(width - 1, height - 1, 0, 0, 0)\\n\\nprint(count_ways)\\n\", \"from collections import defaultdict\\nn, m, k = list(map(int, input().split()))\\na = [[0 for j in range(m)] for i in range(n)]\\n\\nfor i in range(n):\\n    a[i] = list(map(int, input().split()))\\n\\ntotal = n + m - 2\\nhalf = total // 2\\nb = defaultdict(dict)\\n\\n\\ndef upper(i, j, val, cnt):\\n    val ^= a[i][j]\\n    if cnt == half:\\n        s = str(i) + ' ' + str(j)\\n        if val in b[s]:\\n            b[s][val] += 1\\n        else:\\n            b[s][val] = 1\\n        return\\n    if i + 1 < n:\\n        upper(i + 1, j, val, cnt + 1)\\n    if j + 1 < m:\\n        upper(i, j + 1, val, cnt + 1)\\n\\n\\nanswer = 0\\n\\ndef lower(i, j, val, cnt):\\n    nonlocal answer\\n    s = str(i) + ' ' + str(j)\\n    if cnt == total - half:\\n        aim = k ^ val\\n        if aim in b[s]:\\n            answer += b[s][aim]\\n        return\\n    if i > 0:\\n        lower(i - 1, j, val ^ a[i][j], cnt + 1)\\n    if j > 0:\\n        lower(i, j - 1, val ^ a[i][j], cnt + 1)\\n\\n\\nupper(0, 0, 0, 0)\\nlower(n - 1, m - 1, 0, 0)\\n\\nprint(answer)\\n\\n\\n\\n\", \"n, m, k = list(map(int, input().split()))\\na = []\\nfor i in range(n):\\n    a.append(list(map(int, input().split())))\\nif n > m:\\n    d = []\\n    for i in range(m):\\n        d.append([])\\n        for j in range(n):\\n            d[i].append(a[j][i])\\n    a = d\\n    n, m = m, n\\n\\nb = []\\nfor i in range(n):\\n    temp = []\\n    for j in range(m):\\n        temp.append([])\\n    b.append(temp)\\nfor i in range((n + m) // 2):\\n    for j in range(min(i + 1, m, n)):\\n        if i == 0:\\n            b[j][i - j].append(a[j][i - j])\\n        elif j == 0:\\n            b[j][i - j].append(b[j][i - j - 1][0] ^ a[j][i - j])\\n        elif j == i:\\n            b[j][i - j].append(b[j - 1][i - j][0] ^ a[j][i - j])\\n        else:\\n            for x in b[j][i - j - 1] + b[j - 1][i - j]:\\n                b[j][i - j].append(x ^ a[j][i - j])\\nc = []\\nfor i in range(n):\\n    temp = []\\n    for j in range(m):\\n        temp.append([])\\n    c.append(temp)\\nfor i in range((n + m + 1) // 2):\\n    for j in range(min(i + 1, m, n)):\\n        if i == 0:\\n            c[(n - 1) - j][(m - 1) - (i - j)].append(k)\\n        elif j == 0:\\n            c[(n - 1) - j][(m - 1) - (i - j)].append(c[(n - 1) - j][(m - 1) - (i - j - 1)][0] ^ a[(n - 1) - j][(m - 1) - (i - j - 1)])\\n        elif j == i:\\n            c[(n - 1) - j][(m - 1) - (i - j)].append(c[(n - 1) - (j - 1)][(m - 1) - (i - j)][0] ^ a[(n - 1) - (j - 1)][(m - 1) - (i - j)])\\n        else:\\n            for x in c[(n - 1) - j][(m - 1) - (i - j - 1)]:\\n                c[(n - 1) - j][(m - 1) - (i - j)].append(x ^ a[(n - 1) - j][(m - 1) - (i - j - 1)])\\n            for x in c[(n - 1) - (j - 1)][(m - 1) - (i - j)]:\\n                c[(n - 1) - j][(m - 1) - (i - j)].append(x ^ a[(n - 1) - (j - 1)][(m - 1) - (i - j)])\\n\\nwae = 0\\ni = (n + m) // 2 - 1\\nfor j in range(min(m, n)):\\n    d = {}\\n    e = {}\\n    for l1 in b[j][i - j]:\\n        if not l1 in d:\\n            d[l1] = 0\\n        d[l1] += 1\\n    for l2 in c[j][i - j]:\\n        if not l2 in e:\\n            e[l2] = 0\\n        e[l2] += 1\\n    for key in list(d.keys()):\\n        if key in d and key in e:\\n            wae += d[key] * e[key]\\n\\nprint(wae)\\n\", \"import math\\nfrom collections import defaultdict\\nimport sys\\n\\n\\ndef main():\\n    n, m, k = list(map(int, input().split()))\\n    g = [[] for _ in range(n)]\\n    for i in range(n):\\n        g[i] = list(map(int, input().split()))\\n\\n    cnt = [[defaultdict(int) for _ in range(m)] for _ in range(n)]\\n\\n    all = n + m - 2\\n    half = all // 2\\n    res = [0]\\n\\n    def go_start(x, y, val, steps):\\n        val ^= g[x][y]\\n        if steps == half:\\n            cnt[x][y][val] += 1\\n            return\\n\\n        if x+1 < n:\\n            go_start(x + 1, y, val, steps + 1)\\n\\n        if y+1 < m:\\n            go_start(x, y+1, val, steps + 1)\\n\\n    def go_end(x, y, val, steps):\\n        if steps + half == all:\\n            comp = k ^ val\\n            if comp in cnt[x][y]:\\n                res[0] += cnt[x][y][comp]\\n            return\\n\\n        val ^= g[x][y]\\n\\n        if x > 0:\\n            go_end(x-1, y, val, steps + 1)\\n        if y > 0:\\n            go_end(x, y-1, val, steps + 1)\\n\\n    go_start(0, 0, 0, 0)\\n    go_end(n-1, m-1, 0, 0)\\n\\n    print(res[0])\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"n,m,k = list(map(int, input().split()))\\nA = [list(map(int, input().split())) for _ in range(n)]\\n\\nif n == 1 and m == 1:\\n    if A[0][0] == k:\\n        print(1)\\n    else:\\n        print(0)\\n    return\\n\\nimport itertools\\nans = 0\\ns = (n-1+m-1)//2\\nt = (n-1+m-1)-s\\n#print(s, t)\\nfrom collections import defaultdict\\nDS = [defaultdict(lambda :0) for key in range(n)]\\nfor i in range(2**s):\\n    L = [0]*s\\n    for j in range(s):\\n        if (i >> j) & 1:\\n            L[j] = 1\\n    key = sum(L)\\n    if key > n-1:\\n        continue\\n    y = 0\\n    x = 0\\n    res = A[0][0]\\n    for l in L:\\n        if l == 1:\\n            y += 1\\n        else:\\n            x += 1\\n        if 0 <= y < n and 0 <= x < m:\\n            res ^= A[y][x]\\n        else:\\n            break\\n    else:\\n        DS[key][res] += 1\\n#print(DS)\\nans = 0\\nfor i in range(2**t):\\n    L = [0]*t\\n    for j in range(t):\\n        if (i >> j) & 1:\\n            L[j] = 1\\n    tkey = sum(L)\\n    if tkey > n-1:\\n        continue\\n    y = n-1\\n    x = m-1\\n    res = A[n-1][m-1]\\n    for idx, l in enumerate(L):\\n        if idx == len(L)-1:\\n            continue\\n        if l == 1:\\n            y -= 1\\n        else:\\n            x -= 1\\n        if 0 <= y < n and 0 <= x < m:\\n            res ^= A[y][x]\\n        else:\\n            break\\n    else:\\n        skey = n-1-tkey\\n        sres = res^k\\n        #print(skey, sres)\\n        ans += DS[skey][sres]\\nprint(ans)\\n\"]", "task": "apps", "difficulty": "introductory", "split": "test", "transformation_type": "vanilla"}