{"qid": 4000, "orig_input": "You are given an unweighted tree with $n$ vertices. Recall that a tree is a connected undirected graph without cycles.\n\nYour task is to choose three distinct vertices $a, b, c$ on this tree such that the number of edges which belong to at least one of the simple paths between $a$ and $b$, $b$ and $c$, or $a$ and $c$ is the maximum possible. See the notes section for a better understanding.\n\nThe simple path is the path that visits each vertex at most once.\n\n\n-----Input-----\n\nThe first line contains one integer number $n$ ($3 \\le n \\le 2 \\cdot 10^5$) \u2014 the number of vertices in the tree. \n\nNext $n - 1$ lines describe the edges of the tree in form $a_i, b_i$ ($1 \\le a_i$, $b_i \\le n$, $a_i \\ne b_i$). It is guaranteed that given graph is a tree.\n\n\n-----Output-----\n\nIn the first line print one integer $res$ \u2014 the maximum number of edges which belong to at least one of the simple paths between $a$ and $b$, $b$ and $c$, or $a$ and $c$.\n\nIn the second line print three integers $a, b, c$ such that $1 \\le a, b, c \\le n$ and $a \\ne, b \\ne c, a \\ne c$.\n\nIf there are several answers, you can print any.\n\n\n-----Example-----\nInput\n8\n1 2\n2 3\n3 4\n4 5\n4 6\n3 7\n3 8\n\nOutput\n5\n1 8 6\n\n\n\n-----Note-----\n\nThe picture corresponding to the first example (and another one correct answer):\n\n[Image]\n\nIf you choose vertices $1, 5, 6$ then the path between $1$ and $5$ consists of edges $(1, 2), (2, 3), (3, 4), (4, 5)$, the path between $1$ and $6$ consists of edges $(1, 2), (2, 3), (3, 4), (4, 6)$ and the path between $5$ and $6$ consists of edges $(4, 5), (4, 6)$. The union of these paths is $(1, 2), (2, 3), (3, 4), (4, 5), (4, 6)$ so the answer is $5$. It can be shown that there is no better answer.", "input": "You are given an unweighted tree with $n$ vertices. Recall that a tree is a connected undirected graph without cycles.\n\nYour task is to choose three distinct vertices $a, b, c$ on this tree such that the number of edges which belong to at least one of the simple paths between $a$ and $b$, $b$ and $c$, or $a$ and $c$ is the maximum possible. See the notes section for a better understanding.\n\nThe simple path is the path that visits each vertex at most once.\n\n\n-----Input-----\n\nThe first line contains one integer number $n$ ($3 \\le n \\le 2 \\cdot 10^5$) \u2014 the number of vertices in the tree. \n\nNext $n - 1$ lines describe the edges of the tree in form $a_i, b_i$ ($1 \\le a_i$, $b_i \\le n$, $a_i \\ne b_i$). It is guaranteed that given graph is a tree.\n\n\n-----Output-----\n\nIn the first line print one integer $res$ \u2014 the maximum number of edges which belong to at least one of the simple paths between $a$ and $b$, $b$ and $c$, or $a$ and $c$.\n\nIn the second line print three integers $a, b, c$ such that $1 \\le a, b, c \\le n$ and $a \\ne, b \\ne c, a \\ne c$.\n\nIf there are several answers, you can print any.\n\n\n-----Example-----\nInput\n8\n1 2\n2 3\n3 4\n4 5\n4 6\n3 7\n3 8\n\nOutput\n5\n1 8 6\n\n\n\n-----Note-----\n\nThe picture corresponding to the first example (and another one correct answer):\n\n[Image]\n\nIf you choose vertices $1, 5, 6$ then the path between $1$ and $5$ consists of edges $(1, 2), (2, 3), (3, 4), (4, 5)$, the path between $1$ and $6$ consists of edges $(1, 2), (2, 3), (3, 4), (4, 6)$ and the path between $5$ and $6$ consists of edges $(4, 5), (4, 6)$. The union of these paths is $(1, 2), (2, 3), (3, 4), (4, 5), (4, 6)$ so the answer is $5$. It can be shown that there is no better answer.", "test_cases": {"inputs": ["8\n1 2\n2 3\n3 4\n4 5\n4 6\n3 7\n3 8\n", "5\n3 2\n3 5\n2 4\n1 3\n", "4\n1 2\n2 3\n3 4\n", "6\n1 2\n1 3\n2 4\n2 5\n3 6\n", "4\n4 3\n3 1\n1 2\n", "3\n1 2\n1 3\n", "3\n1 2\n1 3\n", "3\n3 1\n1 2\n", "3\n1 3\n1 2\n", "3\n1 2\n1 3\n", "3\n1 2\n1 3\n", "3\n3 1\n3 2\n", "3\n1 3\n2 1\n", "3\n1 3\n1 2\n", "3\n3 1\n2 1\n", "3\n1 2\n1 3\n", "3\n2 1\n3 1\n", "3\n2 3\n3 1\n", "3\n1 3\n3 2\n", "3\n1 3\n1 2\n", "3\n3 2\n1 3\n", "3\n1 2\n3 1\n", "3\n1 2\n1 3\n", "3\n3 2\n2 1\n", "3\n3 2\n3 1\n", "3\n1 2\n2 3\n", "3\n3 1\n3 2\n", "3\n2 3\n1 3\n", "3\n1 2\n3 2\n", "3\n3 2\n3 1\n", "3\n3 2\n1 2\n", "3\n2 3\n2 1\n", "3\n3 2\n1 3\n", "3\n2 3\n3 1\n", "3\n2 3\n2 1\n", "3\n1 2\n2 3\n", "3\n2 3\n3 1\n", "3\n3 2\n3 1\n", "3\n2 3\n2 1\n", "3\n2 3\n3 1\n", "4\n1 3\n1 2\n1 4\n", "4\n1 3\n3 4\n2 3\n", "4\n1 2\n1 3\n1 4\n", "4\n1 4\n1 3\n2 1\n", "4\n4 1\n1 2\n3 1\n", "4\n3 1\n4 1\n2 1\n", "4\n4 1\n1 2\n1 3\n", "4\n1 4\n3 1\n1 2\n", "4\n1 3\n4 1\n3 2\n", "4\n1 4\n3 4\n1 2\n", "4\n2 1\n1 4\n2 3\n", "4\n4 1\n3 1\n1 2\n", "4\n2 1\n3 1\n4 1\n", "4\n1 3\n1 4\n3 2\n", "4\n4 1\n1 2\n3 1\n", "4\n4 1\n4 2\n3 1\n", "4\n1 4\n3 2\n3 4\n", "4\n3 2\n1 2\n4 1\n", "4\n2 1\n1 4\n2 3\n", "4\n3 4\n2 4\n3 1\n", "4\n1 4\n3 4\n2 4\n", "4\n3 1\n2 3\n2 4\n", "4\n2 3\n1 2\n1 4\n", "4\n4 1\n2 3\n1 3\n", "4\n2 1\n2 3\n4 3\n", "4\n4 1\n2 4\n1 3\n", "4\n4 2\n1 3\n3 4\n", "4\n2 3\n4 2\n1 3\n", "4\n2 3\n1 4\n4 2\n", "4\n3 4\n2 4\n1 4\n", "4\n2 3\n3 1\n2 4\n", "4\n2 3\n4 1\n4 3\n", "4\n2 3\n3 1\n4 2\n", "4\n2 1\n4 3\n3 2\n", "4\n4 1\n4 2\n3 4\n", "5\n1 3\n3 2\n5 1\n1 4\n", "5\n1 3\n1 2\n4 1\n1 5\n", "5\n1 5\n4 1\n1 2\n1 3\n", "5\n1 2\n1 4\n5 1\n1 3\n", "5\n2 1\n3 1\n4 1\n5 1\n", "5\n5 1\n4 2\n4 1\n1 3\n", "5\n3 1\n2 1\n1 5\n4 1\n", "5\n1 5\n3 1\n1 4\n2 1\n", "5\n2 3\n1 5\n4 1\n3 1\n", "5\n1 2\n4 1\n3 1\n1 5\n", "5\n5 4\n1 4\n1 2\n3 4\n", "5\n5 1\n5 4\n4 3\n1 2\n", "5\n2 4\n4 1\n1 3\n1 5\n", "5\n3 1\n2 1\n1 5\n1 4\n", "5\n1 4\n2 1\n5 1\n5 3\n", "5\n1 5\n3 4\n2 3\n1 3\n", "5\n2 5\n5 3\n1 3\n2 4\n", "5\n3 1\n5 1\n2 1\n4 2\n", "5\n1 3\n5 3\n2 1\n1 4\n", "5\n3 5\n3 1\n2 1\n4 3\n", "5\n2 3\n2 1\n1 5\n4 2\n", "5\n5 2\n4 5\n1 2\n3 5\n", "5\n5 3\n2 4\n1 2\n4 3\n", "5\n4 1\n1 5\n3 5\n2 5\n", "5\n5 3\n4 2\n1 2\n2 5\n", "5\n5 1\n2 3\n5 4\n3 5\n", "5\n4 5\n1 5\n2 5\n2 3\n", "5\n5 1\n4 2\n5 4\n3 5\n", "5\n1 5\n2 3\n2 5\n3 4\n", "5\n2 3\n4 1\n5 4\n5 2\n", "5\n5 4\n2 3\n2 5\n1 3\n", "5\n5 4\n5 2\n1 3\n4 3\n", "5\n2 5\n2 1\n3 2\n4 3\n", "5\n4 5\n2 1\n3 2\n5 3\n", "5\n5 2\n4 3\n1 2\n2 4\n", "6\n4 2\n5 1\n6 1\n2 1\n1 3\n", "6\n2 1\n1 4\n1 6\n1 3\n5 1\n", "6\n5 1\n1 4\n2 3\n1 6\n1 3\n", "6\n1 5\n1 3\n6 1\n4 1\n1 2\n", "6\n1 2\n5 3\n3 4\n1 3\n6 3\n", "6\n2 4\n4 1\n4 3\n5 4\n1 6\n", "6\n2 1\n5 1\n1 4\n6 1\n1 3\n", "6\n1 3\n5 1\n2 4\n1 2\n1 6\n", "6\n1 5\n1 6\n4 1\n1 2\n3 1\n", "6\n5 6\n4 1\n3 1\n6 1\n2 6\n", "6\n6 1\n5 4\n1 3\n1 5\n5 2\n", "6\n1 6\n6 3\n4 3\n5 6\n2 1\n", "6\n2 3\n1 6\n1 3\n1 4\n5 6\n", "6\n5 1\n3 1\n4 1\n1 6\n2 6\n", "6\n2 1\n1 6\n3 1\n4 2\n2 5\n", "6\n1 3\n1 6\n6 4\n5 1\n2 5\n", "6\n2 5\n4 1\n2 1\n1 6\n3 4\n", "6\n2 4\n6 1\n5 1\n6 2\n3 6\n", "6\n1 5\n1 6\n6 2\n1 4\n4 3\n", "6\n1 4\n5 3\n3 1\n2 5\n1 6\n", "6\n5 3\n5 4\n2 1\n2 4\n6 4\n", "6\n4 3\n5 6\n6 1\n5 2\n6 3\n", "6\n5 3\n3 1\n5 6\n4 5\n2 3\n", "6\n4 3\n4 2\n2 1\n2 6\n5 4\n", "6\n3 6\n6 2\n6 5\n2 1\n6 4\n", "6\n5 4\n5 3\n2 4\n5 6\n2 1\n", "6\n6 3\n4 2\n6 5\n4 1\n2 5\n", "6\n5 3\n4 6\n6 2\n1 2\n2 3\n", "6\n1 4\n6 2\n2 5\n3 5\n2 4\n", "6\n2 4\n3 6\n5 1\n3 5\n6 2\n", "6\n5 4\n6 2\n1 5\n4 6\n5 3\n", "6\n6 2\n3 5\n4 2\n5 4\n1 2\n", "6\n1 4\n2 3\n5 6\n5 3\n2 4\n", "6\n6 4\n4 1\n5 6\n3 2\n4 2\n", "6\n6 1\n5 6\n5 3\n2 5\n2 4\n", "7\n1 7\n6 1\n5 1\n2 1\n3 2\n2 4\n", "7\n3 1\n6 1\n4 1\n1 5\n5 2\n1 7\n", "7\n7 1\n5 1\n1 3\n1 2\n6 1\n4 7\n", "7\n1 7\n2 1\n1 5\n4 1\n3 1\n5 6\n", "7\n3 1\n1 5\n1 7\n1 4\n6 1\n2 1\n", "7\n1 4\n7 4\n5 1\n3 2\n6 4\n3 1\n", "7\n1 3\n6 1\n1 7\n1 4\n5 4\n1 2\n", "7\n5 1\n6 1\n2 1\n1 3\n1 7\n1 4\n", "7\n5 1\n5 7\n1 2\n5 6\n3 1\n4 5\n", "7\n1 4\n6 1\n2 1\n7 5\n1 7\n1 3\n", "7\n1 2\n7 3\n1 6\n5 1\n2 7\n4 6\n", "7\n2 6\n5 6\n4 1\n1 7\n1 6\n3 5\n", "7\n3 2\n1 4\n3 1\n1 6\n7 1\n5 4\n", "7\n1 5\n4 1\n2 1\n2 3\n1 7\n6 2\n", "7\n7 2\n3 4\n4 2\n7 1\n6 7\n5 7\n", "7\n1 6\n3 1\n5 6\n1 4\n1 2\n1 7\n", "7\n2 7\n4 6\n7 1\n5 1\n3 1\n7 6\n", "7\n3 2\n5 1\n3 5\n2 7\n3 6\n4 2\n", "7\n4 1\n4 3\n7 5\n1 6\n7 4\n2 6\n", "7\n5 3\n2 4\n6 1\n4 7\n3 1\n2 3\n", "7\n1 7\n6 5\n4 3\n7 4\n2 5\n5 4\n", "7\n1 4\n3 6\n6 7\n3 5\n4 2\n2 7\n", "7\n2 7\n2 4\n1 3\n5 6\n5 3\n3 2\n", "7\n4 2\n6 3\n5 1\n6 1\n7 4\n6 4\n", "7\n3 2\n1 7\n7 2\n6 5\n6 1\n4 5\n", "7\n3 2\n3 5\n4 7\n3 6\n4 5\n5 1\n", "7\n7 6\n7 1\n4 2\n4 5\n7 3\n5 3\n", "7\n1 2\n3 6\n6 5\n4 3\n7 5\n2 6\n", "7\n2 7\n6 7\n5 4\n1 2\n5 3\n3 6\n", "7\n1 5\n4 2\n5 3\n6 5\n7 2\n1 2\n", "7\n5 2\n3 6\n7 1\n3 7\n3 4\n2 6\n", "7\n1 5\n3 5\n7 2\n7 6\n3 7\n4 5\n", "7\n7 6\n2 1\n6 5\n3 2\n3 6\n7 4\n", "7\n7 6\n2 3\n3 6\n5 4\n4 2\n1 5\n", "7\n2 4\n7 1\n6 5\n3 6\n2 7\n7 6\n", "8\n1 5\n1 8\n7 1\n1 6\n1 2\n4 2\n1 3\n", "8\n6 1\n2 1\n5 4\n8 1\n7 3\n7 1\n4 7\n", "8\n6 8\n1 8\n8 2\n1 7\n5 7\n1 3\n4 1\n", "8\n2 1\n6 1\n4 1\n7 1\n1 3\n1 5\n1 8\n", "8\n1 8\n2 1\n1 7\n1 5\n1 3\n4 8\n1 6\n", "8\n2 1\n2 8\n7 8\n5 1\n2 6\n3 1\n4 6\n", "8\n6 4\n7 6\n1 5\n1 3\n1 6\n8 1\n2 7\n", "8\n8 5\n6 4\n2 4\n1 5\n1 7\n1 4\n4 3\n", "8\n6 5\n7 4\n1 3\n8 7\n1 7\n2 1\n6 1\n", "8\n7 3\n2 8\n4 1\n1 3\n2 1\n6 3\n5 1\n", "8\n1 4\n6 5\n1 6\n7 1\n2 1\n3 6\n5 8\n", "8\n4 8\n4 6\n1 3\n7 4\n7 5\n1 4\n1 2\n", "8\n7 8\n5 4\n8 1\n8 6\n1 2\n4 3\n1 4\n", "8\n2 3\n6 5\n1 7\n2 1\n4 6\n8 4\n1 6\n", "8\n5 3\n4 2\n6 5\n8 1\n5 1\n7 8\n1 2\n", "8\n7 3\n5 6\n6 1\n7 4\n6 2\n2 8\n6 4\n", "8\n8 3\n4 2\n4 1\n1 7\n1 3\n6 2\n8 5\n", "8\n5 1\n1 6\n6 3\n4 3\n5 2\n1 7\n3 8\n", "8\n5 1\n7 2\n4 3\n8 5\n7 1\n4 6\n5 4\n", "8\n8 7\n3 2\n1 3\n6 4\n1 8\n1 4\n8 5\n", "8\n7 2\n5 4\n2 6\n1 3\n3 2\n4 2\n4 8\n", "8\n3 5\n3 6\n8 7\n2 7\n2 1\n2 6\n1 4\n", "8\n1 8\n5 4\n2 5\n6 3\n1 5\n1 7\n8 6\n", "8\n1 7\n6 7\n2 3\n8 4\n5 7\n2 1\n6 8\n", "8\n8 1\n3 4\n6 4\n3 5\n2 4\n8 4\n7 3\n", "8\n2 3\n4 7\n3 7\n2 6\n5 6\n4 1\n3 8\n", "8\n3 6\n8 2\n3 1\n8 4\n8 7\n6 4\n1 5\n", "8\n1 6\n2 7\n4 5\n6 5\n4 8\n2 5\n3 7\n", "8\n2 3\n6 5\n1 8\n4 5\n4 8\n7 6\n2 6\n", "8\n1 2\n5 8\n6 8\n4 5\n6 2\n3 7\n7 4\n", "8\n1 7\n2 8\n7 8\n4 5\n3 4\n1 5\n6 3\n", "8\n2 8\n8 1\n5 7\n6 4\n4 7\n7 2\n7 3\n", "8\n8 5\n6 3\n8 3\n7 2\n1 2\n5 4\n6 7\n", "8\n6 7\n5 8\n4 1\n3 5\n3 6\n7 2\n4 2\n", "8\n6 7\n6 8\n1 3\n2 3\n5 6\n8 4\n7 3\n", "9\n3 1\n7 4\n1 4\n1 8\n2 1\n2 6\n9 1\n1 5\n", "9\n8 9\n6 2\n1 6\n1 4\n3 1\n9 1\n1 5\n1 7\n", "9\n3 9\n5 1\n4 1\n7 6\n3 1\n3 2\n8 1\n7 1\n", "9\n1 3\n6 4\n4 1\n5 1\n7 5\n1 9\n8 5\n1 2\n", "9\n4 1\n8 2\n6 1\n1 5\n3 1\n6 7\n9 5\n1 2\n", "9\n1 9\n4 9\n7 1\n3 2\n1 2\n1 6\n1 8\n2 5\n", "9\n4 1\n2 9\n1 2\n8 1\n9 5\n3 2\n7 6\n7 1\n", "9\n8 4\n5 8\n3 1\n2 8\n1 7\n9 8\n1 6\n1 8\n", "9\n8 3\n6 8\n9 4\n1 8\n8 5\n9 3\n2 1\n1 7\n", "9\n1 8\n5 1\n4 3\n9 1\n2 1\n1 4\n7 1\n6 1\n", "9\n7 2\n2 4\n5 8\n8 3\n2 1\n1 6\n6 9\n1 8\n", "9\n5 1\n8 1\n2 1\n4 1\n3 4\n1 7\n7 6\n5 9\n", "9\n8 1\n9 6\n6 1\n1 3\n2 1\n7 2\n1 4\n4 5\n", "9\n1 2\n9 8\n5 8\n7 5\n6 2\n5 3\n1 4\n1 5\n", "9\n7 1\n6 5\n1 8\n4 9\n2 8\n4 1\n3 8\n8 6\n", "9\n3 7\n3 9\n1 5\n6 1\n1 2\n4 3\n8 2\n3 2\n", "9\n6 2\n3 7\n5 1\n6 5\n3 1\n9 4\n6 8\n4 3\n", "9\n4 3\n6 9\n1 9\n1 3\n5 1\n7 1\n8 7\n2 5\n", "9\n3 5\n9 1\n4 1\n7 4\n3 8\n2 6\n9 2\n3 2\n", "9\n4 2\n9 5\n1 4\n1 7\n4 9\n5 3\n3 6\n9 8\n", "9\n5 2\n3 9\n2 4\n7 8\n5 6\n9 8\n1 2\n9 4\n", "9\n5 8\n8 9\n2 6\n2 7\n3 6\n2 1\n8 1\n4 9\n", "9\n4 2\n2 6\n4 1\n8 5\n8 7\n6 5\n3 4\n9 2\n", "9\n1 4\n5 8\n8 7\n3 4\n6 3\n5 3\n2 4\n2 9\n", "9\n3 6\n9 7\n1 6\n2 8\n7 4\n9 5\n8 6\n3 9\n", "9\n7 9\n6 7\n4 6\n3 9\n9 8\n2 5\n2 8\n1 2\n", "9\n9 3\n5 8\n2 7\n2 3\n9 6\n1 7\n4 5\n4 2\n", "9\n2 7\n3 7\n8 2\n6 7\n1 3\n2 9\n5 2\n4 6\n", "9\n9 2\n6 8\n4 1\n2 5\n1 9\n8 7\n3 6\n5 7\n", "9\n4 3\n6 9\n4 8\n6 5\n7 5\n1 6\n8 5\n7 2\n", "9\n6 7\n8 6\n1 4\n3 8\n4 7\n5 6\n9 3\n2 7\n", "9\n6 4\n9 5\n7 8\n1 8\n9 3\n4 2\n7 5\n7 4\n", "9\n9 2\n3 8\n4 6\n7 9\n2 5\n5 3\n1 6\n9 1\n", "9\n6 9\n1 3\n6 7\n2 8\n4 6\n2 6\n5 2\n3 7\n", "9\n1 8\n6 9\n6 7\n4 3\n3 5\n8 7\n2 6\n9 3\n"], "outputs": ["5\n1 8 6\n", "4\n5 1 4\n", "3 \n1 2 4\n", "5\n5 4 6\n", "3 \n2 1 4\n", "2 \n2 1 3\n", "2 \n2 1 3\n", "2 \n2 1 3\n", "2 \n2 1 3\n", "2 \n2 1 3\n", "2 \n2 1 3\n", "2 \n1 3 2\n", "2 \n2 1 3\n", "2 \n2 1 3\n", "2 \n2 1 3\n", "2 \n2 1 3\n", "2 \n2 1 3\n", "2 \n1 3 2\n", "2 \n1 3 2\n", "2 \n2 1 3\n", "2 \n1 3 2\n", "2 \n2 1 3\n", "2 \n2 1 3\n", "2 \n1 2 3\n", "2 \n1 3 2\n", "2 \n1 2 3\n", "2 \n1 3 2\n", "2 \n1 3 2\n", "2 \n1 2 3\n", "2 \n1 3 2\n", "2 \n1 2 3\n", "2 \n1 2 3\n", "2 \n1 3 2\n", "2 \n1 3 2\n", "2 \n1 2 3\n", "2 \n1 2 3\n", "2 \n1 3 2\n", "2 \n1 3 2\n", "2 \n1 2 3\n", "2 \n1 3 2\n", "3\n3 2 4\n", "3\n2 1 4\n", "3\n3 2 4\n", "3\n3 2 4\n", "3\n3 2 4\n", "3\n3 2 4\n", "3\n3 2 4\n", "3\n3 2 4\n", "3 \n4 1 2\n", "3 \n2 1 3\n", "3 \n4 1 3\n", "3\n3 2 4\n", "3\n3 2 4\n", "3 \n4 1 2\n", "3\n3 2 4\n", "3 \n3 1 2\n", "3 \n1 4 2\n", "3 \n4 1 3\n", "3 \n4 1 3\n", "3 \n1 3 2\n", "3\n2 1 3\n", "3 \n1 3 4\n", "3 \n4 1 3\n", "3 \n4 1 2\n", "3 \n1 2 4\n", "3 \n3 1 2\n", "3 \n1 3 2\n", "3 \n1 3 4\n", "3 \n1 4 3\n", "3\n2 1 3\n", "3 \n1 3 4\n", "3 \n1 4 2\n", "3 \n1 3 4\n", "3 \n1 2 4\n", "3\n2 1 3\n", "4\n5 4 2\n", "3\n4 3 5\n", "3\n4 3 5\n", "3\n4 3 5\n", "3\n4 3 5\n", "4\n5 3 2\n", "3\n4 3 5\n", "3\n4 3 5\n", "4\n5 4 2\n", "3\n4 3 5\n", "4\n2 3 5\n", "4 \n2 1 3\n", "4\n5 3 2\n", "3\n4 3 5\n", "4\n4 2 3\n", "4\n5 2 4\n", "4 \n1 3 4\n", "4\n5 3 4\n", "4\n4 2 5\n", "4\n2 4 5\n", "4\n5 3 4\n", "4\n1 3 4\n", "4 \n1 2 5\n", "4\n4 2 3\n", "4\n4 1 3\n", "4\n4 1 2\n", "4\n4 1 3\n", "4\n3 1 2\n", "4 \n1 5 4\n", "4 \n1 4 3\n", "4 \n1 3 4\n", "4 \n1 3 2\n", "4\n5 1 4\n", "4 \n1 2 4\n", "4\n5 1 3\n", "4\n6 5 4\n", "3\n5 4 6\n", "4\n6 5 2\n", "3\n5 4 6\n", "4\n2 5 6\n", "4\n6 3 5\n", "3\n5 4 6\n", "4\n6 5 4\n", "3\n5 4 6\n", "4\n4 3 5\n", "4\n6 3 4\n", "5\n2 5 4\n", "5\n2 4 5\n", "4\n5 4 2\n", "4\n6 4 5\n", "5\n2 3 4\n", "5\n3 6 5\n", "5\n5 3 4\n", "5\n2 5 3\n", "5\n6 4 2\n", "5\n1 6 3\n", "5\n2 1 4\n", "4\n2 4 6\n", "4\n6 3 5\n", "4\n1 4 5\n", "5\n1 3 6\n", "5 \n1 4 3\n", "5\n4 1 5\n", "5\n1 6 3\n", "5 \n1 5 4\n", "5\n3 1 2\n", "5\n6 1 3\n", "5 \n1 4 6\n", "5\n3 1 5\n", "5\n1 3 4\n", "4\n7 6 4\n", "4\n7 6 2\n", "4\n6 5 4\n", "4\n7 4 6\n", "3\n6 5 7\n", "5\n2 6 7\n", "4\n7 6 5\n", "3\n6 5 7\n", "4\n3 6 7\n", "4\n6 4 5\n", "6\n4 5 3\n", "5\n7 4 3\n", "5\n2 7 5\n", "4\n7 5 6\n", "5\n6 5 3\n", "4\n7 4 5\n", "5\n5 3 4\n", "5\n1 6 7\n", "6\n2 3 5\n", "6\n6 5 7\n", "5\n1 3 6\n", "6 \n1 4 5\n", "5\n6 4 7\n", "5\n5 3 7\n", "6 \n3 2 4\n", "5\n6 2 7\n", "6\n6 1 2\n", "6\n4 1 7\n", "6 \n1 2 4\n", "5\n6 4 7\n", "6\n1 4 5\n", "5\n4 2 6\n", "6\n1 5 4\n", "6 \n1 5 7\n", "5\n4 3 5\n", "4\n8 7 4\n", "5\n8 6 5\n", "5\n5 4 6\n", "3\n7 6 8\n", "4\n7 6 4\n", "6\n5 4 7\n", "5\n8 5 2\n", "5\n6 7 8\n", "5\n5 4 8\n", "5\n7 6 8\n", "5\n7 4 8\n", "5\n3 8 5\n", "5\n5 6 7\n", "6\n3 7 8\n", "6\n6 4 7\n", "6\n8 5 3\n", "7\n5 7 6\n", "6\n2 7 8\n", "6\n2 8 6\n", "6\n6 2 7\n", "5\n1 7 8\n", "7\n8 4 5\n", "6\n4 7 3\n", "7\n3 5 4\n", "5\n1 6 7\n", "7\n1 8 5\n", "7\n5 2 7\n", "7\n8 1 3\n", "7\n1 7 3\n", "7 \n1 2 3\n", "7 \n2 8 6\n", "6\n1 5 6\n", "7 \n1 2 4\n", "7 \n1 4 8\n", "6\n2 5 4\n", "5\n6 9 7\n", "5\n2 7 8\n", "5\n6 8 9\n", "5\n6 9 8\n", "6\n8 7 9\n", "5\n4 8 5\n", "6\n6 8 5\n", "4\n7 6 9\n", "6\n7 6 4\n", "4\n9 8 3\n", "6\n7 5 9\n", "6\n6 3 9\n", "6\n7 5 9\n", "6\n6 7 9\n", "6\n9 7 5\n", "5\n6 8 9\n", "7\n8 7 9\n", "6\n6 4 8\n", "7\n7 6 8\n", "7\n7 8 6\n", "7\n6 3 7\n", "7\n3 7 4\n", "7\n3 9 7\n", "7\n9 6 7\n", "7\n2 5 4\n", "7\n5 3 4\n", "8\n6 1 8\n", "6\n4 1 9\n", "8 \n4 1 3\n", "7\n9 2 3\n", "7\n1 5 9\n", "7\n6 1 3\n", "8\n4 7 8\n", "6\n1 9 8\n", "7\n1 4 5\n"]}, "solutions": "[\"import sys\\ninput = sys.stdin.readline\\n\\nNEGINF = -1000000\\n\\nn = int(input())\\nadj = [[] for i in range(n)]\\nparent = [-1] * n\\n\\nvisited = [False] * n\\nfor _ in range(n - 1):\\n    a, b = list(map(int, input().split()))\\n    adj[a - 1].append(b - 1)\\n    adj[b - 1].append(a - 1)\\n\\ntup = tuple()\\nouts = [tup] * n\\nq = [(0, 0)]\\n\\nwhile q:\\n    node, type = q.pop()\\n    if type == 0:\\n        visited[node] = True\\n        q.append((node, 1))\\n        for v in adj[node]:\\n            if not visited[v]:\\n                parent[v] = node\\n                q.append((v, 0))\\n    else:\\n        ones = [(0, node)]\\n        twos = []\\n        threes = []\\n        for v in adj[node]:\\n            if v != parent[node]:\\n                a, b, c = outs[v]\\n                ones.append((a[0] + 1, a[1], v))\\n                twos.append((b[0] + 1, b[1], v))\\n                threes.append(c)\\n        ones.sort(reverse = True)\\n        twos.sort(reverse = True)\\n        threes.sort(reverse = True)\\n\\n        bestOne = (ones[0][0], ones[0][1])\\n        \\n        bestsTwo = [(NEGINF, (0, 0))]\\n        if len(twos) > 0:\\n            bestsTwo.append((twos[0][0], twos[0][1]))\\n        if len(ones) > 1:\\n            o1 = ones[0]\\n            o2 = ones[1]\\n            bestsTwo.append((o1[0] + o2[0], (o1[1], o2[1])))\\n\\n        bestsThree = [(NEGINF, (0, 0, 0))]\\n        if len(threes) > 0:\\n            bestsThree.append(threes[0])\\n        if len(ones) > 2:\\n            o1 = ones[0]\\n            o2 = ones[1]\\n            o3 = ones[2]\\n            bestsThree.append((o1[0] + o2[0] + o3[0], (o1[1], o2[1], o3[1])))\\n        if len(twos) > 0:\\n            o1 = ones[0]\\n            t1 = twos[0]\\n            if o1[2] != t1[2]:\\n                bestsThree.append((o1[0] + t1[0], (o1[1], t1[1][0], t1[1][1])))\\n            else:\\n                if len(twos) > 1:\\n                    t2 = twos[1]\\n                    bestsThree.append((o1[0] + t2[0], (o1[1], t2[1][0], t2[1][1])))\\n                if len(ones) > 1:\\n                    o2 = ones[1]\\n                    bestsThree.append((o2[0] + t1[0], (o2[1], t1[1][0], t1[1][1])))\\n                    \\n\\n        outs[node] = (bestOne, max(bestsTwo), max(bestsThree))\\n\\nfinal = outs[0][2]\\nprint(final[0])\\nprint(' '.join([str(x + 1) for x in final[1]]))\\n\", \"import sys\\nfrom collections import deque\\n\\n# inf = open('input.txt', 'r')\\n# reader = (line.rstrip() for line in inf)\\nreader = (line.rstrip() for line in sys.stdin)\\ninput = reader.__next__\\n\\nn = int(input())\\ng = [[] for _ in range(n)]\\nfor _ in range(n - 1):\\n    v, to = list(map(int, input().split()))\\n    v -= 1\\n    to -= 1\\n    g[v].append(to)\\n    g[to].append(v)\\n\\n# (vertex, distance)\\nqueue = deque([(0, 0)])\\nvisited = [False] * n\\nwhile queue:\\n    v, d = queue.popleft()\\n    visited[v] = True\\n    for to in g[v]:\\n        if not visited[to]:\\n            queue.append((to, d + 1))\\na = v\\n\\n# (vertex, distance)\\nqueue = deque([(a, 0)])\\nprev = [-1] * n\\nfor i in range(n):\\n    visited[i] = False\\nwhile queue:\\n    v, d = queue.popleft()\\n    visited[v] = True\\n    for to in g[v]:\\n        if not visited[to]:\\n            queue.append((to, d + 1))\\n            prev[to] = v\\nb, ctr = v, d\\n\\nfor i in range(n):\\n    visited[i] = False\\ncurr = prev[b]\\nnxt = b\\nprv = prev[curr]\\nadd = 0\\nif a != 0 and b != 0:\\n    c = 0\\nelif a != 1 and b != 1:\\n    c = 1\\nelse:\\n    c = 2\\nwhile curr != a:\\n    visited[curr] = True\\n    for to in g[curr]:\\n        if to == nxt or to == prv:\\n            continue\\n        queue = deque([(to, 1)])\\n        while queue:\\n            v, d = queue.popleft()\\n            visited[v] = True\\n            for to in g[v]:\\n                if not visited[to]:\\n                    queue.append((to, d + 1))\\n        if add < d:\\n            c, add = v, d    \\n    nxt = curr\\n    curr = prev[curr]\\n    prv = prev[curr]\\n    \\nprint(ctr + add)\\nprint(a + 1, b + 1, c + 1)\\n\\n# inf.close()\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nn=int(input())\\nE=[[] for i in range(n+1)]\\n\\nfor i in range(n-1):\\n    x,y=list(map(int,input().split()))\\n    E[x].append(y)\\n    E[y].append(x)\\n\\ndef dfs(t):\\n    L=[-1]*(n+1)\\n    L[t]=0\\n\\n    Q=[t]\\n\\n    while Q:\\n        x=Q.pop()\\n        for to in E[x]:\\n            if L[to]==-1:\\n                L[to]=L[x]+1\\n                Q.append(to)\\n\\n    return L.index(max(L))\\n\\nA=dfs(1)\\nB=dfs(A)\\n\\nDEPTH=[-1]*(n+1)\\nDEPTH[1]=0\\n\\nfrom collections import deque\\nQUE = deque([1])\\nQUE2 = deque()\\nEULER=[]\\n\\nUSED=[0]*(n+1)\\nwhile QUE:\\n    x=QUE.pop()\\n    EULER.append((DEPTH[x],x))\\n    if USED[x]==1:\\n        continue\\n    for to in E[x]:\\n        \\n        if USED[to]==0:\\n            DEPTH[to]=DEPTH[x]+1\\n            QUE2.append(to)\\n        else:\\n            QUE.append(to)\\n    QUE.extend(QUE2)\\n    QUE2=deque()\\n \\n    USED[x]=1\\n\\nMINP=[1<<30]*(n+1)\\nMAXP=[-1]*(n+1)\\n\\nfor ind,(depth,p) in enumerate(EULER):\\n    MINP[p]=min(MINP[p],ind)\\n    MAXP[p]=max(MAXP[p],ind)\\n\\nLEN=len(EULER)\\n\\nseg_el=1<<(LEN.bit_length())\\nSEG=[(1<<30,0)]*(2*seg_el)\\n\\nfor i in range(LEN):\\n    SEG[i+seg_el]=EULER[i]\\n\\nfor i in range(seg_el-1,0,-1):\\n    SEG[i]=min(SEG[i*2],SEG[i*2+1])\\n\\ndef update(n,x,seg_el):\\n    i=n+seg_el\\n    SEG[i]=x\\n    i>>=1\\n    \\n    while i!=0:\\n        SEG[i]=min(SEG[i*2],SEG[i*2+1])\\n        i>>=1\\n        \\ndef getvalues(l,r):\\n    L=l+seg_el\\n    R=r+seg_el\\n    ANS=(1<<30,0)\\n\\n    while L<R:\\n        if L & 1:\\n            ANS=min(ANS , SEG[L])\\n            L+=1\\n\\n        if R & 1:\\n            R-=1\\n            ANS=min(ANS , SEG[R])\\n        L>>=1\\n        R>>=1\\n\\n    return ANS\\n\\ndef LCA(l,r):\\n    return getvalues(min(MINP[l],MINP[r]),max(MAXP[l],MAXP[r])+1)\\n\\nA2=DEPTH[A]*2+DEPTH[B]*2-LCA(A,B)[0]*2\\nANS=0\\n\\nfor i in range(1,n+1):\\n    if i==A or i==B:\\n        continue\\n\\n    if ANS<A2+DEPTH[i]*2-LCA(i,A)[0]*2-LCA(i,B)[0]*2:\\n        ANS=A2+DEPTH[i]*2-LCA(i,A)[0]*2-LCA(i,B)[0]*2\\n        Aind=i\\n\\nprint(ANS//2)\\nprint(A,B,Aind)\\n    \\n    \\n\", \"import sys\\nfrom collections import deque\\nn = int(input())\\nadj = [[] for _ in range(n)]\\nfor u, v in (list(map(int, l.split())) for l in sys.stdin):\\n    adj[u-1].append(v-1)\\n    adj[v-1].append(u-1)\\n\\ninf = 10**9\\n\\n\\ndef rec(s):\\n    prev = [-1]*n\\n    prev[s] = inf\\n    dq = deque([s])\\n    last = s\\n\\n    while dq:\\n        v = dq.popleft()\\n        last = v\\n        for dest in adj[v]:\\n            if prev[dest] > -1:\\n                continue\\n            prev[dest] = v\\n            dq.append(dest)\\n\\n    return last, prev\\n\\n\\nv1, _ = rec(0)\\nv2, prev = rec(v1)\\nv = prev[v2]\\nvisited = [0]*n\\nvisited[v] = visited[v1] = visited[v2] = 1\\ndia = 0\\nmax_e, max_e_i = 0, v\\n\\nwhile v != inf:\\n    dia += 1\\n    if prev[v] != inf:\\n        visited[prev[v]] = 1\\n\\n    stack = [(v, 0)]\\n    while stack:\\n        cv, e = stack.pop()\\n        if max_e < e:\\n            max_e, max_e_i = e, cv\\n        e += 1\\n\\n        for dest in adj[cv]:\\n            if visited[dest]:\\n                continue\\n            visited[dest] = 1\\n            stack.append((dest, e))\\n\\n    v = prev[v]\\n\\nprint(dia + max_e)\\nprint(v1+1, v2+1, max_e_i+1)\\n\"]", "task": "apps", "difficulty": "introductory", "split": "test", "transformation_type": "vanilla"}