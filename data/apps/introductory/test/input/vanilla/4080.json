{"qid": 4080, "orig_input": "The only difference between easy and hard versions is a number of elements in the array.\n\nYou are given an array $a$ consisting of $n$ integers. The value of the $i$-th element of the array is $a_i$.\n\nYou are also given a set of $m$ segments. The $j$-th segment is $[l_j; r_j]$, where $1 \\le l_j \\le r_j \\le n$.\n\nYou can choose some subset of the given set of segments and decrease values on each of the chosen segments by one (independently). For example, if the initial array $a = [0, 0, 0, 0, 0]$ and the given segments are $[1; 3]$ and $[2; 4]$ then you can choose both of them and the array will become $b = [-1, -2, -2, -1, 0]$.\n\nYou have to choose some subset of the given segments (each segment can be chosen at most once) in such a way that if you apply this subset of segments to the array $a$ and obtain the array $b$ then the value $\\max\\limits_{i=1}^{n}b_i - \\min\\limits_{i=1}^{n}b_i$ will be maximum possible.\n\nNote that you can choose the empty set.\n\nIf there are multiple answers, you can print any.\n\nIf you are Python programmer, consider using PyPy instead of Python when you submit your code.\n\n\n-----Input-----\n\nThe first line of the input contains two integers $n$ and $m$ ($1 \\le n \\le 10^5, 0 \\le m \\le 300$) \u2014 the length of the array $a$ and the number of segments, respectively.\n\nThe second line of the input contains $n$ integers $a_1, a_2, \\dots, a_n$ ($-10^6 \\le a_i \\le 10^6$), where $a_i$ is the value of the $i$-th element of the array $a$.\n\nThe next $m$ lines are contain two integers each. The $j$-th of them contains two integers $l_j$ and $r_j$ ($1 \\le l_j \\le r_j \\le n$), where $l_j$ and $r_j$ are the ends of the $j$-th segment.\n\n\n-----Output-----\n\nIn the first line of the output print one integer $d$ \u2014 the maximum possible value $\\max\\limits_{i=1}^{n}b_i - \\min\\limits_{i=1}^{n}b_i$ if $b$ is the array obtained by applying some subset of the given segments to the array $a$.\n\nIn the second line of the output print one integer $q$ ($0 \\le q \\le m$) \u2014 the number of segments you apply.\n\nIn the third line print $q$ distinct integers $c_1, c_2, \\dots, c_q$ in any order ($1 \\le c_k \\le m$) \u2014 indices of segments you apply to the array $a$ in such a way that the value $\\max\\limits_{i=1}^{n}b_i - \\min\\limits_{i=1}^{n}b_i$ of the obtained array $b$ is maximum possible.\n\nIf there are multiple answers, you can print any.\n\n\n-----Examples-----\nInput\n5 4\n2 -2 3 1 2\n1 3\n4 5\n2 5\n1 3\n\nOutput\n6\n2\n4 1 \n\nInput\n5 4\n2 -2 3 1 4\n3 5\n3 4\n2 4\n2 5\n\nOutput\n7\n2\n3 2 \n\nInput\n1 0\n1000000\n\nOutput\n0\n0\n\n\n\n\n-----Note-----\n\nIn the first example the obtained array $b$ will be $[0, -4, 1, 1, 2]$ so the answer is $6$.\n\nIn the second example the obtained array $b$ will be $[2, -3, 1, -1, 4]$ so the answer is $7$.\n\nIn the third example you cannot do anything so the answer is $0$.", "input": "The only difference between easy and hard versions is a number of elements in the array.\n\nYou are given an array $a$ consisting of $n$ integers. The value of the $i$-th element of the array is $a_i$.\n\nYou are also given a set of $m$ segments. The $j$-th segment is $[l_j; r_j]$, where $1 \\le l_j \\le r_j \\le n$.\n\nYou can choose some subset of the given set of segments and decrease values on each of the chosen segments by one (independently). For example, if the initial array $a = [0, 0, 0, 0, 0]$ and the given segments are $[1; 3]$ and $[2; 4]$ then you can choose both of them and the array will become $b = [-1, -2, -2, -1, 0]$.\n\nYou have to choose some subset of the given segments (each segment can be chosen at most once) in such a way that if you apply this subset of segments to the array $a$ and obtain the array $b$ then the value $\\max\\limits_{i=1}^{n}b_i - \\min\\limits_{i=1}^{n}b_i$ will be maximum possible.\n\nNote that you can choose the empty set.\n\nIf there are multiple answers, you can print any.\n\nIf you are Python programmer, consider using PyPy instead of Python when you submit your code.\n\n\n-----Input-----\n\nThe first line of the input contains two integers $n$ and $m$ ($1 \\le n \\le 10^5, 0 \\le m \\le 300$) \u2014 the length of the array $a$ and the number of segments, respectively.\n\nThe second line of the input contains $n$ integers $a_1, a_2, \\dots, a_n$ ($-10^6 \\le a_i \\le 10^6$), where $a_i$ is the value of the $i$-th element of the array $a$.\n\nThe next $m$ lines are contain two integers each. The $j$-th of them contains two integers $l_j$ and $r_j$ ($1 \\le l_j \\le r_j \\le n$), where $l_j$ and $r_j$ are the ends of the $j$-th segment.\n\n\n-----Output-----\n\nIn the first line of the output print one integer $d$ \u2014 the maximum possible value $\\max\\limits_{i=1}^{n}b_i - \\min\\limits_{i=1}^{n}b_i$ if $b$ is the array obtained by applying some subset of the given segments to the array $a$.\n\nIn the second line of the output print one integer $q$ ($0 \\le q \\le m$) \u2014 the number of segments you apply.\n\nIn the third line print $q$ distinct integers $c_1, c_2, \\dots, c_q$ in any order ($1 \\le c_k \\le m$) \u2014 indices of segments you apply to the array $a$ in such a way that the value $\\max\\limits_{i=1}^{n}b_i - \\min\\limits_{i=1}^{n}b_i$ of the obtained array $b$ is maximum possible.\n\nIf there are multiple answers, you can print any.\n\n\n-----Examples-----\nInput\n5 4\n2 -2 3 1 2\n1 3\n4 5\n2 5\n1 3\n\nOutput\n6\n2\n4 1 \n\nInput\n5 4\n2 -2 3 1 4\n3 5\n3 4\n2 4\n2 5\n\nOutput\n7\n2\n3 2 \n\nInput\n1 0\n1000000\n\nOutput\n0\n0\n\n\n\n\n-----Note-----\n\nIn the first example the obtained array $b$ will be $[0, -4, 1, 1, 2]$ so the answer is $6$.\n\nIn the second example the obtained array $b$ will be $[2, -3, 1, -1, 4]$ so the answer is $7$.\n\nIn the third example you cannot do anything so the answer is $0$.", "test_cases": {"inputs": ["5 4\n2 -2 3 1 2\n1 3\n4 5\n2 5\n1 3\n", "5 4\n2 -2 3 1 4\n3 5\n3 4\n2 4\n2 5\n", "1 0\n1000000\n", "1 0\n-1\n", "1 1\n-10\n1 1\n", "1 2\n-7\n1 1\n1 1\n", "1 5\n9\n1 1\n1 1\n1 1\n1 1\n1 1\n", "1 50\n5\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n", "1 100\n-4\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n", "2 0\n9 0\n", "2 1\n5 8\n1 1\n", "2 2\n-4 7\n2 2\n2 2\n", "2 5\n-1 -7\n1 2\n2 2\n2 2\n2 2\n1 1\n", "2 50\n-8 -6\n2 2\n2 2\n1 2\n1 1\n2 2\n1 2\n2 2\n2 2\n1 1\n1 1\n1 1\n2 2\n2 2\n2 2\n1 1\n1 1\n1 1\n2 2\n2 2\n1 1\n2 2\n2 2\n2 2\n1 1\n1 2\n2 2\n1 1\n2 2\n1 1\n2 2\n1 2\n1 1\n2 2\n1 2\n2 2\n1 1\n1 2\n1 1\n2 2\n2 2\n2 2\n1 2\n2 2\n2 2\n2 2\n1 1\n1 1\n1 2\n2 2\n1 2\n", "5 0\n0 -8 -5 -6 10\n", "5 1\n8 -5 -4 4 -8\n1 3\n", "5 2\n-1 -5 0 5 -1\n3 4\n2 5\n", "5 5\n2 6 -2 1 -6\n3 5\n4 5\n4 4\n2 3\n5 5\n", "5 50\n-5 4 -4 -1 5\n4 5\n4 5\n1 1\n1 5\n1 1\n1 1\n3 5\n4 5\n5 5\n1 1\n3 3\n1 4\n1 3\n4 5\n4 5\n5 5\n1 3\n2 3\n3 4\n5 5\n1 2\n4 4\n2 2\n1 3\n5 5\n2 5\n2 2\n3 3\n1 1\n4 4\n2 3\n3 4\n5 5\n5 5\n5 5\n4 4\n5 5\n1 4\n3 3\n3 3\n4 4\n1 1\n4 5\n2 5\n3 3\n1 1\n5 5\n3 4\n2 4\n5 5\n", "50 0\n-7 8 -10 -6 10 -2 -2 -4 0 0 1 9 -8 -7 -6 3 2 -3 10 -5 -9 7 -4 -9 1 -3 3 -3 -1 7 -4 3 -8 6 -3 -9 9 -10 -6 -10 5 3 -3 -3 3 -5 -3 -9 -7 2\n", "50 1\n-8 8 -6 -4 -1 8 6 7 -7 3 -2 -3 6 10 2 8 -2 -4 2 9 0 7 0 9 5 6 -2 -1 -7 -9 -6 1 9 -1 -6 -5 -4 2 -2 4 8 7 -9 7 6 3 -8 -3 4 0\n27 41\n", "50 2\n5 -5 8 5 6 6 10 -4 8 -10 9 -10 -5 -7 -7 -3 5 -9 7 9 0 -2 8 10 1 -9 -7 -4 8 9 -7 -5 2 -9 -1 -1 8 -6 -5 10 -5 -2 10 5 0 10 -9 -9 3 -2\n2 21\n28 38\n", "50 5\n0 2 1 1 -2 7 -3 3 8 -1 6 8 -8 -3 0 1 6 1 -5 -1 -4 -3 -4 -4 -6 6 -9 5 0 -7 -8 3 8 -4 3 6 -10 -3 6 1 4 1 2 -7 5 -5 5 -2 4 -5\n30 34\n8 25\n48 50\n19 48\n48 49\n", "50 50\n1 -9 8 -9 5 -4 -4 3 -2 -1 3 -8 -6 -6 2 -5 -1 -2 -5 10 2 0 10 10 5 -3 7 -1 -9 9 -10 4 7 0 -6 0 -1 4 8 0 -3 -8 10 10 6 6 -3 -5 -3 -8\n28 41\n28 49\n49 49\n6 38\n22 30\n50 50\n41 45\n30 32\n17 44\n24 25\n27 39\n17 39\n50 50\n10 14\n11 12\n18 28\n11 20\n36 42\n45 49\n29 36\n32 44\n19 41\n6 36\n39 40\n32 44\n41 47\n6 47\n44 48\n31 48\n45 48\n43 48\n1 14\n46 50\n50 50\n38 40\n18 29\n19 29\n20 50\n3 21\n47 50\n6 24\n38 49\n14 48\n28 39\n36 50\n10 32\n5 12\n14 18\n13 23\n13 24\n", "100 0\n6 0 3 6 1 -7 9 -2 -8 -4 -6 -2 7 -3 0 4 -8 10 -2 5 -2 3 9 -7 -2 0 -4 -7 3 7 7 -2 -5 2 9 7 -9 1 2 -8 9 0 8 2 -4 3 -10 0 3 8 3 -6 -8 2 0 10 0 -3 1 2 7 -6 -9 -4 7 7 -2 -4 2 -4 -4 -6 2 0 10 -6 -1 -6 -10 -2 3 8 -10 -10 10 0 1 8 -8 5 9 -6 -2 0 5 -6 -6 6 -10 -6\n", "100 1\n-3 4 8 -1 0 7 9 8 10 3 8 7 -8 -7 -9 -7 -8 5 7 5 -10 -5 9 -2 3 5 -10 -10 -2 7 10 9 8 8 2 3 -1 -8 -6 2 -5 4 6 -1 -5 7 10 -2 -3 2 -5 1 2 8 -7 -3 6 -6 -2 -3 -4 -1 -8 4 -10 6 -4 8 4 -9 -2 7 -4 -6 7 -1 1 -7 -4 2 -4 6 -6 -8 -9 -8 -1 -10 -1 -4 -4 -5 -9 -1 7 2 -7 -7 -2 -1\n83 92\n", "100 2\n-7 3 0 -4 -10 1 -4 -2 3 7 2 -1 2 -3 -1 -6 -5 4 -2 2 -10 7 -8 -1 -5 10 2 9 9 3 8 -1 5 -3 -10 7 -10 5 -9 -9 -1 -5 1 -3 10 5 5 -8 -8 4 -5 0 -5 10 -9 1 0 8 -4 0 6 0 -10 8 7 -8 8 7 6 3 -9 -10 1 -5 9 -4 -4 0 -10 -8 -6 -4 3 -3 1 0 0 5 5 4 -8 1 5 2 1 1 10 -3 -7 0\n69 88\n96 96\n", "100 5\n-4 10 -7 9 7 2 8 0 4 -4 -5 1 -5 1 6 6 0 -3 8 -4 -10 10 9 6 9 9 0 1 9 5 7 7 7 5 -10 -7 -7 0 6 -9 -9 -2 -8 6 -2 7 -2 -10 -3 -3 -9 2 -9 -1 8 -9 -3 3 -9 -8 3 -9 -4 0 0 1 -8 -5 8 -4 -5 -4 6 8 3 9 6 5 5 -10 7 -1 0 3 6 6 10 -8 -9 2 3 -8 -3 -1 5 7 3 1 -8 -6\n27 59\n64 94\n79 87\n9 57\n37 91\n", "69 1\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n1 3\n"], "outputs": ["6\n2\n1 4 \n", "7\n2\n2 3 \n", "0\n0\n", "0\n0\n", "0\n0\n", "0\n0\n", "0\n0\n", "0\n0\n", "0\n0\n", "9\n0\n\n", "4\n1\n1 \n", "11\n0\n\n", "9\n3\n2 4 3 \n", "23\n25\n2 13 1 19 45 43 44 8 7 23 30 12 21 39 5 14 22 18 49 41 35 40 26 28 33 \n", "18\n0\n\n", "16\n0\n\n", "10\n0\n\n", "15\n4\n5 1 3 2 \n", "25\n30\n36 13 21 46 38 32 30 28 41 40 42 6 29 22 27 19 31 24 48 5 12 39 10 45 49 18 17 3 11 23 \n", "20\n0\n\n", "20\n1\n1 \n", "21\n2\n2 1 \n", "19\n4\n4 5 3 1 \n", "34\n48\n11 48 21 10 13 40 12 38 41 9 20 6 18 4 42 47 43 8 15 37 19 7 5 22 44 31 30 29 36 49 25 26 34 3 23 50 27 2 28 46 45 17 1 33 24 35 14 16 \n", "20\n0\n\n", "21\n1\n1 \n", "21\n2\n2 1 \n", "23\n5\n3 4 5 2 1 \n", "1\n1\n1 \n"]}, "solutions": "[\"import sys\\n\\n# a very nice implementation of a minimum segment tree with \\n# some inspiration taken from https://codeforces.com/blog/entry/18051\\n# this implementation should be able to be modified to do pretty\\n# much anything one would want to do with segment trees apart from\\n# persistance.\\n# note that especially in python this implementation is much much better\\n# than most other approches because how slow python can be with function\\n# calls.\\n\\n# currently it allows for two operations, both running in o(log n),\\n# 'add(l,r,value)' adds value to [l,r)\\n# 'find_min(l,r)' finds the index with the smallest value\\n\\nclass super_seg:\\n    def __init__(self,data):\\n        n = len(data)\\n        m = 1\\n        while m<n: m *= 2\\n        \\n        self.n = n\\n        self.m = m\\n        self.data = [0]*(2*m)\\n        for i in range(n):\\n            self.data[i+m] = data[i]\\n        for i in reversed(range(m)):\\n            self.data[i] = min(self.data[2*i], self.data[2*i+1])\\n        self.query = [0]*(2*m)\\n    \\n    # push the query on seg_ind to its children\\n    def push(self,seg_ind):\\n        # let the children know of the queries\\n        q = self.query[seg_ind]\\n\\n        self.query[2*seg_ind]   += q\\n        self.query[2*seg_ind+1] += q\\n        \\n        self.data[2*seg_ind]   += q\\n        self.data[2*seg_ind+1] += q\\n\\n        # remove queries from seg_ind\\n        self.data[seg_ind] = min(self.data[2*seg_ind],self.data[2*seg_ind+1])\\n        self.query[seg_ind] = 0\\n\\n    # updates the node seg_ind to know of all queries\\n    # applied to it via its ancestors\\n    def update(self,seg_ind):\\n        # find all indecies to be updated\\n        seg_ind //= 2\\n        inds = []\\n        while seg_ind>0:\\n            inds.append(seg_ind)\\n            seg_ind//=2\\n       \\n        # push the queries down the segment tree\\n        for ind in reversed(inds):\\n            self.push(ind)\\n\\n    # make the changes to seg_ind be known to its ancestors\\n    def build(self,seg_ind):\\n        seg_ind//=2\\n        while seg_ind>0:\\n            self.data[seg_ind] = min(self.data[2*seg_ind], self.data[2*seg_ind+1]) + self.query[seg_ind]\\n            seg_ind //= 2\\n\\n    # lazily add value to [l,r)\\n    def add(self,l,r,value):\\n        l += self.m\\n        r += self.m\\n        \\n        l0 = l\\n        r0 = r\\n\\n        while l<r:\\n            if l%2==1:\\n                self.query[l]+= value\\n                self.data[l] += value\\n                l+=1\\n            if r%2==1:\\n                r-=1\\n                self.query[r]+= value\\n                self.data[r] += value\\n            l//=2\\n            r//=2\\n\\n        # tell all nodes above of the updated\\n        # area of the updates\\n        self.build(l0)\\n        self.build(r0-1)\\n    \\n    # min of data[l,r)\\n    def min(self,l,r):\\n        l += self.m\\n        r += self.m\\n\\n        # apply all the lazily stored queries\\n        self.update(l)\\n        self.update(r-1)\\n        \\n        segs = []\\n        while l<r:\\n            if l%2==1:\\n                segs.append(l)\\n                l+=1\\n            if r%2==1:\\n                r-=1\\n                segs.append(r)\\n            l//=2\\n            r//=2\\n\\n        return min(self.data[ind] for ind in segs)\\n\\n\\n    # find index of smallest value in data[l,r)\\n    def find_min(self,l,r):\\n        l += self.m\\n        r += self.m\\n        \\n        # apply all the lazily stored queries\\n        self.update(l)\\n        self.update(r-1)\\n\\n        segs = []\\n        while l<r:\\n            if l%2==1:\\n                segs.append(l)\\n                l+=1\\n            if r%2==1:\\n                r-=1\\n                segs.append(r)\\n            l//=2\\n            r//=2\\n\\n        ind = min(segs, key=lambda i:self.data[i])\\n        mini = self.data[ind]\\n       \\n        # dig down in search of mini\\n        while ind<self.m:\\n            self.push(ind)\\n\\n            if self.data[2*ind]==mini:\\n                ind *= 2\\n            else:\\n                ind = 2*ind+1\\n        \\n        return ind-self.m,mini\\n\\n\\nn,m = [int(x) for x in input().split()]\\n\\nA = [int(x) for x in input().split()]\\n\\ninter = []\\ninter2 = []\\nfor _ in range(m):\\n    l,r = [int(x) for x in input().split()]\\n    l -= 1\\n    inter.append((l,r))\\n    inter2.append((r,l))\\n\\ninter_copy = inter[:]\\n\\ninter.sort()\\ninter2.sort()\\n\\nAneg = super_seg([-a for a in A])\\n\\nbesta = -1\\nbesta_ind = -1\\n\\nj1 = 0\\nj2 = 0\\nfor i in range(n):\\n    # Only segments containing i should be active\\n    # Activate\\n    while j1<m and inter[j1][0]<=i:\\n        l,r = inter[j1]\\n        Aneg.add(l,r,1)\\n        j1 += 1\\n    # Deactivate\\n    while j2<m and inter2[j2][0]<=i:\\n        r,l = inter2[j2]\\n        Aneg.add(l,r,-1)\\n        j2 += 1\\n    Amax = -Aneg.min(0,n)\\n    Ai = -Aneg.min(i,i+1)\\n    if Amax-Ai>besta:\\n        besta = Amax-Ai\\n        besta_ind = i\\n\\nints = [j for j in range(m) if inter_copy[j][0]<=besta_ind<inter_copy[j][1]]\\n\\nprint(besta)\\nprint(len(ints))\\nprint(*[x+1 for x in ints])\", \"import sys\\n\\n# a very nice implementation of a minimum segment tree with \\n# some inspiration taken from https://codeforces.com/blog/entry/18051\\n# this implementation should be able to be modified to do pretty\\n# much anything one would want to do with segment trees apart from\\n# persistance.\\n# note that especially in python this implementation is much much better\\n# than most other approches because how slow python can be with function\\n# calls.\\n\\n# currently it allows for two operations, both running in o(log n),\\n# 'add(l,r,value)' adds value to [l,r)\\n# 'find_min(l,r)' finds the index with the smallest value\\n\\nbig = 10**9\\n\\nclass super_seg:\\n    def __init__(self,data):\\n        n = len(data)\\n        m = 1\\n        while m<n: m *= 2\\n        \\n        self.n = n\\n        self.m = m\\n        self.data = [big]*(2*m)\\n        for i in range(n):\\n            self.data[i+m] = data[i]\\n        for i in reversed(list(range(m))):\\n            self.data[i] = min(self.data[2*i], self.data[2*i+1])\\n        self.query = [0]*(2*m)\\n    \\n    # push the query on seg_ind to its children\\n    def push(self,seg_ind):\\n        # let the children know of the queries\\n        q = self.query[seg_ind]\\n\\n        self.query[2*seg_ind]   += q\\n        self.query[2*seg_ind+1] += q\\n        \\n        self.data[2*seg_ind]   += q\\n        self.data[2*seg_ind+1] += q\\n\\n        # remove queries from seg_ind\\n        self.data[seg_ind] = min(self.data[2*seg_ind],self.data[2*seg_ind+1])\\n        self.query[seg_ind] = 0\\n\\n    # updates the node seg_ind to know of all queries\\n    # applied to it via its ancestors\\n    def update(self,seg_ind):\\n        # find all indecies to be updated\\n        seg_ind //= 2\\n        inds = []\\n        while seg_ind>0:\\n            inds.append(seg_ind)\\n            seg_ind//=2\\n       \\n        # push the queries down the segment tree\\n        for ind in reversed(inds):\\n            self.push(ind)\\n\\n    # make the changes to seg_ind be known to its ancestors\\n    def build(self,seg_ind):\\n        seg_ind//=2\\n        while seg_ind>0:\\n            self.data[seg_ind] = min(self.data[2*seg_ind], self.data[2*seg_ind+1]) + self.query[seg_ind]\\n            seg_ind //= 2\\n\\n    # lazily add value to [l,r)\\n    def add(self,l,r,value):\\n        l += self.m\\n        r += self.m\\n        \\n        l0 = l\\n        r0 = r\\n\\n        while l<r:\\n            if l%2==1:\\n                self.query[l]+= value\\n                self.data[l] += value\\n                l+=1\\n            if r%2==1:\\n                r-=1\\n                self.query[r]+= value\\n                self.data[r] += value\\n            l//=2\\n            r//=2\\n\\n        # tell all nodes above of the updated\\n        # area of the updates\\n        self.build(l0)\\n        self.build(r0-1)\\n    \\n    # min of data[l,r)\\n    def min(self,l,r):\\n        l += self.m\\n        r += self.m\\n\\n        # apply all the lazily stored queries\\n        self.update(l)\\n        self.update(r-1)\\n        \\n        segs = []\\n        while l<r:\\n            if l%2==1:\\n                segs.append(l)\\n                l+=1\\n            if r%2==1:\\n                r-=1\\n                segs.append(r)\\n            l//=2\\n            r//=2\\n\\n        return min(self.data[ind] for ind in segs)\\n\\n\\n    # find index of smallest value in data[l,r)\\n    def find_min(self,l,r):\\n        l += self.m\\n        r += self.m\\n        \\n        # apply all the lazily stored queries\\n        self.update(l)\\n        self.update(r-1)\\n\\n        segs = []\\n        while l<r:\\n            if l%2==1:\\n                segs.append(l)\\n                l+=1\\n            if r%2==1:\\n                r-=1\\n                segs.append(r)\\n            l//=2\\n            r//=2\\n\\n        ind = min(segs, key=lambda i:self.data[i])\\n        mini = self.data[ind]\\n       \\n        # dig down in search of mini\\n        while ind<self.m:\\n            self.push(ind)\\n\\n            if self.data[2*ind]==mini:\\n                ind *= 2\\n            else:\\n                ind = 2*ind+1\\n        \\n        return ind-self.m,mini\\n\\n\\nn,m = [int(x) for x in input().split()]\\n\\nA = [int(x) for x in input().split()]\\n\\ninter = []\\ninter2 = []\\nfor _ in range(m):\\n    l,r = [int(x) for x in input().split()]\\n    l -= 1\\n    inter.append((l,r))\\n    inter2.append((r,l))\\n\\ninter_copy = inter[:]\\n\\ninter.sort()\\ninter2.sort()\\n\\nAneg = super_seg([-a for a in A])\\n\\nbesta = -1\\nbesta_ind = -1\\n\\nj1 = 0\\nj2 = 0\\nfor i in range(n):\\n    # Only segments containing i should be active\\n    # Activate\\n    while j1<m and inter[j1][0]<=i:\\n        l,r = inter[j1]\\n        Aneg.add(l,r,1)\\n        j1 += 1\\n    # Deactivate\\n    while j2<m and inter2[j2][0]<=i:\\n        r,l = inter2[j2]\\n        Aneg.add(l,r,-1)\\n        j2 += 1\\n    Amax = -Aneg.data[1]\\n    Ai = A[i]-(j1-j2)\\n    if Amax-Ai>besta:\\n        besta = Amax-Ai\\n        besta_ind = i\\n\\nints = [i for i in range(m) if inter_copy[i][0]<=besta_ind<inter_copy[i][1]]\\n\\nprint(besta)\\nprint(len(ints))\\nprint(*[x+1 for x in ints])\\n\", \"import sys\\n\\n# a very nice implementation of a minimum segment tree with \\n# some inspiration taken from https://codeforces.com/blog/entry/18051\\n# this implementation should be able to be modified to do pretty\\n# much anything one would want to do with segment trees apart from\\n# persistance.\\n# note that especially in python this implementation is much much better\\n# than most other approches because how slow python can be with function\\n# calls.\\n\\n# currently it allows for two operations, both running in o(log n),\\n# 'add(l,r,value)' adds value to [l,r)\\n# 'find_min(l,r)' finds the index with the smallest value\\n\\nbig = 10**9\\n\\nclass super_seg:\\n    def __init__(self,data):\\n        n = len(data)\\n        m = 1\\n        while m<n: m *= 2\\n        \\n        self.n = n\\n        self.m = m\\n        self.data = [big]*(2*m)\\n        for i in range(n):\\n            self.data[i+m] = data[i]\\n        for i in reversed(list(range(m))):\\n            self.data[i] = min(self.data[2*i], self.data[2*i+1])\\n        self.query = [0]*(2*m)\\n    \\n    # push the query on seg_ind to its children\\n    def push(self,seg_ind):\\n        # let the children know of the queries\\n        q = self.query[seg_ind]\\n\\n        self.query[2*seg_ind]   += q\\n        self.query[2*seg_ind+1] += q\\n        \\n        self.data[2*seg_ind]   += q\\n        self.data[2*seg_ind+1] += q\\n\\n        # remove queries from seg_ind\\n        self.data[seg_ind] = min(self.data[2*seg_ind],self.data[2*seg_ind+1])\\n        self.query[seg_ind] = 0\\n\\n    # updates the node seg_ind to know of all queries\\n    # applied to it via its ancestors\\n    def update(self,seg_ind):\\n        # find all indecies to be updated\\n        seg_ind //= 2\\n        inds = []\\n        while seg_ind>0:\\n            inds.append(seg_ind)\\n            seg_ind//=2\\n       \\n        # push the queries down the segment tree\\n        for ind in reversed(inds):\\n            self.push(ind)\\n\\n    # make the changes to seg_ind be known to its ancestors\\n    def build(self,seg_ind):\\n        seg_ind//=2\\n        while seg_ind>0:\\n            self.data[seg_ind] = min(self.data[2*seg_ind], self.data[2*seg_ind+1]) + self.query[seg_ind]\\n            seg_ind //= 2\\n\\n    # lazily add value to [l,r)\\n    def add(self,l,r,value):\\n        l += self.m\\n        r += self.m\\n        \\n        l0 = l\\n        r0 = r\\n\\n        while l<r:\\n            if l%2==1:\\n                self.query[l]+= value\\n                self.data[l] += value\\n                l+=1\\n            if r%2==1:\\n                r-=1\\n                self.query[r]+= value\\n                self.data[r] += value\\n            l//=2\\n            r//=2\\n\\n        # tell all nodes above of the updated\\n        # area of the updates\\n        self.build(l0)\\n        self.build(r0-1)\\n    \\n    # min of data[l,r)\\n    def min(self,l,r):\\n        l += self.m\\n        r += self.m\\n\\n        # apply all the lazily stored queries\\n        self.update(l)\\n        self.update(r-1)\\n        \\n        segs = []\\n        while l<r:\\n            if l%2==1:\\n                segs.append(l)\\n                l+=1\\n            if r%2==1:\\n                r-=1\\n                segs.append(r)\\n            l//=2\\n            r//=2\\n\\n        return min(self.data[ind] for ind in segs)\\n\\n\\n    # find index of smallest value in data[l,r)\\n    def find_min(self,l,r):\\n        l += self.m\\n        r += self.m\\n        \\n        # apply all the lazily stored queries\\n        self.update(l)\\n        self.update(r-1)\\n\\n        segs = []\\n        while l<r:\\n            if l%2==1:\\n                segs.append(l)\\n                l+=1\\n            if r%2==1:\\n                r-=1\\n                segs.append(r)\\n            l//=2\\n            r//=2\\n\\n        ind = min(segs, key=lambda i:self.data[i])\\n        mini = self.data[ind]\\n       \\n        # dig down in search of mini\\n        while ind<self.m:\\n            self.push(ind)\\n\\n            if self.data[2*ind]==mini:\\n                ind *= 2\\n            else:\\n                ind = 2*ind+1\\n        \\n        return ind-self.m,mini\\n\\n\\nn,m = [int(x) for x in input().split()]\\n\\nA = [int(x) for x in input().split()]\\n\\ninter = []\\ninter2 = []\\nfor _ in range(m):\\n    l,r = [int(x) for x in input().split()]\\n    l -= 1\\n    inter.append((l,r))\\n    inter2.append((r,l))\\n\\ninter_copy = inter[:]\\n\\ninter.sort()\\ninter2.sort()\\n\\nAneg = super_seg([-a for a in A])\\n\\nbesta = -1\\nbesta_ind = -1\\n\\nj1 = 0\\nj2 = 0\\nfor i in range(n):\\n    # Only segments containing i should be active\\n    # Activate\\n    while j1<m and inter[j1][0]<=i:\\n        l,r = inter[j1]\\n        Aneg.add(l,r,1)\\n        j1 += 1\\n    # Deactivate\\n    while j2<m and inter2[j2][0]<=i:\\n        r,l = inter2[j2]\\n        Aneg.add(l,r,-1)\\n        j2 += 1\\n    Amax = -Aneg.data[1]\\n    Ai = A[i]-(j1-j2)\\n    if Amax-Ai>besta:\\n        besta = Amax-Ai\\n        besta_ind = i\\n\\nints = [i for i in range(m) if inter_copy[i][0]<=besta_ind<inter_copy[i][1]]\\n\\nprint(besta)\\nprint(len(ints))\\nprint(*[x+1 for x in ints])\\n\", \"import sys\\n\\n# a very nice implementation of a minimum segment tree with \\n# some inspiration taken from https://codeforces.com/blog/entry/18051\\n# this implementation should be able to be modified to do pretty\\n# much anything one would want to do with segment trees apart from\\n# persistance.\\n# note that especially in python this implementation is much much better\\n# than most other approches because how slow python can be with function\\n# calls.\\n\\n# currently it allows for two operations, both running in o(log n),\\n# 'add(l,r,value)' adds value to [l,r)\\n# 'find_min(l,r)' finds the index with the smallest value\\n\\nbig = 10**9\\n\\nclass super_seg:\\n    def __init__(self,data):\\n        n = len(data)\\n        m = 1\\n        while m<n: m *= 2\\n        \\n        self.n = n\\n        self.m = m\\n        self.data = [big]*(2*m)\\n        for i in range(n):\\n            self.data[i+m] = data[i]\\n        for i in reversed(range(m)):\\n            self.data[i] = min(self.data[2*i], self.data[2*i+1])\\n        self.query = [0]*(2*m)\\n    \\n    # push the query on seg_ind to its children\\n    def push(self,seg_ind):\\n        # let the children know of the queries\\n        q = self.query[seg_ind]\\n\\n        self.query[2*seg_ind]   += q\\n        self.query[2*seg_ind+1] += q\\n        \\n        self.data[2*seg_ind]   += q\\n        self.data[2*seg_ind+1] += q\\n\\n        # remove queries from seg_ind\\n        self.data[seg_ind] = min(self.data[2*seg_ind],self.data[2*seg_ind+1])\\n        self.query[seg_ind] = 0\\n\\n    # updates the node seg_ind to know of all queries\\n    # applied to it via its ancestors\\n    def update(self,seg_ind):\\n        # find all indecies to be updated\\n        seg_ind //= 2\\n        inds = []\\n        while seg_ind>0:\\n            inds.append(seg_ind)\\n            seg_ind//=2\\n       \\n        # push the queries down the segment tree\\n        for ind in reversed(inds):\\n            self.push(ind)\\n\\n    # make the changes to seg_ind be known to its ancestors\\n    def build(self,seg_ind):\\n        seg_ind//=2\\n        while seg_ind>0:\\n            self.data[seg_ind] = min(self.data[2*seg_ind], self.data[2*seg_ind+1]) + self.query[seg_ind]\\n            seg_ind //= 2\\n\\n    # lazily add value to [l,r)\\n    def add(self,l,r,value):\\n        l += self.m\\n        r += self.m\\n        \\n        l0 = l\\n        r0 = r\\n\\n        while l<r:\\n            if l%2==1:\\n                self.query[l]+= value\\n                self.data[l] += value\\n                l+=1\\n            if r%2==1:\\n                r-=1\\n                self.query[r]+= value\\n                self.data[r] += value\\n            l//=2\\n            r//=2\\n\\n        # tell all nodes above of the updated\\n        # area of the updates\\n        self.build(l0)\\n        self.build(r0-1)\\n    \\n    # min of data[l,r)\\n    def min(self,l,r):\\n        l += self.m\\n        r += self.m\\n\\n        # apply all the lazily stored queries\\n        self.update(l)\\n        self.update(r-1)\\n        \\n        segs = []\\n        while l<r:\\n            if l%2==1:\\n                segs.append(l)\\n                l+=1\\n            if r%2==1:\\n                r-=1\\n                segs.append(r)\\n            l//=2\\n            r//=2\\n\\n        return min(self.data[ind] for ind in segs)\\n\\n\\n    # find index of smallest value in data[l,r)\\n    def find_min(self,l,r):\\n        l += self.m\\n        r += self.m\\n        \\n        # apply all the lazily stored queries\\n        self.update(l)\\n        self.update(r-1)\\n\\n        segs = []\\n        while l<r:\\n            if l%2==1:\\n                segs.append(l)\\n                l+=1\\n            if r%2==1:\\n                r-=1\\n                segs.append(r)\\n            l//=2\\n            r//=2\\n\\n        ind = min(segs, key=lambda i:self.data[i])\\n        mini = self.data[ind]\\n       \\n        # dig down in search of mini\\n        while ind<self.m:\\n            self.push(ind)\\n\\n            if self.data[2*ind]==mini:\\n                ind *= 2\\n            else:\\n                ind = 2*ind+1\\n        \\n        return ind-self.m,mini\\n\\n\\nn,m = [int(x) for x in input().split()]\\n\\nA = [int(x) for x in input().split()]\\n\\ninter = []\\ninter2 = []\\nfor _ in range(m):\\n    l,r = [int(x) for x in input().split()]\\n    l -= 1\\n    inter.append((l,r))\\n    inter2.append((r,l))\\n\\ninter_copy = inter[:]\\n\\ninter.sort()\\ninter2.sort()\\n\\nAneg = super_seg([-a for a in A])\\n\\nbesta = -1\\nbesta_ind = -1\\n\\nj1 = 0\\nj2 = 0\\nfor i in range(n):\\n    # Only segments containing i should be active\\n    # Activate\\n    while j1<m and inter[j1][0]<=i:\\n        l,r = inter[j1]\\n        Aneg.add(l,r,1)\\n        j1 += 1\\n    # Deactivate\\n    while j2<m and inter2[j2][0]<=i:\\n        r,l = inter2[j2]\\n        Aneg.add(l,r,-1)\\n        j2 += 1\\n    Amax = -Aneg.data[1]\\n    Ai = A[i]-(j1-j2)\\n    if Amax-Ai>besta:\\n        besta = Amax-Ai\\n        besta_ind = i\\n\\nints = [i for i in range(m) if inter_copy[i][0]<=besta_ind<inter_copy[i][1]]\\n\\nprint(besta)\\nprint(len(ints))\\nprint(*[x+1 for x in ints])\", \"import sys\\n\\n# a very nice implementation of a minimum segment tree with \\n# some inspiration taken from https://codeforces.com/blog/entry/18051\\n# this implementation should be able to be modified to do pretty\\n# much anything one would want to do with segment trees apart from\\n# persistance.\\n# note that especially in python this implementation is much much better\\n# than most other approches because how slow python can be with function\\n# calls. /pajenegod\\n\\n# currently it allows for two operations, both running in o(log n),\\n# 'add(l,r,value)' adds value to [l,r)\\n# 'find_min(l,r)' finds the index with the smallest value\\n\\nbig = 10**9\\n\\nclass super_seg:\\n    def __init__(self,data):\\n        n = len(data)\\n        m = 1\\n        while m<n: m *= 2\\n        \\n        self.n = n\\n        self.m = m\\n        self.data = [big]*(2*m)\\n        for i in range(n):\\n            self.data[i+m] = data[i]\\n        for i in reversed(range(m)):\\n            self.data[i] = min(self.data[2*i], self.data[2*i+1])\\n        self.query = [0]*(2*m)\\n    \\n    # push the query on seg_ind to its children\\n    def push(self,seg_ind):\\n        # let the children know of the queries\\n        q = self.query[seg_ind]\\n\\n        self.query[2*seg_ind]   += q\\n        self.query[2*seg_ind+1] += q\\n        \\n        self.data[2*seg_ind]   += q\\n        self.data[2*seg_ind+1] += q\\n\\n        # remove queries from seg_ind\\n        self.data[seg_ind] = min(self.data[2*seg_ind],self.data[2*seg_ind+1])\\n        self.query[seg_ind] = 0\\n\\n    # updates the node seg_ind to know of all queries\\n    # applied to it via its ancestors\\n    def update(self,seg_ind):\\n        # find all indecies to be updated\\n        seg_ind //= 2\\n        inds = []\\n        while seg_ind>0:\\n            inds.append(seg_ind)\\n            seg_ind//=2\\n       \\n        # push the queries down the segment tree\\n        for ind in reversed(inds):\\n            self.push(ind)\\n\\n    # make the changes to seg_ind be known to its ancestors\\n    def build(self,seg_ind):\\n        seg_ind//=2\\n        while seg_ind>0:\\n            self.data[seg_ind] = min(self.data[2*seg_ind], self.data[2*seg_ind+1]) + self.query[seg_ind]\\n            seg_ind //= 2\\n\\n    # lazily add value to [l,r)\\n    def add(self,l,r,value):\\n        l += self.m\\n        r += self.m\\n        \\n        l0 = l\\n        r0 = r\\n\\n        while l<r:\\n            if l%2==1:\\n                self.query[l]+= value\\n                self.data[l] += value\\n                l+=1\\n            if r%2==1:\\n                r-=1\\n                self.query[r]+= value\\n                self.data[r] += value\\n            l//=2\\n            r//=2\\n\\n        # tell all nodes above of the updated\\n        # area of the updates\\n        self.build(l0)\\n        self.build(r0-1)\\n    \\n    # min of data[l,r)\\n    def min(self,l,r):\\n        l += self.m\\n        r += self.m\\n\\n        # apply all the lazily stored queries\\n        self.update(l)\\n        self.update(r-1)\\n        \\n        segs = []\\n        while l<r:\\n            if l%2==1:\\n                segs.append(l)\\n                l+=1\\n            if r%2==1:\\n                r-=1\\n                segs.append(r)\\n            l//=2\\n            r//=2\\n\\n        return min(self.data[ind] for ind in segs)\\n\\n\\n    # find index of smallest value in data[l,r)\\n    def find_min(self,l,r):\\n        l += self.m\\n        r += self.m\\n        \\n        # apply all the lazily stored queries\\n        self.update(l)\\n        self.update(r-1)\\n\\n        segs = []\\n        while l<r:\\n            if l%2==1:\\n                segs.append(l)\\n                l+=1\\n            if r%2==1:\\n                r-=1\\n                segs.append(r)\\n            l//=2\\n            r//=2\\n\\n        ind = min(segs, key=lambda i:self.data[i])\\n        mini = self.data[ind]\\n       \\n        # dig down in search of mini\\n        while ind<self.m:\\n            self.push(ind)\\n\\n            if self.data[2*ind]==mini:\\n                ind *= 2\\n            else:\\n                ind = 2*ind+1\\n        \\n        return ind-self.m,mini\\n\\n\\nn,m = [int(x) for x in input().split()]\\n\\nA = [int(x) for x in input().split()]\\n\\ninter = []\\nbucketsl = [[] for _ in range(n)]\\nbucketsr = [[] for _ in range(n)]\\nfor _ in range(m):\\n    l,r = [int(x) for x in input().split()]\\n    l -= 1\\n    inter.append((l,r))\\n    bucketsl[l].append(r)\\n    if r<n:\\n        bucketsr[r].append(l)\\n\\nAneg = super_seg([-a for a in A])\\n\\nbesta = -1\\nbesta_ind = -1\\n\\nactive_intervals = 0\\nfor i in range(n):\\n    # Activate\\n    for r in bucketsl[i]:\\n        Aneg.add(i,r,1)\\n        active_intervals += 1\\n    # Deactivate\\n    for l in bucketsr[i]:\\n        Aneg.add(l,i,-1)\\n        active_intervals -= 1\\n    Amax = -Aneg.data[1]\\n    Ai = A[i] - active_intervals\\n    if Amax-Ai>besta:\\n        besta = Amax-Ai\\n        besta_ind = i\\n\\nints = [i for i in range(m) if inter[i][0]<=besta_ind<inter[i][1]]\\n\\nprint(besta)\\nprint(len(ints))\\nprint(*[x+1 for x in ints])\", \"import sys\\n\\n# a very nice implementation of a minimum segment tree with \\n# some inspiration taken from https://codeforces.com/blog/entry/18051\\n# this implementation should be able to be modified to do pretty\\n# much anything one would want to do with segment trees apart from\\n# persistance.\\n# note that especially in python this implementation is much much better\\n# than most other approches because how slow python can be with function\\n# calls. /pajenegod\\n\\n# currently it allows for two operations, both running in o(log n),\\n# 'add(l,r,value)' adds value to [l,r)\\n# 'find_min(l,r)' finds the index with the smallest value\\n\\nbig = 10**9\\n\\nclass super_seg:\\n    def __init__(self,data):\\n        n = len(data)\\n        m = 1\\n        while m<n: m *= 2\\n        \\n        self.n = n\\n        self.m = m\\n        self.data = [big]*(2*m)\\n        for i in range(n):\\n            self.data[i+m] = data[i]\\n        for i in reversed(range(m)):\\n            self.data[i] = min(self.data[2*i], self.data[2*i+1])\\n        self.query = [0]*(2*m)\\n    \\n    # push the query on seg_ind to its children\\n    def push(self,seg_ind):\\n        # let the children know of the queries\\n        q = self.query[seg_ind]\\n\\n        self.query[2*seg_ind]   += q\\n        self.query[2*seg_ind+1] += q\\n        \\n        self.data[2*seg_ind]   += q\\n        self.data[2*seg_ind+1] += q\\n\\n        # remove queries from seg_ind\\n        self.data[seg_ind] = min(self.data[2*seg_ind],self.data[2*seg_ind+1])\\n        self.query[seg_ind] = 0\\n\\n    # updates the node seg_ind to know of all queries\\n    # applied to it via its ancestors\\n    def update(self,seg_ind):\\n        # find all indecies to be updated\\n        seg_ind //= 2\\n        inds = []\\n        while seg_ind>0:\\n            inds.append(seg_ind)\\n            seg_ind//=2\\n       \\n        # push the queries down the segment tree\\n        for ind in reversed(inds):\\n            self.push(ind)\\n\\n    # make the changes to seg_ind be known to its ancestors\\n    def build(self,seg_ind):\\n        seg_ind//=2\\n        while seg_ind>0:\\n            self.data[seg_ind] = min(self.data[2*seg_ind], self.data[2*seg_ind+1]) + self.query[seg_ind]\\n            seg_ind //= 2\\n\\n    # lazily add value to [l,r)\\n    def add(self,l,r,value):\\n        l += self.m\\n        r += self.m\\n        \\n        l0 = l\\n        r0 = r\\n\\n        while l<r:\\n            if l%2==1:\\n                self.query[l]+= value\\n                self.data[l] += value\\n                l+=1\\n            if r%2==1:\\n                r-=1\\n                self.query[r]+= value\\n                self.data[r] += value\\n            l//=2\\n            r//=2\\n\\n        # tell all nodes above of the updated\\n        # area of the updates\\n        self.build(l0)\\n        self.build(r0-1)\\n    \\n    # min of data[l,r)\\n    def min(self,l,r):\\n        l += self.m\\n        r += self.m\\n\\n        # apply all the lazily stored queries\\n        self.update(l)\\n        self.update(r-1)\\n        \\n        segs = []\\n        while l<r:\\n            if l%2==1:\\n                segs.append(l)\\n                l+=1\\n            if r%2==1:\\n                r-=1\\n                segs.append(r)\\n            l//=2\\n            r//=2\\n\\n        return min(self.data[ind] for ind in segs)\\n\\n\\n    # find index of smallest value in data[l,r)\\n    def find_min(self,l,r):\\n        l += self.m\\n        r += self.m\\n        \\n        # apply all the lazily stored queries\\n        self.update(l)\\n        self.update(r-1)\\n\\n        segs = []\\n        while l<r:\\n            if l%2==1:\\n                segs.append(l)\\n                l+=1\\n            if r%2==1:\\n                r-=1\\n                segs.append(r)\\n            l//=2\\n            r//=2\\n\\n        ind = min(segs, key=lambda i:self.data[i])\\n        mini = self.data[ind]\\n       \\n        # dig down in search of mini\\n        while ind<self.m:\\n            self.push(ind)\\n\\n            if self.data[2*ind]==mini:\\n                ind *= 2\\n            else:\\n                ind = 2*ind+1\\n        \\n        return ind-self.m,mini\\n\\n\\nn,m = [int(x) for x in input().split()]\\n\\nA = [int(x) for x in input().split()]\\n\\ninter = []\\nbucketsl = [[] for _ in range(n)]\\nbucketsr = [[] for _ in range(n)]\\nfor _ in range(m):\\n    l,r = [int(x) for x in input().split()]\\n    l -= 1\\n    inter.append((l,r))\\n    bucketsl[l].append(r)\\n    if r<n:\\n        bucketsr[r].append(l)\\n\\nAneg = super_seg([-a for a in A])\\n\\nbesta = -1\\nbesta_ind = -1\\n\\nactive_intervals = 0\\nfor i in range(n):\\n    # Activate\\n    for r in bucketsl[i]:\\n        Aneg.add(i,r,1)\\n        active_intervals += 1\\n    # Deactivate\\n    for l in bucketsr[i]:\\n        Aneg.add(l,i,-1)\\n        active_intervals -= 1\\n    Amax = -Aneg.data[1]\\n    Ai = A[i] - active_intervals\\n    if Amax-Ai>besta:\\n        besta = Amax-Ai\\n        besta_ind = i\\n\\nints = [i for i in range(m) if inter[i][0]<=besta_ind<inter[i][1]]\\n\\nprint(besta)\\nprint(len(ints))\\nprint(*[x+1 for x in ints])\", \"import sys\\n\\n# a very nice implementation of a minimum segment tree with \\n# some inspiration taken from https://codeforces.com/blog/entry/18051\\n# this implementation should be able to be modified to do pretty\\n# much anything one would want to do with segment trees apart from\\n# persistance.\\n# note that especially in python this implementation is much much better\\n# than most other approches because how slow python can be with function\\n# calls. /pajenegod\\n\\n# currently it allows for two operations, both running in o(log n),\\n# 'add(l,r,value)' adds value to [l,r)\\n# 'find_min(l,r)' finds the index with the smallest value\\n\\nbig = 10**9\\n\\nclass super_seg:\\n    def __init__(self,data):\\n        n = len(data)\\n        m = 1\\n        while m<n: m *= 2\\n        \\n        self.n = n\\n        self.m = m\\n        self.data = [big]*(2*m)\\n        for i in range(n):\\n            self.data[i+m] = data[i]\\n        for i in reversed(list(range(m))):\\n            self.data[i] = min(self.data[2*i], self.data[2*i+1])\\n        self.query = [0]*(2*m)\\n    \\n    # push the query on seg_ind to its children\\n    def push(self,seg_ind):\\n        # let the children know of the queries\\n        q = self.query[seg_ind]\\n\\n        self.query[2*seg_ind]   += q\\n        self.query[2*seg_ind+1] += q\\n        \\n        self.data[2*seg_ind]   += q\\n        self.data[2*seg_ind+1] += q\\n\\n        # remove queries from seg_ind\\n        self.data[seg_ind] = min(self.data[2*seg_ind],self.data[2*seg_ind+1])\\n        self.query[seg_ind] = 0\\n\\n    # updates the node seg_ind to know of all queries\\n    # applied to it via its ancestors\\n    def update(self,seg_ind):\\n        # find all indecies to be updated\\n        seg_ind //= 2\\n        inds = []\\n        while seg_ind>0:\\n            inds.append(seg_ind)\\n            seg_ind//=2\\n       \\n        # push the queries down the segment tree\\n        for ind in reversed(inds):\\n            self.push(ind)\\n\\n    # make the changes to seg_ind be known to its ancestors\\n    def build(self,seg_ind):\\n        seg_ind//=2\\n        while seg_ind>0:\\n            self.data[seg_ind] = min(self.data[2*seg_ind], self.data[2*seg_ind+1]) + self.query[seg_ind]\\n            seg_ind //= 2\\n\\n    # lazily add value to [l,r)\\n    def add(self,l,r,value):\\n        l += self.m\\n        r += self.m\\n        \\n        l0 = l\\n        r0 = r\\n\\n        while l<r:\\n            if l%2==1:\\n                self.query[l]+= value\\n                self.data[l] += value\\n                l+=1\\n            if r%2==1:\\n                r-=1\\n                self.query[r]+= value\\n                self.data[r] += value\\n            l//=2\\n            r//=2\\n\\n        # tell all nodes above of the updated\\n        # area of the updates\\n        self.build(l0)\\n        self.build(r0-1)\\n    \\n    # min of data[l,r)\\n    def min(self,l,r):\\n        l += self.m\\n        r += self.m\\n\\n        # apply all the lazily stored queries\\n        self.update(l)\\n        self.update(r-1)\\n        \\n        segs = []\\n        while l<r:\\n            if l%2==1:\\n                segs.append(l)\\n                l+=1\\n            if r%2==1:\\n                r-=1\\n                segs.append(r)\\n            l//=2\\n            r//=2\\n\\n        return min(self.data[ind] for ind in segs)\\n\\n\\n    # find index of smallest value in data[l,r)\\n    def find_min(self,l,r):\\n        l += self.m\\n        r += self.m\\n        \\n        # apply all the lazily stored queries\\n        self.update(l)\\n        self.update(r-1)\\n\\n        segs = []\\n        while l<r:\\n            if l%2==1:\\n                segs.append(l)\\n                l+=1\\n            if r%2==1:\\n                r-=1\\n                segs.append(r)\\n            l//=2\\n            r//=2\\n\\n        ind = min(segs, key=lambda i:self.data[i])\\n        mini = self.data[ind]\\n       \\n        # dig down in search of mini\\n        while ind<self.m:\\n            self.push(ind)\\n\\n            if self.data[2*ind]==mini:\\n                ind *= 2\\n            else:\\n                ind = 2*ind+1\\n        \\n        return ind-self.m,mini\\n\\n\\nn,m = [int(x) for x in input().split()]\\n\\nA = [int(x) for x in input().split()]\\n\\ninter = []\\nupdate = [[] for _ in range(n+1)]\\nfor _ in range(m):\\n    l,r = [int(x) for x in input().split()]\\n    l -= 1\\n    inter.append((l,r))\\n    update[l].append((l,r))\\n    update[r].append((l,r))\\n\\nAneg = super_seg([-a for a in A])\\n\\nbesta = -1\\nbesta_ind = -1\\n\\nactive_intervals = 0\\nfor i in range(n):\\n    for l,r in update[i]:\\n        Aneg.add(l,r,1 if l==i else -1)\\n        active_intervals += 1 if l==i else -1 \\n    Amax = -Aneg.data[1]\\n    Ai = A[i] - active_intervals\\n    if Amax-Ai>besta:\\n        besta = Amax-Ai\\n        besta_ind = i\\n\\nints = [i for i in range(m) if inter[i][0]<=besta_ind<inter[i][1]]\\nprint(besta)\\nprint(len(ints))\\nprint(*[x+1 for x in ints])\\n\", \"import sys\\n\\n# a very nice implementation of a minimum segment tree with \\n# some inspiration taken from https://codeforces.com/blog/entry/18051\\n# this implementation should be able to be modified to do pretty\\n# much anything one would want to do with segment trees apart from\\n# persistance.\\n# note that especially in python this implementation is much much better\\n# than most other approches because how slow python can be with function\\n# calls. /pajenegod\\n\\n# currently it allows for two operations, both running in o(log n),\\n# 'add(l,r,value)' adds value to [l,r)\\n# 'find_min(l,r)' finds the index with the smallest value\\n\\nbig = 10**9\\n\\nclass super_seg:\\n    def __init__(self,data):\\n        n = len(data)\\n        m = 1\\n        while m<n: m *= 2\\n        \\n        self.n = n\\n        self.m = m\\n        self.data = [big]*(2*m)\\n        for i in range(n):\\n            self.data[i+m] = data[i]\\n        for i in reversed(list(range(m))):\\n            self.data[i] = min(self.data[2*i], self.data[2*i+1])\\n        self.query = [0]*(2*m)\\n    \\n    # push the query on seg_ind to its children\\n    def push(self,seg_ind):\\n        # let the children know of the queries\\n        q = self.query[seg_ind]\\n\\n        self.query[2*seg_ind]   += q\\n        self.query[2*seg_ind+1] += q\\n        \\n        self.data[2*seg_ind]   += q\\n        self.data[2*seg_ind+1] += q\\n\\n        # remove queries from seg_ind\\n        self.data[seg_ind] = min(self.data[2*seg_ind],self.data[2*seg_ind+1])\\n        self.query[seg_ind] = 0\\n\\n    # updates the node seg_ind to know of all queries\\n    # applied to it via its ancestors\\n    def update(self,seg_ind):\\n        # find all indecies to be updated\\n        seg_ind //= 2\\n        inds = []\\n        while seg_ind>0:\\n            inds.append(seg_ind)\\n            seg_ind//=2\\n       \\n        # push the queries down the segment tree\\n        for ind in reversed(inds):\\n            self.push(ind)\\n\\n    # make the changes to seg_ind be known to its ancestors\\n    def build(self,seg_ind):\\n        seg_ind//=2\\n        while seg_ind>0:\\n            self.data[seg_ind] = min(self.data[2*seg_ind], self.data[2*seg_ind+1]) + self.query[seg_ind]\\n            seg_ind //= 2\\n\\n    # lazily add value to [l,r)\\n    def add(self,l,r,value):\\n        l += self.m\\n        r += self.m\\n        \\n        l0 = l\\n        r0 = r\\n\\n        while l<r:\\n            if l%2==1:\\n                self.query[l]+= value\\n                self.data[l] += value\\n                l+=1\\n            if r%2==1:\\n                r-=1\\n                self.query[r]+= value\\n                self.data[r] += value\\n            l//=2\\n            r//=2\\n\\n        # tell all nodes above of the updated\\n        # area of the updates\\n        self.build(l0)\\n        self.build(r0-1)\\n    \\n    # min of data[l,r)\\n    def min(self,l,r):\\n        l += self.m\\n        r += self.m\\n\\n        # apply all the lazily stored queries\\n        self.update(l)\\n        self.update(r-1)\\n        \\n        segs = []\\n        while l<r:\\n            if l%2==1:\\n                segs.append(l)\\n                l+=1\\n            if r%2==1:\\n                r-=1\\n                segs.append(r)\\n            l//=2\\n            r//=2\\n\\n        return min(self.data[ind] for ind in segs)\\n\\n\\n    # find index of smallest value in data[l,r)\\n    def find_min(self,l,r):\\n        l += self.m\\n        r += self.m\\n        \\n        # apply all the lazily stored queries\\n        self.update(l)\\n        self.update(r-1)\\n\\n        segs = []\\n        while l<r:\\n            if l%2==1:\\n                segs.append(l)\\n                l+=1\\n            if r%2==1:\\n                r-=1\\n                segs.append(r)\\n            l//=2\\n            r//=2\\n\\n        ind = min(segs, key=lambda i:self.data[i])\\n        mini = self.data[ind]\\n       \\n        # dig down in search of mini\\n        while ind<self.m:\\n            self.push(ind)\\n\\n            if self.data[2*ind]==mini:\\n                ind *= 2\\n            else:\\n                ind = 2*ind+1\\n        \\n        return ind-self.m,mini\\n\\n\\nn,m = [int(x) for x in input().split()]\\nA = [int(x) for x in input().split()]\\n\\ninter = []\\nupdate = [[] for _ in range(n+1)]\\nfor _ in range(m):\\n    l,r = [int(x) for x in input().split()]\\n    l -= 1\\n    inter.append((l,r))\\n    update[l].append((l,r))\\n    update[r].append((l,r))\\n\\nAneg = super_seg([-a for a in A])\\nbesta = -1\\nbesta_ind = -1\\n\\nactive_intervals = 0\\nfor i in range(n):\\n    for l,r in update[i]:\\n        Aneg.add(l,r,1 if l==i else -1)\\n        active_intervals += 1 if l==i else -1 \\n    Amax = -Aneg.data[1]\\n    Ai = A[i] - active_intervals\\n    if Amax-Ai>besta:\\n        besta = Amax-Ai\\n        besta_ind = i\\n\\nints = [i for i in range(m) if inter[i][0]<=besta_ind<inter[i][1]]\\nprint(besta)\\nprint(len(ints))\\nprint(*[x+1 for x in ints])\\n\", \"import sys\\nimport copy\\ninput = sys.stdin.readline\\n\\nn,m=map(int,input().split())\\nA=list(map(int,input().split()))\\n\\nLR=[list(map(int,input().split())) for i in range(m)]\\n\\n\\nMLIST=[]\\nfor l,r in LR:\\n    MLIST.append(l)\\n    MLIST.append(r)\\n\\nMLIST=list(set(MLIST))\\nMLIST.sort()\\nMLIST.append(10**9)\\n\\n\\nMDICT=dict()\\nMLEN=len(MLIST)\\nfor i in range(MLEN):\\n    MDICT[MLIST[i]]=i\\n\\n\\nMINUSLIST=[[0]*(MLEN*2-1) for i in range(MLEN)]\\n\\nfor l,r in LR:\\n    for j in range(MDICT[l],MDICT[r]+1):\\n        for k in range(MDICT[l]*2+1,MDICT[r]*2+2):\\n            MINUSLIST[j][k]+=1\\n            \\n#print(MLIST)\\n#print(MINUSLIST)\\n\\n\\nA_m=[[float(\\\"inf\\\"),-float(\\\"inf\\\")] for i in range(MLEN*2-1)]\\n\\nif MLIST[0]!=1:\\n    A_m[0]=[min(A[:MLIST[0]-1]),max(A[:MLIST[0]-1])]\\n#if MLIST[MLEN-2]!=n:\\n#    A_m[MLEN*2-2]=[min(A[MLIST[MLEN-2]:]),max(A[MLIST[MLEN-2]:])]\\n\\nfor i in range(MLEN-1):\\n    x=MLIST[i]-1\\n    y=MLIST[i+1]-1\\n\\n    A_m[2*i+1]=[A[x],A[x]]\\n    if x+1!=y and x!=n-1:\\n        A_m[2*i+2]=[min(A[x+1:y]),max(A[x+1:y])]\\n    \\ndef MINUS(A,B):\\n    MIN=float(\\\"inf\\\")\\n    MAX=-float(\\\"inf\\\")\\n\\n    for i in range(MLEN*2-1):\\n        if MIN>A[i][0]-B[i]:\\n            MIN=A[i][0]-B[i]\\n        if MAX<A[i][1]-B[i]:\\n            MAX=A[i][1]-B[i]\\n\\n    return MAX-MIN\\n\\nANSLIST=[0]*MLEN\\n\\nfor i in range(MLEN):\\n    ANSLIST[i]=MINUS(A_m,MINUSLIST[i])\\n\\nprint(max(ANSLIST))\\ntarget=MLIST[ANSLIST.index(max(ANSLIST))]\\n\\nAN=[]\\nfor i in range(m):\\n    z,w=LR[i]\\n    if z<=target<=w:\\n        AN.append(i+1)\\n\\nprint(len(AN))\\nfor a in AN:\\n    print(a,end=\\\" \\\")\\n\\n\", \"import sys\\n\\n# a very nice implementation of a minimum segment tree with \\n# some inspiration taken from https://codeforces.com/blog/entry/18051\\n# this implementation should be able to be modified to do pretty\\n# much anything one would want to do with segment trees apart from\\n# persistance.\\n# note that especially in python this implementation is much much better\\n# than most other approches because how slow python can be with function\\n# calls. /pajenegod\\n\\n# currently it allows for two operations, both running in o(log n),\\n# 'add(l,r,value)' adds value to [l,r)\\n# 'find_min(l,r)' finds the index with the smallest value\\n\\nbig = 10**9\\n\\nclass super_seg:\\n    def __init__(self,data):\\n        n = len(data)\\n        m = 1\\n        while m<n: m *= 2\\n        \\n        self.n = n\\n        self.m = m\\n        self.data = [big]*(2*m)\\n        for i in range(n):\\n            self.data[i+m] = data[i]\\n        for i in reversed(range(m)):\\n            self.data[i] = min(self.data[2*i], self.data[2*i+1])\\n        self.query = [0]*(2*m)\\n    \\n    # push the query on seg_ind to its children\\n    def push(self,seg_ind):\\n        # let the children know of the queries\\n        q = self.query[seg_ind]\\n\\n        self.query[2*seg_ind]   += q\\n        self.query[2*seg_ind+1] += q\\n        \\n        self.data[2*seg_ind]   += q\\n        self.data[2*seg_ind+1] += q\\n\\n        # remove queries from seg_ind\\n        self.data[seg_ind] = min(self.data[2*seg_ind],self.data[2*seg_ind+1])\\n        self.query[seg_ind] = 0\\n\\n    # updates the node seg_ind to know of all queries\\n    # applied to it via its ancestors\\n    def update(self,seg_ind):\\n        # find all indecies to be updated\\n        seg_ind //= 2\\n        inds = []\\n        while seg_ind>0:\\n            inds.append(seg_ind)\\n            seg_ind//=2\\n       \\n        # push the queries down the segment tree\\n        for ind in reversed(inds):\\n            self.push(ind)\\n\\n    # make the changes to seg_ind be known to its ancestors\\n    def build(self,seg_ind):\\n        seg_ind//=2\\n        while seg_ind>0:\\n            self.data[seg_ind] = min(self.data[2*seg_ind], self.data[2*seg_ind+1]) + self.query[seg_ind]\\n            seg_ind //= 2\\n\\n    # lazily add value to [l,r)\\n    def add(self,l,r,value):\\n        l += self.m\\n        r += self.m\\n        \\n        l0 = l\\n        r0 = r\\n\\n        while l<r:\\n            if l%2==1:\\n                self.query[l]+= value\\n                self.data[l] += value\\n                l+=1\\n            if r%2==1:\\n                r-=1\\n                self.query[r]+= value\\n                self.data[r] += value\\n            l//=2\\n            r//=2\\n\\n        # tell all nodes above of the updated\\n        # area of the updates\\n        self.build(l0)\\n        self.build(r0-1)\\n    \\n    # min of data[l,r)\\n    def min(self,l,r):\\n        l += self.m\\n        r += self.m\\n\\n        # apply all the lazily stored queries\\n        self.update(l)\\n        self.update(r-1)\\n        \\n        segs = []\\n        while l<r:\\n            if l%2==1:\\n                segs.append(l)\\n                l+=1\\n            if r%2==1:\\n                r-=1\\n                segs.append(r)\\n            l//=2\\n            r//=2\\n\\n        return min(self.data[ind] for ind in segs)\\n\\n\\n    # find index of smallest value in data[l,r)\\n    def find_min(self,l,r):\\n        l += self.m\\n        r += self.m\\n        \\n        # apply all the lazily stored queries\\n        self.update(l)\\n        self.update(r-1)\\n\\n        segs = []\\n        while l<r:\\n            if l%2==1:\\n                segs.append(l)\\n                l+=1\\n            if r%2==1:\\n                r-=1\\n                segs.append(r)\\n            l//=2\\n            r//=2\\n\\n        ind = min(segs, key=lambda i:self.data[i])\\n        mini = self.data[ind]\\n       \\n        # dig down in search of mini\\n        while ind<self.m:\\n            self.push(ind)\\n\\n            if self.data[2*ind]==mini:\\n                ind *= 2\\n            else:\\n                ind = 2*ind+1\\n        \\n        return ind-self.m,mini\\n\\n\\nn,m = [int(x) for x in input().split()]\\nA = [int(x) for x in input().split()]\\n\\ninter = []\\nupdate = [[] for _ in range(n+1)]\\nfor _ in range(m):\\n    l,r = [int(x) for x in input().split()]\\n    l -= 1\\n    inter.append((l,r))\\n    update[l].append((l,r))\\n    update[r].append((l,r))\\n\\nAneg = super_seg([-a for a in A])\\nbesta = -1\\nbesta_ind = -1\\n\\nactive_intervals = 0\\nfor i in range(n):\\n    for l,r in update[i]:\\n        Aneg.add(l,r,1 if l==i else -1)\\n        active_intervals += 1 if l==i else -1 \\n    Amax = -Aneg.data[1]\\n    Ai = A[i] - active_intervals\\n    if Amax-Ai>besta:\\n        besta = Amax-Ai\\n        besta_ind = i\\n\\nints = [i for i in range(m) if inter[i][0]<=besta_ind<inter[i][1]]\\nprint(besta)\\nprint(len(ints))\\nprint(*[x+1 for x in ints])\", \"import sys\\n\\n# a very nice implementation of a minimum segment tree with \\n# some inspiration taken from https://codeforces.com/blog/entry/18051\\n# this implementation should be able to be modified to do pretty\\n# much anything one would want to do with segment trees apart from\\n# persistance.\\n# note that especially in python this implementation is much much better\\n# than most other approches because how slow python can be with function\\n# calls. /pajenegod\\n\\n# currently it allows for two operations, both running in o(log n),\\n# 'add(l,r,value)' adds value to [l,r)\\n# 'find_min(l,r)' finds the index with the smallest value\\n\\nbig = 10**9\\n\\nclass super_seg:\\n    def __init__(self,data):\\n        n = len(data)\\n        m = 1\\n        while m<n: m *= 2\\n        \\n        self.n = n\\n        self.m = m\\n        self.data = [big]*(2*m)\\n        for i in range(n):\\n            self.data[i+m] = data[i]\\n        for i in reversed(range(m)):\\n            self.data[i] = min(self.data[2*i], self.data[2*i+1])\\n        self.query = [0]*(2*m)\\n    \\n    # push the query on seg_ind to its children\\n    def push(self,seg_ind):\\n        # let the children know of the queries\\n        q = self.query[seg_ind]\\n\\n        self.query[2*seg_ind]   += q\\n        self.query[2*seg_ind+1] += q\\n        \\n        self.data[2*seg_ind]   += q\\n        self.data[2*seg_ind+1] += q\\n\\n        # remove queries from seg_ind\\n        self.data[seg_ind] = min(self.data[2*seg_ind],self.data[2*seg_ind+1])\\n        self.query[seg_ind] = 0\\n\\n    # updates the node seg_ind to know of all queries\\n    # applied to it via its ancestors\\n    def update(self,seg_ind):\\n        # find all indecies to be updated\\n        seg_ind //= 2\\n        inds = []\\n        while seg_ind>0:\\n            inds.append(seg_ind)\\n            seg_ind//=2\\n       \\n        # push the queries down the segment tree\\n        for ind in reversed(inds):\\n            self.push(ind)\\n\\n    # make the changes to seg_ind be known to its ancestors\\n    def build(self,seg_ind):\\n        seg_ind//=2\\n        while seg_ind>0:\\n            self.data[seg_ind] = min(self.data[2*seg_ind], self.data[2*seg_ind+1]) + self.query[seg_ind]\\n            seg_ind //= 2\\n\\n    # lazily add value to [l,r)\\n    def add(self,l,r,value):\\n        l += self.m\\n        r += self.m\\n        \\n        l0 = l\\n        r0 = r\\n\\n        while l<r:\\n            if l%2==1:\\n                self.query[l]+= value\\n                self.data[l] += value\\n                l+=1\\n            if r%2==1:\\n                r-=1\\n                self.query[r]+= value\\n                self.data[r] += value\\n            l//=2\\n            r//=2\\n\\n        # tell all nodes above of the updated\\n        # area of the updates\\n        self.build(l0)\\n        self.build(r0-1)\\n    \\n    # min of data[l,r)\\n    def min(self,l,r):\\n        l += self.m\\n        r += self.m\\n\\n        # apply all the lazily stored queries\\n        self.update(l)\\n        self.update(r-1)\\n        \\n        segs = []\\n        while l<r:\\n            if l%2==1:\\n                segs.append(l)\\n                l+=1\\n            if r%2==1:\\n                r-=1\\n                segs.append(r)\\n            l//=2\\n            r//=2\\n\\n        return min(self.data[ind] for ind in segs)\\n\\n\\n    # find index of smallest value in data[l,r)\\n    def find_min(self,l,r):\\n        l += self.m\\n        r += self.m\\n        \\n        # apply all the lazily stored queries\\n        self.update(l)\\n        self.update(r-1)\\n\\n        segs = []\\n        while l<r:\\n            if l%2==1:\\n                segs.append(l)\\n                l+=1\\n            if r%2==1:\\n                r-=1\\n                segs.append(r)\\n            l//=2\\n            r//=2\\n\\n        ind = min(segs, key=lambda i:self.data[i])\\n        mini = self.data[ind]\\n       \\n        # dig down in search of mini\\n        while ind<self.m:\\n            self.push(ind)\\n\\n            if self.data[2*ind]==mini:\\n                ind *= 2\\n            else:\\n                ind = 2*ind+1\\n        \\n        return ind-self.m,mini\\n\\n\\nn,m = [int(x) for x in input().split()]\\nA = [int(x) for x in input().split()]\\n\\ninter = []\\nupdate = [[] for _ in range(n+1)]\\nfor _ in range(m):\\n    l,r = [int(x) for x in input().split()]\\n    l -= 1\\n    inter.append((l,r))\\n    update[l].append((l,r))\\n    update[r].append((l,r))\\n\\nAneg = super_seg([-a for a in A])\\nbesta = -1\\nbesta_ind = -1\\n\\nactive_intervals = 0\\nfor i in range(n):\\n    for l,r in update[i]:\\n        Aneg.add(l,r,1 if l==i else -1)\\n        active_intervals += 1 if l==i else -1 \\n    Amax = -Aneg.data[1]\\n    Ai = A[i] - active_intervals\\n    if Amax-Ai>besta:\\n        besta = Amax-Ai\\n        besta_ind = i\\n\\nints = [i for i in range(m) if inter[i][0]<=besta_ind<inter[i][1]]\\nprint(besta)\\nprint(len(ints))\\nprint(*[x+1 for x in ints])\", \"def main():\\n    n, m = list(map(int, input().split()))\\n    aa = list(map(int, input().split()))\\n    res = max(aa) - min(aa)\\n    ll, rr = [n + 1], [n + 1]\\n    segments = res_segments = [False] * (m + 1)\\n    bounds = {0, n, n + 1}\\n    for _ in range(m):\\n        l, r = list(map(int, input().split()))\\n        l -= 1\\n        ll.append(l)\\n        rr.append(r)\\n        bounds.add(l)\\n        bounds.add(r)\\n    xlat = sorted(bounds)\\n    mi, ma = [], []\\n    for l, r in zip(xlat, xlat[1:-1]):\\n        t = aa[l:r]\\n        mi.append(min(t))\\n        ma.append(max(t))\\n    bounds = {x: i for i, x in enumerate(xlat)}\\n    for xx in (ll, rr):\\n        for i, x in enumerate(xx):\\n            xx[i] = bounds[x]\\n    il, ir = (sorted(list(range(m + 1)), key=xx.__getitem__, reverse=True) for xx in (ll, rr))\\n    for i in range(len(xlat) - 1):\\n        while True:\\n            k = il[-1]\\n            lo = ll[k]\\n            if lo > i:\\n                break\\n            segments[k] = True\\n            for j in range(lo, rr[k]):\\n                mi[j] -= 1\\n                ma[j] -= 1\\n            del il[-1]\\n\\n        x = max(ma) - min(mi)\\n        if res < x:\\n            res = x\\n            res_segments = segments[:]\\n        while True:\\n            k = ir[-1]\\n            hi = rr[k]\\n            if hi > i:\\n                break\\n            segments[k] = False\\n            for j in range(ll[k], hi):\\n                mi[j] += 1\\n                ma[j] += 1\\n            del ir[-1]\\n\\n    print(res)\\n    segments = [i for i, f in enumerate(res_segments) if f]\\n    print(len(segments))\\n    print(*segments)\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"n, m = list(map(int, input().split()))\\nA = list(map(int, input().split()))\\nLf = [[] for _ in range(n)]\\nRb = [[] for _ in range(n)]\\nLR = []\\nfor i in range(m):\\n    l, r = list(map(int, input().split()))\\n    l, r = l-1, r-1\\n    Lf[r].append(l)\\n    Rb[l].append(r)\\n    LR.append((l, r))\\n\\nminus = [0]*n\\nINF = 10**18\\nans = [-INF]*n\\nmn = A[0]\\n\\nfor i in range(n):\\n    ans[i] = max(ans[i], A[i]-mn)\\n    for l in Lf[i]:\\n        for j in range(l, i+1):\\n            minus[j] -= 1\\n            mn = min(mn, A[j]+minus[j])\\n    mn = min(mn, A[i]+minus[i])\\n\\nminus = [0]*n\\nmn = A[n-1]\\nfor i in reversed(list(range(n))):\\n    ans[i] = max(ans[i], A[i]-mn)\\n    for r in Rb[i]:\\n        for j in range(i, r+1):\\n            minus[j] -= 1\\n            mn = min(mn, A[j]+minus[j])\\n    mn = min(mn, A[i]+minus[i])\\nans_ = max(ans)\\nres = []\\nfor i in range(n):\\n    if ans[i] == ans_:\\n        for j in range(m):\\n            l, r = LR[j]\\n            if not (l <= i and i <= r):\\n                res.append(j+1)\\n        break\\nprint(ans_)\\nprint(len(res))\\nprint(*res)\\n\"]", "task": "apps", "difficulty": "introductory", "split": "test", "transformation_type": "vanilla"}