{"qid": 4129, "orig_input": "There are $n$ cities and $m$ roads in Berland. Each road connects a pair of cities. The roads in Berland are one-way.\n\nWhat is the minimum number of new roads that need to be built to make all the cities reachable from the capital?\n\nNew roads will also be one-way.\n\n\n-----Input-----\n\nThe first line of input consists of three integers $n$, $m$ and $s$ ($1 \\le n \\le 5000, 0 \\le m \\le 5000, 1 \\le s \\le n$) \u2014 the number of cities, the number of roads and the index of the capital. Cities are indexed from $1$ to $n$.\n\nThe following $m$ lines contain roads: road $i$ is given as a pair of cities $u_i$, $v_i$ ($1 \\le u_i, v_i \\le n$, $u_i \\ne v_i$). For each pair of cities $(u, v)$, there can be at most one road from $u$ to $v$. Roads in opposite directions between a pair of cities are allowed (i.e. from $u$ to $v$ and from $v$ to $u$).\n\n\n-----Output-----\n\nPrint one integer \u2014 the minimum number of extra roads needed to make all the cities reachable from city $s$. If all the cities are already reachable from $s$, print 0.\n\n\n-----Examples-----\nInput\n9 9 1\n1 2\n1 3\n2 3\n1 5\n5 6\n6 1\n1 8\n9 8\n7 1\n\nOutput\n3\n\nInput\n5 4 5\n1 2\n2 3\n3 4\n4 1\n\nOutput\n1\n\n\n\n-----Note-----\n\nThe first example is illustrated by the following: [Image] \n\nFor example, you can add roads ($6, 4$), ($7, 9$), ($1, 7$) to make all the cities reachable from $s = 1$.\n\nThe second example is illustrated by the following: [Image] \n\nIn this example, you can add any one of the roads ($5, 1$), ($5, 2$), ($5, 3$), ($5, 4$) to make all the cities reachable from $s = 5$.", "input": "There are $n$ cities and $m$ roads in Berland. Each road connects a pair of cities. The roads in Berland are one-way.\n\nWhat is the minimum number of new roads that need to be built to make all the cities reachable from the capital?\n\nNew roads will also be one-way.\n\n\n-----Input-----\n\nThe first line of input consists of three integers $n$, $m$ and $s$ ($1 \\le n \\le 5000, 0 \\le m \\le 5000, 1 \\le s \\le n$) \u2014 the number of cities, the number of roads and the index of the capital. Cities are indexed from $1$ to $n$.\n\nThe following $m$ lines contain roads: road $i$ is given as a pair of cities $u_i$, $v_i$ ($1 \\le u_i, v_i \\le n$, $u_i \\ne v_i$). For each pair of cities $(u, v)$, there can be at most one road from $u$ to $v$. Roads in opposite directions between a pair of cities are allowed (i.e. from $u$ to $v$ and from $v$ to $u$).\n\n\n-----Output-----\n\nPrint one integer \u2014 the minimum number of extra roads needed to make all the cities reachable from city $s$. If all the cities are already reachable from $s$, print 0.\n\n\n-----Examples-----\nInput\n9 9 1\n1 2\n1 3\n2 3\n1 5\n5 6\n6 1\n1 8\n9 8\n7 1\n\nOutput\n3\n\nInput\n5 4 5\n1 2\n2 3\n3 4\n4 1\n\nOutput\n1\n\n\n\n-----Note-----\n\nThe first example is illustrated by the following: [Image] \n\nFor example, you can add roads ($6, 4$), ($7, 9$), ($1, 7$) to make all the cities reachable from $s = 1$.\n\nThe second example is illustrated by the following: [Image] \n\nIn this example, you can add any one of the roads ($5, 1$), ($5, 2$), ($5, 3$), ($5, 4$) to make all the cities reachable from $s = 5$.", "test_cases": {"inputs": ["9 9 1\n1 2\n1 3\n2 3\n1 5\n5 6\n6 1\n1 8\n9 8\n7 1\n", "5 4 5\n1 2\n2 3\n3 4\n4 1\n", "5000 0 2956\n", "2 0 2\n", "2 1 1\n1 2\n", "2 1 2\n1 2\n", "2 2 2\n1 2\n2 1\n", "5000 2 238\n3212 238\n238 3212\n", "5000 2 3810\n3225 1137\n1137 3225\n", "100 1 30\n69 81\n", "500 1 209\n183 107\n", "1000 1 712\n542 916\n", "39 40 38\n4 8\n24 28\n16 17\n7 25\n4 29\n34 35\n16 24\n21 10\n23 36\n36 14\n28 16\n34 19\n15 21\n22 38\n22 37\n37 27\n28 33\n3 29\n32 22\n12 30\n9 15\n5 19\n23 27\n19 17\n25 17\n24 11\n39 10\n6 20\n16 6\n3 18\n34 21\n15 38\n11 19\n11 3\n32 4\n15 13\n16 11\n11 7\n33 7\n3 33\n", "8 8 1\n3 2\n3 4\n4 5\n5 3\n6 4\n6 7\n7 8\n8 6\n", "7 7 1\n2 3\n4 2\n7 4\n5 7\n4 5\n4 6\n6 4\n", "2333 1 1\n1 2\n", "7 4 2\n1 2\n3 4\n5 6\n7 1\n", "1 0 1\n", "9 9 1\n2 3\n3 4\n4 5\n6 2\n7 6\n8 7\n6 8\n5 9\n9 2\n", "30 30 29\n29 9\n1 3\n15 5\n14 24\n7 18\n17 12\n5 9\n22 7\n26 20\n7 29\n8 2\n10 12\n17 18\n17 24\n8 12\n23 28\n10 15\n18 2\n29 13\n25 29\n9 2\n7 13\n11 5\n19 26\n10 5\n25 5\n20 10\n5 26\n24 23\n22 8\n", "30 30 28\n16 28\n5 30\n7 17\n6 1\n12 28\n15 28\n14 30\n25 11\n25 10\n25 8\n12 30\n27 5\n30 10\n22 14\n30 13\n20 27\n15 25\n24 20\n20 15\n1 30\n3 10\n3 4\n3 18\n15 14\n18 22\n20 26\n10 3\n15 27\n23 29\n10 24\n"], "outputs": ["3\n", "1\n", "4999\n", "1\n", "0\n", "1\n", "0\n", "4998\n", "4998\n", "98\n", "498\n", "998\n", "12\n", "1\n", "1\n", "2331\n", "3\n", "0\n", "1\n", "13\n", "9\n"]}, "solutions": "[\"\\nfrom queue import Queue\\nfrom random import shuffle\\nimport sys\\nimport math\\nimport os.path\\n\\n\\nsys.setrecursionlimit(100000)\\n\\n# LOG\\n\\ndef log(*args, **kwargs):\\n    print(*args, file=sys.stderr, **kwargs)\\n\\n\\n# INPUT\\n\\ndef ni():\\n    return map(int, input().split())\\n\\n\\ndef nio(offset):\\n    return map(lambda x: int(x) + offset, input().split())\\n\\n\\ndef nia():\\n    return list(map(int, input().split()))\\n\\n\\n# CONVERT\\ndef toString(aList, sep=\\\" \\\"):\\n    return sep.join(str(x) for x in aList)\\n\\n\\ndef toMapInvertIndex(aList):\\n    return {k: v for v, k in enumerate(aList)}\\n\\n\\n# SORT\\ndef sortId(arr):\\n    return sorted(range(len(arr)), key=lambda k: arr[k])\\n\\n\\n# MAIN\\n\\nn,m,s = ni()\\n\\ns -= 1\\n\\nadj = [[] for _ in range(n)]\\n\\nfor i in range(m):\\n    u,v = nio(-1)\\n    if (v != s):\\n        adj[u].append(v)\\n\\nstack = []\\n\\nvisited= [False]*n\\n\\ndef dfs(x):\\n    nonlocal visited\\n    nonlocal stack\\n    visited[x] = True\\n    for y in adj[x]:\\n        if not visited[y]:\\n            dfs(y)\\n\\n    stack.append(x)\\n\\n\\nfor i in range(n):\\n    if not visited[i]:\\n        dfs(i)\\n\\n# log(adj)\\n# log(visited)\\n# log(stack)\\n\\ncount = -1\\n\\ndef loang(x):\\n    nonlocal visited\\n    visited[x] = False\\n    for y in adj[x]:\\n        if visited[y]:\\n            loang(y)\\n\\n\\nfor x in stack[::-1]:\\n    if visited[x]:\\n        count += 1\\n        loang(x)\\n\\nprint(count)\", \"\\nfrom queue import Queue\\nfrom random import shuffle\\nimport sys\\nimport math\\nimport os.path\\n\\n\\nsys.setrecursionlimit(10**9)\\n\\n# LOG\\n\\ndef log(*args, **kwargs):\\n    print(*args, file=sys.stderr, **kwargs)\\n\\n\\n# INPUT\\n\\ndef ni():\\n    return map(int, input().split())\\n\\n\\ndef nio(offset):\\n    return map(lambda x: int(x) + offset, input().split())\\n\\n\\ndef nia():\\n    return list(map(int, input().split()))\\n\\n\\n# CONVERT\\ndef toString(aList, sep=\\\" \\\"):\\n    return sep.join(str(x) for x in aList)\\n\\n\\ndef toMapInvertIndex(aList):\\n    return {k: v for v, k in enumerate(aList)}\\n\\n\\n# SORT\\ndef sortId(arr):\\n    return sorted(range(len(arr)), key=lambda k: arr[k])\\n\\n\\n# MAIN\\n\\nn,m,s = ni()\\n\\ns -= 1\\n\\nadj = [[] for _ in range(n)]\\n\\nfor i in range(m):\\n    u,v = nio(-1)\\n    if (v != s):\\n        adj[u].append(v)\\n\\nstack = []\\n\\nvisited= [False]*n\\n\\ndef dfs(x):\\n    nonlocal visited\\n    nonlocal stack\\n    visited[x] = True\\n    for y in adj[x]:\\n        if not visited[y]:\\n            dfs(y)\\n\\n    stack.append(x)\\n\\n\\nfor i in range(n):\\n    if not visited[i]:\\n        dfs(i)\\n\\n# log(adj)\\n# log(visited)\\n# log(stack)\\n\\ncount = -1\\n\\ndef loang(x):\\n    nonlocal visited\\n    visited[x] = False\\n    for y in adj[x]:\\n        if visited[y]:\\n            loang(y)\\n\\n\\nfor x in stack[::-1]:\\n    if visited[x]:\\n        count += 1\\n        loang(x)\\n\\nprint(count)\", \"from collections import defaultdict\\nimport sys\\nsys.setrecursionlimit(1000000)\\n\\nn, m, s = list(map(int, input().split()))\\ns = s - 1\\n\\n\\ndef read_graph():\\n    g = defaultdict(list)\\n    for _ in range(m):\\n        (u, v) = [int(x) - 1 for x in input().split()]\\n        if v != s:\\n            g[u].append(v)\\n    return g\\n\\n\\nG = read_graph()\\nvis = defaultdict(lambda: False)\\ntopo = []\\n\\n\\ndef dfs(u):\\n    # print(u)\\n    for v in G[u]:\\n        if not vis[v]:\\n            vis[v] = True\\n            dfs(v)\\n    topo.append(u)\\n\\n\\nfor i in range(n):\\n    if not vis[i]:\\n        vis[i] = True\\n        dfs(i)\\n\\nvis.clear()\\nvis[s] = True\\ndfs(s)\\nans = 0\\nfor i in topo[::-1]:\\n    if not vis[i]:\\n        vis[i] = True\\n        ans += 1\\n        dfs(i)\\n\\nprint(ans)\\n\", \"from collections import defaultdict\\nimport sys\\nsys.setrecursionlimit(1000000)\\n\\nn, m, s = list(map(int, input().split()))\\ns = s - 1\\n\\n\\ndef read_graph():\\n    g = defaultdict(list)\\n    for _ in range(m):\\n        (u, v) = [int(x) - 1 for x in input().split()]\\n        # if v != s:\\n        g[u].append(v)\\n    return g\\n\\n\\nG = read_graph()\\nvis = defaultdict(lambda: False)\\ntopo = []\\n\\n\\ndef dfs(u):\\n    # print(u)\\n    for v in G[u]:\\n        if not vis[v]:\\n            vis[v] = True\\n            dfs(v)\\n    topo.append(u)\\n\\n\\nfor i in range(n):\\n    if not vis[i]:\\n        vis[i] = True\\n        dfs(i)\\n\\nvis.clear()\\nvis[s] = True\\ndfs(s)\\nans = 0\\nfor i in topo[::-1]:\\n    if not vis[i]:\\n        vis[i] = True\\n        ans += 1\\n        dfs(i)\\n\\nprint(ans)\\n\", \"import sys\\n\\n\\ndef dfs(u):\\n    avail[u] = False\\n    for v in g[u]:\\n        if avail[v]:\\n            dfs(v)\\n    topo.append(u)\\n\\n\\nsys.setrecursionlimit(6000)\\nn, m, s = map(int, input().split())\\ng = [[] for _ in range(n)]\\nfor _ in range(m):\\n    u, v = map(int, input().split())\\n    g[u - 1].append(v - 1)\\navail, topo = [True] * n, []\\nfor i,a in enumerate(avail):\\n    if a:\\n        dfs(i)\\navail, res = [True] * n, 0\\ndfs(s - 1)\\nfor i in reversed(topo):\\n    if avail[i]:\\n        res += 1\\n        dfs(i)\\nprint(res)\", \"import sys\\n\\nN = 5000 + 5\\nadj = [[] for i in range(N)]\\nmark = [0 for i in range(N)]\\ntopo = []\\nsys.setrecursionlimit(6000)\\n#fin = open(\\\"999E.inp\\\", \\\"r\\\")\\n#fou = open(\\\"999E.out\\\", \\\"w\\\")\\n#n, m, s = map(int, fin.readline().split())\\nn, m, s = list(map(int, input().split()))\\nfor i in range(m):\\n\\t#u, v = map(int, fin.readline().split())\\n\\tu, v = list(map(int, input().split()))\\n\\tadj[u].append(v)\\n\\ndef topoSort(u):\\n\\tmark[u] = 1\\n\\tfor j in range(len(adj[u])):\\n\\t\\tv = adj[u][j]\\n\\t\\tif (mark[v] == 0): topoSort(v)\\n\\ttopo.append(u)\\n\\ndef dfs(u):\\n\\tmark[u] = 1\\n\\tfor j in range(len(adj[u])):\\n\\t\\tv = adj[u][j]\\n\\t\\tif (mark[v] == 0): dfs(v)\\n\\nfor i in range(1, n+1):\\n\\tif (mark[i] == 0):\\n\\t\\ttopoSort(i)\\ntopo.reverse()\\nfor i in range(1, n+1):\\n\\tmark[i] = 0\\ndfs(s)\\nres = 0\\nfor i in range(n):\\n\\tv = topo[i]\\n\\tif (mark[v] == 0):\\n\\t\\tres += 1\\n\\t\\tdfs(v)\\n#fou.write(str(res))\\nprint(res)\\n\\n\", \"from collections import defaultdict\\nimport sys\\ndef dfs(u):\\n    avail[u] = False\\n    for v in g[u]:\\n        if avail[v]:\\n            dfs(v)\\n    topo.append(u)\\n\\n\\nsys.setrecursionlimit(6000)\\nn, m, s = map(int, input().split())\\ng = [[] for _ in range(n)]\\nfor _ in range(m):\\n    u, v = map(int, input().split())\\n    g[u - 1].append(v - 1)\\n\\navail, topo = [True] * n, []\\nfor i,a in enumerate(avail):\\n    if a:\\n        dfs(i)\\navail, res = [True] * n, 0\\ndfs(s - 1)\\nfor i in reversed(topo):\\n    if avail[i]:\\n        res += 1\\n        dfs(i)\\nprint(res)\", \"import sys\\n\\nn, m, s = list(map(int, input().split()))\\n\\nadj = [[] for i in range(500005)]\\nar = []\\nvis = [0 for i in range(500005)]\\nsys.setrecursionlimit(6000)\\n\\ndef dfs(s):\\n    vis[s] = 1\\n    for i in range(len(adj[s])):\\n        if(vis[adj[s][i]] == 0):\\n            dfs(adj[s][i])\\n    ar.append(s)\\n\\n\\nfor i in range(m):\\n    u, v = list(map(int, input().split()))\\n    adj[u].append(v)\\n\\ndfs(s)\\n\\nfor i in range(n):\\n    if(vis[i + 1] == 0):\\n        dfs(i + 1)\\nres = 0\\nvis = [0 for i in range(500005)]\\nfor i in range(n - 1, -1, -1):\\n    if(vis[ar[i]] == 0):\\n        if(s != ar[i]):\\n            res += 1\\n        dfs(ar[i])\\n\\nprint(res)\\n\", \"import sys\\n\\nn, m, s = list(map(int, input().split()))\\n\\nadj = [[] for _ in range(500005)]\\nar = []\\nvis = [0] * 500005\\nsys.setrecursionlimit(6000)\\n\\ndef dfs(s):\\n    vis[s] = 1\\n    for i in range(len(adj[s])):\\n        if(vis[adj[s][i]] == 0):\\n            dfs(adj[s][i])\\n    ar.append(s)\\n\\n\\nfor i in range(m):\\n    u, v = list(map(int, input().split()))\\n    adj[u].append(v)\\n\\ndfs(s)\\n\\nfor i in range(n):\\n    if(vis[i + 1] == 0):\\n        dfs(i + 1)\\nres = 0\\nvis = [0] * 500005\\nfor i in range(n - 1, -1, -1):\\n    if(vis[ar[i]] == 0):\\n        if(s != ar[i]):\\n            res += 1\\n        dfs(ar[i])\\n\\nprint(res)\\n\", \"import sys\\n\\nBigNum = 10 ** 10\\n\\nclass DSU:\\n    def __init__(self, count, stateInitializer, stateMerger):\\n        self.vs = list(range(count))\\n        self.states = [stateInitializer(i) for i in range(count)]\\n        self.sizes = [1] * count\\n        self.merger = stateMerger\\n    \\n    def get(self, i):\\n        if self.vs[i] == i:\\n            return i\\n        else:\\n            res = self.get(self.vs[i])\\n            self.vs[i] = res\\n            return res\\n\\n    def getState(self, i):\\n        return self.states[self.get(i)]\\n    \\n    def setState(self, i, newState):\\n        i = self.get(i)\\n        self.states[i] = newState\\n    \\n    def unite(self, a, b):\\n        a = self.get(a)\\n        b = self.get(b)\\n        if a == b:\\n            return a\\n\\n        mergedState = self.merger(self.states[a], self.states[b])\\n        if self.sizes[a] >= self.sizes[b]:\\n            self.vs[b] = a\\n            self.sizes[a] += self.sizes[b]\\n            self.states[a] = mergedState\\n            return a\\n        else:\\n            self.vs[a] = b\\n            self.sizes[b] += self.sizes[a]\\n            self.states[b] = mergedState\\n            return b\\n    \\n    def flatten(self):\\n        for i in range(len(self.vs)):\\n            self.get(i)\\n    \\n    def setNames(self):\\n        self.flatten()\\n        return set(self.vs)\\n\\nn, m, s = list(map(int, input().split(' ')))\\nps = [[] for _ in range(n+1)]\\nedges = []\\nfor i in range(m):\\n    u, v = list(map(int, input().split(' ')))\\n    ps[v] += [u]\\n    edges += [(u, v)]\\n\\ndsu = DSU(\\n    n+1,\\n    lambda i: (0, BigNum),\\n    lambda a, b: (min(a[0], b[0]), min(a[1], b[1]))\\n)\\n\\ndef dfs(v, depth):\\n    vSt = dsu.getState(v)\\n    vState, vMinDepth = vSt\\n\\n    if vState >= 1:\\n        raise 'Not supposed to dfs processed node!'\\n\\n    vState = 1\\n    vMinDepth = depth\\n    dsu.setState(v, (vState, vMinDepth))\\n\\n    for nv in ps[v]:\\n        #print(':', v, nv)\\n        nvSt = dsu.getState(nv)\\n        nvState, nvMinDepth = nvSt\\n\\n        if nvState == 2:\\n            continue\\n        if nvState == 1:\\n            if nvMinDepth < vMinDepth:\\n                vMinDepth = nvMinDepth\\n                dsu.setState(v, (vState, vMinDepth))\\n        else:\\n            nvMinDepth = dfs(nv, depth + 1)\\n            if nvMinDepth <= depth:\\n                dsu.unite(v, nv)\\n\\n            if nvMinDepth < vMinDepth:\\n                vMinDepth = nvMinDepth\\n                dsu.setState(v, (vState, vMinDepth))\\n\\n    if depth <= vMinDepth:\\n        vState = 2\\n        dsu.setState(v, (vState, vMinDepth))\\n\\n    return vMinDepth\\n\\n\\nsys.setrecursionlimit(12000)\\n\\nfor i in range(1, n+1):\\n    st = dsu.getState(i)\\n    if st[0] == 0:\\n        dfs(i, 0)\\n\\ncomponents = dsu.setNames().difference({0})\\n#print(dsu.vs)\\n#print(components)\\n\\ncomponents = components.difference({ dsu.get(s) })\\nfor (u, v) in edges:\\n    u, v = dsu.get(u), dsu.get(v)\\n    if u == v:\\n        continue\\n    components = components.difference({ v })\\n\\n#print(components)\\nprint(len(components))\\n\", \"import sys\\n\\nBigNum = 10 ** 10\\n\\nclass DSU:\\n    def __init__(self, count, stateInitializer, stateMerger):\\n        self.vs = list(range(count))\\n        self.states = [stateInitializer(i) for i in range(count)]\\n        self.sizes = [1] * count\\n        self.merger = stateMerger\\n    \\n    def get(self, i):\\n        if self.vs[i] == i:\\n            return i\\n        else:\\n            res = self.get(self.vs[i])\\n            self.vs[i] = res\\n            return res\\n\\n    def getState(self, i):\\n        return self.states[self.get(i)]\\n    \\n    def setState(self, i, newState):\\n        i = self.get(i)\\n        self.states[i] = newState\\n    \\n    def unite(self, a, b):\\n        a = self.get(a)\\n        b = self.get(b)\\n        if a == b:\\n            return a\\n\\n        mergedState = self.merger(self.states[a], self.states[b])\\n        if self.sizes[a] >= self.sizes[b]:\\n            self.vs[b] = a\\n            self.sizes[a] += self.sizes[b]\\n            self.states[a] = mergedState\\n            return a\\n        else:\\n            self.vs[a] = b\\n            self.sizes[b] += self.sizes[a]\\n            self.states[b] = mergedState\\n            return b\\n    \\n    def flatten(self):\\n        for i in range(len(self.vs)):\\n            self.get(i)\\n    \\n    def setNames(self):\\n        self.flatten()\\n        return set(self.vs)\\n\\nn, m, s = list(map(int, input().split(' ')))\\nps = [[] for _ in range(n+1)]\\nedges = []\\nfor i in range(m):\\n    u, v = list(map(int, input().split(' ')))\\n    ps[v] += [u]\\n    edges += [(u, v)]\\n\\ndsu = DSU(\\n    n+1,\\n    lambda i: (0, BigNum),\\n    lambda a, b: (min(a[0], b[0]), min(a[1], b[1]))\\n)\\n\\ndef dfs(v, depth):\\n    vSt = dsu.getState(v)\\n    vState, vMinDepth = vSt\\n\\n    if vState >= 1:\\n        raise 'Not supposed to dfs processed node!'\\n\\n    vState = 1\\n    vMinDepth = depth\\n    dsu.setState(v, (vState, vMinDepth))\\n\\n    for nv in ps[v]:\\n        #print(':', v, nv)\\n        nvSt = dsu.getState(nv)\\n        nvState, nvMinDepth = nvSt\\n\\n        if nvState == 2:\\n            continue\\n        if nvState == 1:\\n            if nvMinDepth < vMinDepth:\\n                vMinDepth = nvMinDepth\\n                dsu.setState(v, (vState, vMinDepth))\\n        else:\\n            nvMinDepth = dfs(nv, depth + 1)\\n            if nvMinDepth <= depth:\\n                dsu.unite(v, nv)\\n\\n            if nvMinDepth < vMinDepth:\\n                vMinDepth = nvMinDepth\\n                dsu.setState(v, (vState, vMinDepth))\\n\\n    if depth <= vMinDepth:\\n        vState = 2\\n        dsu.setState(v, (vState, vMinDepth))\\n\\n    return vMinDepth\\n\\n\\nsys.setrecursionlimit(6000)\\n\\nfor i in range(1, n+1):\\n    st = dsu.getState(i)\\n    if st[0] == 0:\\n        dfs(i, 0)\\n\\ncomponents = dsu.setNames().difference({0})\\n#print(dsu.vs)\\n#print(components)\\n\\ncomponents = components.difference({ dsu.get(s) })\\nfor (u, v) in edges:\\n    u, v = dsu.get(u), dsu.get(v)\\n    if u == v:\\n        continue\\n    components = components.difference({ v })\\n\\n#print(components)\\nprint(len(components))\\n\", \"import sys\\n\\n\\ndef d(u):\\n    rt[u] = False\\n    for v in q[u]:\\n        if rt[v]:\\n            d(v)\\n    topo.append(u)\\n\\n\\nsys.setrecursionlimit(6000)\\nn, m, s = map(int, input().split())\\nq = [[] for _ in range(n)]\\nfor _ in range(m):\\n    u, v = map(int, input().split())\\n    q[u - 1].append(v - 1)\\nrt, topo = [True] * n, []\\nfor i,a in enumerate(rt):\\n    if a:\\n        d(i)\\nrt, res = [True] * n, 0\\nd(s - 1)\\nfor i in reversed(topo):\\n    if rt[i]:\\n        res += 1\\n        d(i)\\nprint(res)\", \"import sys\\nsys.setrecursionlimit(6000)\\n\\nn, m, s = map(int, input().split())\\ns -= 1\\ng = [[] for _ in range(n)]\\nfor _ in range(m):\\n    a, b = map(int, input().split())\\n    g[a-1].append(b-1)\\n\\nused = [False] * 5010\\ntopo = []\\n\\ndef topo_sort(node):\\n    used[node] = True\\n    for c in g[node]:\\n        if not used[c]:\\n            topo_sort(c)\\n    topo.append(node)\\n\\ndef dfs(node):\\n    used[node] = True\\n    for c in g[node]:\\n        if not used[c]:\\n            dfs(c)\\n\\nfor i in range(n):\\n    if not used[i]:\\n        topo_sort(i)\\n\\ntopo.reverse()\\nfor i in range(n):\\n    used[i] = False\\n\\ndfs(s)\\nres = 0\\nfor v in topo:\\n    if not used[v]:\\n        res += 1\\n        dfs(v)\\n\\nprint(res)\", \"from collections import deque\\nimport sys\\nsys.setrecursionlimit(1000000)\\n \\n\\nn, m, s = [int(x) for x in input().split()]\\nadj = [[] for u in range(n + 1)]\\nvis = [False for u in range(n + 1)]\\nfor i in range(m):\\n    u, v = [int(x) for x in input().split()]\\n    adj[u].append(v)\\n\\ndef tarjan():\\n    low = [-1 for u in range(n + 1)]\\n    disc = [-1 for v in range(n + 1)]\\n    in_stack = [False for v in range(n + 1)]\\n    st = deque()\\n    comp = []\\n\\n    def dfs(u):\\n        dfs.dfs_time = dfs.dfs_time + 1\\n        low[u] = dfs.dfs_time\\n        disc[u] = dfs.dfs_time\\n        in_stack[u] = True\\n        st.append(u)\\n\\n        for v in adj[u]:\\n            if disc[v] == -1:\\n                dfs(v)\\n                low[u] = min(low[u], low[v])\\n            elif in_stack[v]:\\n                low[u] = min(low[u], disc[v])\\n\\n        if low[u] == disc[u]:\\n            comp.append([])\\n            while u != st[-1]:\\n                x = st.pop()\\n                in_stack[x] = False\\n                comp[-1].append(x)\\n            x = st.pop()\\n            in_stack[x] = False\\n            comp[-1].append(x)\\n\\n    dfs.dfs_time = 0\\n    for i in range(1, n + 1):\\n        if disc[i] == -1:\\n            dfs(i)\\n\\n    return comp[::-1]\\n\\ndef visit(adj, vis, src):\\n    q = deque()\\n    q.append(src)\\n    vis[src] = True\\n    while len(q) > 0: \\n        u = q.popleft()\\n        for v in adj[u]:\\n            if vis[v] == False:\\n                vis[v] = True\\n                q.append(v)\\n    \\nans = 0\\nvisit(adj, vis, s)\\ntarOrd = tarjan()\\nfor lis in tarOrd:\\n    x = lis[0]\\n    if vis[lis[0]] == False:\\n        visit(adj, vis, x)\\n        ans += 1\\n\\nprint(ans)\\n\\n\\n\\n\", \"from bisect import bisect\\nfrom collections import defaultdict\\n# l = list(map(int,input().split()))\\n# map(int,input().split()))\\nfrom math import gcd,sqrt,ceil\\nfrom collections import Counter\\nimport sys\\nsys.setrecursionlimit(10**9)\\n\\ndef dfs(n):\\n    b[n] =True\\n\\n    for i in hash[n]:\\n        if b[i] == False:\\n            dfs(i)\\n\\n    top.append(n)\\nn,m,s = list(map(int,input().split()))\\n\\nhash = defaultdict(list)\\n\\nfor i in range(m):\\n    a,b = list(map(int,input().split()))\\n    hash[a].append(b)\\n\\nb = [False]*(n+1)\\ntop = []\\nfor i in range(1,n+1):\\n    if not b[i]:\\n        dfs(i)\\nb = [False]*(n+1)\\ndfs(s)\\ntop.reverse()\\ncount = 0\\nfor i in top:\\n    if not b[i]:\\n        count+=1\\n        dfs(i)\\n\\nprint(count)\\n\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nn, m, s = list(map(int, input().split()))\\ns -= 1\\nadj = [[] for _ in range(n)]\\nrev = [[] for _ in range(n)]\\n\\nfor u, v in (list(map(int, input().split())) for _ in range(m)):\\n    adj[u-1].append(v-1)\\n    rev[v-1].append(u-1)\\n\\ngroup = [-1]*n\\ngroup[s] = 0\\nstack = [s]\\n\\nwhile stack:\\n    v = stack.pop()\\n    for dest in adj[v]:\\n        if group[dest] != -1:\\n            continue\\n        group[dest] = 0\\n        stack.append(dest)\\n\\ng = 0\\nfor i in range(n):\\n    if group[i] != -1 or rev[i]:\\n        continue\\n    g += 1\\n    group[i] = g\\n    stack = [i]\\n\\n    while stack:\\n        v = stack.pop()\\n        for dest in adj[v]:\\n            if group[dest] != -1:\\n                continue\\n            group[dest] = g\\n            stack.append(dest)\\n\\nfor i in range(n):\\n    if group[i] != -1:\\n        continue\\n    g += 1\\n    group[i] = g\\n    stack = [i]\\n\\n    while stack:\\n        v = stack.pop()\\n        for dest in adj[v]:\\n            if group[dest] == 0 or group[dest] == g:\\n                continue\\n            group[dest] = g\\n            stack.append(dest)\\n\\nprint(len(set(group)) - 1)\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nn, m, s = list(map(int, input().split()))\\ns -= 1\\nadj = [[] for _ in range(n)]\\nrev = [[] for _ in range(n)]\\n\\nfor u, v in (list(map(int, input().split())) for _ in range(m)):\\n    adj[u-1].append(v-1)\\n    rev[v-1].append(u-1)\\n\\ngroup = [-1]*n\\ng = 0\\ngroup[s] = g\\nstack = [s]\\n\\nwhile stack:\\n    v = stack.pop()\\n    for dest in adj[v]:\\n        if group[dest] != -1:\\n            continue\\n        group[dest] = g\\n        stack.append(dest)\\n\\n\\nfor i in range(n):\\n    if group[i] != -1:\\n        continue\\n    g += 1\\n    group[i] = g\\n    stack = [i]\\n\\n    while stack:\\n        v = stack.pop()\\n        for dest in adj[v]:\\n            if group[dest] == 0 or group[dest] == g:\\n                continue\\n            group[dest] = g\\n            stack.append(dest)\\n\\nprint(len(set(group)) - 1)\\n\", \"# -*- coding: utf-8 -*-\\n\\nimport sys\\nfrom collections import Counter\\n\\ndef input(): return sys.stdin.readline().strip()\\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\\ndef ceil(x, y=1): return int(-(-x // y))\\ndef INT(): return int(input())\\ndef MAP(): return list(map(int, input().split()))\\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\\ndef Yes(): print('Yes')\\ndef No(): print('No')\\ndef YES(): print('YES')\\ndef NO(): print('NO')\\nINF = 10 ** 18\\nMOD = 10 ** 9 + 7\\n\\ndef bfs(nodes, src):\\n    from collections import deque\\n\\n    que = deque([(src, 0)])\\n    dist[src][src] = 1\\n    while que:\\n        u, c = que.popleft()\\n        for v in nodes[u]:\\n            if dist[src][v]:\\n                continue\\n            dist[src][v] = 1\\n            que.append((v, c+1))\\n\\nN, M, s = MAP()\\ns -= 1\\n\\nnodes = [[] for i in range(N)]\\nfor _ in range(M):\\n    a, b = MAP()\\n    a -= 1; b -= 1\\n    nodes[a].append(b)\\n\\ndist = list2d(N, N, 0)\\nfor i in range(N):\\n    bfs(nodes, i)\\n\\nneed = []\\nfor v in range(N):\\n    if not dist[s][v]:\\n        need.append((dist[v].count(1), v))\\nneed.sort(reverse=1)\\n\\ndone = [False] * N\\nans = 0\\nfor _, u in need:\\n    if not done[u]:\\n        for v, can in enumerate(dist[u]):\\n            if can:\\n                done[v] = True\\n        ans += 1\\nprint(ans)\\n\", \"from collections import defaultdict\\n\\ndef topo_sort_variant(graph, n):\\n    result = []\\n    visited = [False] * (n+1)\\n\\n    for i in range(1, n+1):\\n        if not visited[i]:\\n            stack = [i]\\n            while stack:\\n                node = stack[-1]\\n                if not visited[node]:\\n                    visited[node] = True\\n                    for child in graph[node]:\\n                        if not visited[child]:\\n                            stack.append(child)\\n                else:\\n                    result.append(stack.pop())\\n    return result\\n\\n\\n\\ndef __starting_point():\\n    min_roads_required = 0\\n    ncities, nroads, capital = map(int, input().split())\\n\\n    g = defaultdict(list)\\n\\n    for i in range(nroads):\\n        u, v = map(int, input().split())\\n        g[u].append(v)\\n\\n    #print(\\\"The graph is:\\\", g)\\n    op = topo_sort_variant(g, ncities)\\n    #print(\\\"The topo sort output is\\\", op)\\n\\n    visited = [False] * (ncities + 1)\\n\\n    def topo_dfs(i):\\n        stack = [i]\\n        while stack:\\n            node = stack[-1]\\n            if not visited[node]:\\n                visited[node] = True\\n                for child in g[node]:\\n                    if not visited[child]:\\n                        stack.append(child)\\n            else:\\n                stack.pop()\\n\\n\\n    topo_dfs(capital)\\n    for i in reversed(topo_sort_variant(g, ncities)):\\n        if not visited[i]:\\n            topo_dfs(i)\\n            min_roads_required += 1\\n\\n    print(min_roads_required)\\n__starting_point()\", \"import sys\\ninput=lambda:sys.stdin.readline().rstrip()\\nsys.setrecursionlimit(50000)\\n\\n# \\u5f37\\u9023\\u7d50\\u6210\\u5206\\u5206\\u89e3(SCC): \\u30b0\\u30e9\\u30d5G\\u306b\\u5bfe\\u3059\\u308bSCC\\u3092\\u884c\\u3046\\n# \\u5165\\u529b: <N>: \\u9802\\u70b9\\u30b5\\u30a4\\u30ba, <G>: \\u9806\\u65b9\\u5411\\u306e\\u6709\\u5411\\u30b0\\u30e9\\u30d5, <RG>: \\u9006\\u65b9\\u5411\\u306e\\u6709\\u5411\\u30b0\\u30e9\\u30d5\\n# \\u51fa\\u529b: (<\\u30e9\\u30d9\\u30eb\\u6570>, <\\u5404\\u9802\\u70b9\\u306e\\u30e9\\u30d9\\u30eb\\u756a\\u53f7>)\\ndef scc(N, G, RG):\\n  order = []\\n  used = [0]*N\\n  group = [None]*N\\n  def dfs(s):\\n    used[s] = 1\\n    for t in G[s]:\\n      if not used[t]:\\n        dfs(t)\\n    order.append(s)\\n  def rdfs(s, col):\\n    group[s] = col\\n    used[s] = 1\\n    for t in RG[s]:\\n      if not used[t]:\\n        rdfs(t, col)\\n  for i in range(N):\\n    if not used[i]:\\n      dfs(i)\\n  used = [0]*N\\n  label = 0\\n  for s in reversed(order):\\n    if not used[s]:\\n      rdfs(s, label)\\n      label += 1\\n  return label, group\\n\\n# \\u7e2e\\u7d04\\u5f8c\\u306e\\u30b0\\u30e9\\u30d5\\u3092\\u69cb\\u7bc9\\ndef construct(N, G, label, group):\\n  G0 = [[] for i in range(label)]\\n  GP = [[] for i in range(label)]\\n  for v in range(N):\\n    lbs = group[v]\\n    for w in G[v]:\\n      lbt = group[w]\\n      if lbs == lbt:\\n        continue\\n      G0[lbs].append(lbt)\\n    GP[lbs].append(v)\\n  return G0, GP\\n\\nn,m,s=map(int,input().split())\\ns-=1\\nedge=[[]for _ in range(n)]\\nredge=[[]for _ in range(n)]\\nfor _ in range(m):\\n  a,b=map(int,input().split())\\n  a-=1\\n  b-=1\\n  edge[a].append(b)\\n  redge[b].append(a)\\nlabel,group=scc(n,edge,redge)\\na,b=construct(n,redge,label,group)\\nans=0\\nfor i in range(label):\\n  if len(a[i])==0:\\n    ans+=(i!=group[s])\\nprint(ans)\", \"def main():\\n    import sys\\n    sys.setrecursionlimit(10**5)\\n    from collections import deque\\n    n, m, s = map(int, input().split())\\n    s -= 1\\n    graph = [[] for _ in range(n)]\\n    for _ in range(m):\\n        u, v = map(int, input().split())\\n        graph[u-1].append(v-1)\\n\\n    seen = [False]*n\\n    li = deque()\\n\\n    def visit(node):\\n        if not seen[node]:\\n            seen[node] = True\\n            for c_node in graph[node]:\\n                visit(c_node)\\n            li.appendleft(node)\\n\\n    def visit2(node):\\n        if not seen[node]:\\n            seen[node] = True\\n            for c_node in graph[node]:\\n                visit2(c_node)\\n\\n    for i in range(n):\\n        visit(i)\\n    seen = [False]*n\\n    cnt = 0\\n    visit2(s)\\n    for i in li:\\n        if seen[i]:\\n            continue\\n        visit2(i)\\n        cnt += 1\\n    print(cnt)\\n\\ndef __starting_point():\\n    try:\\n        main()\\n    except:\\n        print('error!')\\n        return\\n__starting_point()\", \"import sys\\nsys.setrecursionlimit(10**5)\\nfrom collections import deque\\nn, m, s = map(int, input().split())\\ns -= 1\\ngraph = [[] for _ in range(n)]\\nfor _ in range(m):\\n    u, v = map(int, input().split())\\n    graph[u-1].append(v-1)\\n\\nseen = [False]*n\\nli = deque()\\ndef visit(node):\\n    if not seen[node]:\\n        seen[node] = True\\n        for c_node in graph[node]:\\n            visit(c_node)\\n        li.appendleft(node)\\nfor i in range(n):\\n    visit(i)\\nseen = [False]*n\\ncnt = 0\\nli2 = list(li)\\nvisit(s)\\nfor i in li2:\\n    if seen[i]:\\n        continue\\n    visit(i)\\n    cnt += 1\\nprint(cnt)\"]", "task": "apps", "difficulty": "introductory", "split": "test", "transformation_type": "vanilla"}