{"qid": 4150, "orig_input": "There are $n$ students standing in a row. Two coaches are forming two teams \u2014 the first coach chooses the first team and the second coach chooses the second team.\n\nThe $i$-th student has integer programming skill $a_i$. All programming skills are distinct and between $1$ and $n$, inclusive.\n\nFirstly, the first coach will choose the student with maximum programming skill among all students not taken into any team, and $k$ closest students to the left of him and $k$ closest students to the right of him (if there are less than $k$ students to the left or to the right, all of them will be chosen). All students that are chosen leave the row and join the first team. Secondly, the second coach will make the same move (but all students chosen by him join the second team). Then again the first coach will make such move, and so on. This repeats until the row becomes empty (i. e. the process ends when each student becomes to some team).\n\nYour problem is to determine which students will be taken into the first team and which students will be taken into the second team.\n\n\n-----Input-----\n\nThe first line of the input contains two integers $n$ and $k$ ($1 \\le k \\le n \\le 2 \\cdot 10^5$) \u2014 the number of students and the value determining the range of chosen students during each move, respectively.\n\nThe second line of the input contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le n$), where $a_i$ is the programming skill of the $i$-th student. It is guaranteed that all programming skills are distinct.\n\n\n-----Output-----\n\nPrint a string of $n$ characters; $i$-th character should be 1 if $i$-th student joins the first team, or 2 otherwise.\n\n\n-----Examples-----\nInput\n5 2\n2 4 5 3 1\n\nOutput\n11111\n\nInput\n5 1\n2 1 3 5 4\n\nOutput\n22111\n\nInput\n7 1\n7 2 1 3 5 4 6\n\nOutput\n1121122\n\nInput\n5 1\n2 4 5 3 1\n\nOutput\n21112\n\n\n\n-----Note-----\n\nIn the first example the first coach chooses the student on a position $3$, and the row becomes empty (all students join the first team).\n\nIn the second example the first coach chooses the student on position $4$, and the row becomes $[2, 1]$ (students with programming skills $[3, 4, 5]$ join the first team). Then the second coach chooses the student on position $1$, and the row becomes empty (and students with programming skills $[1, 2]$ join the second team).\n\nIn the third example the first coach chooses the student on position $1$, and the row becomes $[1, 3, 5, 4, 6]$ (students with programming skills $[2, 7]$ join the first team). Then the second coach chooses the student on position $5$, and the row becomes $[1, 3, 5]$ (students with programming skills $[4, 6]$ join the second team). Then the first coach chooses the student on position $3$, and the row becomes $[1]$ (students with programming skills $[3, 5]$ join the first team). And then the second coach chooses the remaining student (and the student with programming skill $1$ joins the second team).\n\nIn the fourth example the first coach chooses the student on position $3$, and the row becomes $[2, 1]$ (students with programming skills $[3, 4, 5]$ join the first team). Then the second coach chooses the student on position $1$, and the row becomes empty (and students with programming skills $[1, 2]$ join the second team).", "input": "There are $n$ students standing in a row. Two coaches are forming two teams \u2014 the first coach chooses the first team and the second coach chooses the second team.\n\nThe $i$-th student has integer programming skill $a_i$. All programming skills are distinct and between $1$ and $n$, inclusive.\n\nFirstly, the first coach will choose the student with maximum programming skill among all students not taken into any team, and $k$ closest students to the left of him and $k$ closest students to the right of him (if there are less than $k$ students to the left or to the right, all of them will be chosen). All students that are chosen leave the row and join the first team. Secondly, the second coach will make the same move (but all students chosen by him join the second team). Then again the first coach will make such move, and so on. This repeats until the row becomes empty (i. e. the process ends when each student becomes to some team).\n\nYour problem is to determine which students will be taken into the first team and which students will be taken into the second team.\n\n\n-----Input-----\n\nThe first line of the input contains two integers $n$ and $k$ ($1 \\le k \\le n \\le 2 \\cdot 10^5$) \u2014 the number of students and the value determining the range of chosen students during each move, respectively.\n\nThe second line of the input contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le n$), where $a_i$ is the programming skill of the $i$-th student. It is guaranteed that all programming skills are distinct.\n\n\n-----Output-----\n\nPrint a string of $n$ characters; $i$-th character should be 1 if $i$-th student joins the first team, or 2 otherwise.\n\n\n-----Examples-----\nInput\n5 2\n2 4 5 3 1\n\nOutput\n11111\n\nInput\n5 1\n2 1 3 5 4\n\nOutput\n22111\n\nInput\n7 1\n7 2 1 3 5 4 6\n\nOutput\n1121122\n\nInput\n5 1\n2 4 5 3 1\n\nOutput\n21112\n\n\n\n-----Note-----\n\nIn the first example the first coach chooses the student on a position $3$, and the row becomes empty (all students join the first team).\n\nIn the second example the first coach chooses the student on position $4$, and the row becomes $[2, 1]$ (students with programming skills $[3, 4, 5]$ join the first team). Then the second coach chooses the student on position $1$, and the row becomes empty (and students with programming skills $[1, 2]$ join the second team).\n\nIn the third example the first coach chooses the student on position $1$, and the row becomes $[1, 3, 5, 4, 6]$ (students with programming skills $[2, 7]$ join the first team). Then the second coach chooses the student on position $5$, and the row becomes $[1, 3, 5]$ (students with programming skills $[4, 6]$ join the second team). Then the first coach chooses the student on position $3$, and the row becomes $[1]$ (students with programming skills $[3, 5]$ join the first team). And then the second coach chooses the remaining student (and the student with programming skill $1$ joins the second team).\n\nIn the fourth example the first coach chooses the student on position $3$, and the row becomes $[2, 1]$ (students with programming skills $[3, 4, 5]$ join the first team). Then the second coach chooses the student on position $1$, and the row becomes empty (and students with programming skills $[1, 2]$ join the second team).", "test_cases": {"inputs": ["5 2\n2 4 5 3 1\n", "5 1\n2 1 3 5 4\n", "7 1\n7 2 1 3 5 4 6\n", "5 1\n2 4 5 3 1\n", "100 1\n78 52 95 76 96 49 53 59 77 100 64 11 9 48 15 17 44 46 21 54 39 68 43 4 32 28 73 6 16 62 72 84 65 86 98 75 33 45 25 3 91 82 2 92 63 88 7 50 97 93 14 22 20 42 60 55 80 85 29 34 56 71 83 38 26 47 90 70 51 41 40 31 37 12 35 99 67 94 1 87 57 8 61 19 23 79 36 18 66 74 5 27 81 69 24 58 13 10 89 30\n", "100 2\n62 70 29 14 12 87 94 78 39 92 84 91 61 49 60 33 69 37 19 82 42 8 45 97 81 43 54 67 1 22 77 58 65 17 18 28 25 57 16 90 40 13 4 21 68 35 15 76 73 93 56 95 79 47 74 75 30 71 66 99 41 24 88 83 5 6 31 96 38 80 27 46 51 53 2 86 32 9 20 100 26 36 63 7 52 55 23 3 50 59 48 89 85 44 34 64 10 72 11 98\n", "100 3\n100 6 41 33 5 32 39 58 95 48 27 17 90 73 10 81 56 87 79 91 43 42 47 75 57 98 22 49 67 28 94 86 89 60 65 96 11 46 13 23 85 61 9 99 63 52 15 66 40 31 12 72 93 20 77 44 88 55 16 54 38 7 26 19 97 36 14 92 3 4 1 24 2 8 50 76 82 34 51 53 64 45 70 37 18 62 25 21 69 35 74 30 71 84 59 80 83 29 78 68\n", "100 4\n80 78 96 22 39 21 74 48 61 16 55 32 27 52 34 51 98 4 72 47 42 46 28 90 43 33 44 99 91 11 29 85 92 19 58 73 65 12 87 97 54 59 75 15 9 63 24 67 71 84 36 6 60 94 82 89 70 95 31 5 10 3 37 49 45 18 83 53 64 17 100 1 81 86 88 38 20 40 66 77 50 7 30 69 14 13 79 35 23 68 57 25 8 93 41 62 56 2 76 26\n", "100 5\n73 72 15 88 11 48 18 17 52 10 75 99 71 80 97 57 47 32 31 12 64 45 85 26 41 14 21 66 27 84 82 6 29 38 37 62 91 65 92 3 40 1 4 13 42 63 44 68 67 46 87 5 9 50 93 36 7 51 79 58 98 70 56 81 83 96 35 54 74 20 55 2 49 43 59 53 30 94 16 89 19 39 61 22 77 23 90 28 34 8 78 100 76 24 33 69 95 25 60 86\n", "100 10\n19 55 91 50 31 23 60 84 38 1 22 51 27 76 28 98 11 44 61 63 15 93 52 3 66 16 53 36 18 62 35 85 78 37 73 64 87 74 46 26 82 69 49 33 83 89 56 67 71 25 39 94 96 17 21 6 47 68 34 42 57 81 13 10 54 2 48 80 20 77 4 5 59 30 90 95 45 75 8 88 24 41 40 14 97 32 7 9 65 70 100 99 72 58 92 29 79 12 86 43\n", "100 20\n66 99 9 17 2 42 79 50 34 15 77 100 91 46 64 93 37 68 52 78 73 57 53 61 19 86 21 39 5 60 96 55 74 40 51 3 16 11 41 45 6 65 20 70 84 90 18 4 71 48 98 76 44 14 13 35 7 58 72 94 75 63 27 97 23 92 1 49 54 43 83 22 56 12 89 81 33 28 25 47 59 67 29 10 62 26 8 85 88 87 32 31 69 95 24 30 36 80 38 82\n", "100 25\n81 45 55 5 13 10 42 44 18 4 6 72 89 78 3 100 73 91 47 33 99 93 98 2 11 92 49 69 8 21 43 41 46 36 40 7 87 14 76 62 29 58 38 56 19 24 35 61 53 1 77 79 80 67 15 28 94 51 64 96 57 95 63 30 54 71 22 68 59 97 27 32 85 52 88 90 65 60 17 12 20 86 26 39 37 48 16 83 66 34 70 9 74 75 84 82 50 25 23 31\n", "100 50\n2 4 82 12 47 63 52 91 87 45 53 1 17 25 64 50 9 13 22 54 21 30 43 24 38 33 68 11 41 78 99 23 28 18 58 67 79 10 71 56 49 61 26 29 59 20 90 74 5 75 89 8 39 95 72 42 66 98 44 32 88 35 92 3 97 55 65 51 77 27 81 76 84 69 73 85 19 46 62 100 60 37 7 36 57 6 14 83 40 48 16 70 96 15 31 93 80 86 94 34\n", "100 7\n43 82 34 4 37 23 1 58 13 55 24 93 92 90 41 80 87 65 39 89 19 42 56 20 27 61 53 26 72 36 59 86 75 68 31 46 54 57 67 8 2 28 48 63 95 79 30 78 25 49 52 7 29 81 5 14 11 96 98 99 35 97 76 17 38 83 62 71 69 91 60 84 15 16 64 32 74 51 70 40 22 77 3 18 66 45 33 85 100 88 47 12 94 21 50 9 6 73 44 10\n", "100 7\n25 66 64 59 98 50 84 73 34 49 100 93 7 30 53 69 39 65 52 5 47 29 42 38 90 46 77 16 81 56 76 88 37 32 15 36 97 87 40 11 67 2 89 99 20 18 31 26 14 33 4 51 75 61 19 1 10 68 43 82 80 17 54 74 12 35 83 72 45 6 92 8 24 86 60 22 27 41 91 44 21 9 48 23 78 71 70 13 96 94 55 28 79 95 57 58 3 85 63 62\n", "100 7\n20 27 16 53 17 24 18 43 44 46 6 97 93 52 51 29 8 50 31 94 81 61 4 25 35 12 36 99 57 86 79 11 5 23 28 92 59 82 48 26 78 67 38 62 63 73 15 45 88 87 95 56 9 39 1 96 66 19 76 40 42 69 41 34 30 89 7 83 37 14 84 54 13 80 65 71 47 32 70 100 85 64 60 21 75 2 91 90 3 77 49 33 68 98 74 22 58 10 55 72\n", "100 7\n89 100 24 91 95 84 22 64 69 52 76 99 62 93 82 57 72 21 26 27 9 32 71 96 17 2 4 40 41 50 55 60 36 14 70 11 68 74 80 98 75 15 94 29 63 66 38 3 25 28 79 13 97 16 1 39 33 12 30 49 90 10 87 18 42 20 88 73 6 5 65 85 37 77 19 43 81 31 61 86 78 34 7 59 8 58 23 83 35 67 54 56 47 44 48 53 45 46 51 92\n", "100 7\n26 5 48 33 80 43 2 21 75 40 54 53 37 34 93 14 11 13 77 57 19 27 65 89 69 84 22 97 3 52 9 28 73 78 31 1 86 76 39 20 49 64 29 8 63 62 12 7 38 17 60 46 35 47 51 95 41 4 92 68 25 67 44 85 36 10 94 83 56 32 100 90 82 24 45 59 71 6 61 16 23 55 87 74 98 66 96 50 42 15 18 30 58 91 99 81 70 88 72 79\n", "1 1\n1\n"], "outputs": ["11111\n", "22111\n", "1121122\n", "21112\n", "1221112111122222112222221111111111111221112222222221111122211222122211111122211112222222222111222111\n", "2222111112222211111112222211222221211111112221111222221112222211111111221222211111222222122222111111\n", "1111222222222222111111111111111111111111222222211222222211111222222211222222222222222222111111111111\n", "1111111221221111111112222222222222222222222222111111122222222212221111111111111111222222211111111122\n", "1111112222222222211111111111222222222222222222111111111111111111111111112222222222222211111111111222\n", "1111122222222222222222222211111111222222221111111111111111111112222222222222222211111111111111111111\n", "1111111111111111111111111111111122222222222222222222222222222222222222222111111111111111111111111111\n", "1111111111111111111111111111111111111111111122222222222222222222222222222222222222222222222222211111\n", "2222222222222222222222222222211111111111111111111111111111111111111111111111111111111111111111111111\n", "2222222222222222222222222221111111111111111111111111222222222222222111111111111111111111111111111112\n", "1121111111111111112222222222222211112222222222222221111111111112222222222222221111111111111111111111\n", "2222222222222222222222222222222222222222222111111111111111111111111111111111111111111111111111111111\n", "1111111112222222222111111111112211111111111111122222222222221111111111111122222222222221111122222222\n", "1111111222222222222222222222222222222111112222221111111111111111111111111111111111111112222222222222\n", "1\n"]}, "solutions": "[\"IN = input\\nrint = lambda: int(IN())\\nrmint = lambda: map(int, IN().split())\\nrlist = lambda: list(rmint())\\n\\nn, k = rmint()\\npr = [i for i in range(-1, n - 1)]\\nnx = [i for i in range(+1, n + 1)]\\nans = [0] * n\\np = [0] * n\\ni = 0\\nfor g in rlist():\\n    p[n-(g-1)-1] = i\\n    i += 1\\n\\n\\ndef dl(x, t):\\n    ans[x] = t\\n    if nx[x] < n: pr[nx[x]] = pr[x]\\n    if pr[x] >= 0: nx[pr[x]] = nx[x]\\n\\n\\nt = 1\\nfor c in p:\\n    #print(ans)\\n    #print(pr)\\n    #print(nx)\\n    if ans[c]: continue\\n    dl(c, t)\\n    j = pr[c]\\n    for i in range(k):\\n        if j < 0: break\\n        dl(j, t)\\n        j = pr[j]\\n    j = nx[c]\\n    for i in range(k):\\n        if j >= n: break\\n        dl(j, t)\\n        j = nx[j]\\n    t = 3 - t\\nfor o in ans: print(o, end='')\\n\", \"n, k = map(int, input().split())\\n\\nlst = map(int, input().split())\\n\\ndef debug():\\n\\n\\tprint('-')\\n\\tlst = [0 for _ in range(n)]\\n\\tfor i in range(n):\\n\\t\\tnode = table[i]\\n\\t\\tlst[node.index] = node.team\\n\\n\\tprint (''.join(str(x) for x in lst))\\n\\tprint('-')\\n\\nclass Node:\\n\\n\\tdef __init__(self, index):\\n\\t\\tself.index = index\\n\\t\\tself.team = 0 \\n\\t\\tself.prev = None\\n\\t\\tself.next = None\\n\\ntable = [None for _ in range(n)]\\n\\nprev_node = None\\nfor index, element in enumerate(lst):\\n\\n\\tnode = Node(index)\\n\\n\\tif prev_node:\\n\\t\\tprev_node.next = node\\n\\n\\tnode.prev = prev_node\\n\\n\\ttable[element - 1] = node\\n\\tprev_node = node\\n\\nteam = 1\\nfor i in reversed(range(n)):\\n\\n\\t# taken\\n\\tif table[i].team != 0:\\n\\t\\tcontinue\\n\\n\\tnode = table[i]\\n\\tnode.team = team\\n\\n\\tnext_node = node.next\\n\\tfor j in range(k):\\n\\n\\t\\tif next_node is None:\\n\\t\\t\\tbreak\\n\\n\\t\\tnext_node.team = team\\n\\t\\tnext_node = next_node.next\\n\\n\\tprev_node = node.prev\\n\\tfor j in range(k):\\n\\n\\t\\tif prev_node is None:\\n\\t\\t\\tbreak\\n\\n\\t\\tprev_node.team = team\\n\\t\\tprev_node = prev_node.prev\\n\\n\\tif prev_node is not None:\\n\\t\\tprev_node.next = next_node\\n\\n\\tif next_node is not None:\\n\\t\\tnext_node.prev = prev_node\\n\\n\\tteam = 1 if team == 2 else 2\\n\\nlst = [0 for _ in range(n)]\\nfor i in range(n):\\n\\tnode = table[i]\\n\\tlst[node.index] = node.team\\n\\nprint (''.join(str(x) for x in lst))\", \"N, K = list(map(int, input().split()))\\nA = [int(a)-1 for a in input().split()]\\nT = [0] * N\\ninv = [0] * N\\nfor i in range(N):\\n    inv[A[i]] = i\\n\\nL = [a-1 for a in range(N)]\\nR = [a+1 for a in range(N)]\\n\\nc = 0\\nt = 2\\ni = N-1\\nwhile c < N and i >= 0:\\n    j = inv[i]\\n    if T[j]:\\n        i -= 1\\n        continue\\n    t = 3 - t\\n    T[j] = t\\n    c += 1\\n    k = K\\n    pj = j\\n    while True:\\n        nj = L[pj]\\n        if k==0 or nj < 0:\\n            break\\n        T[nj] = t\\n        c += 1\\n        k -= 1\\n        pj = nj\\n    ll = nj\\n    k = K\\n    pj = j\\n    while True:\\n        nj = R[pj]\\n        if k==0 or nj >= N:\\n            break\\n        T[nj] = t\\n        c += 1\\n        k -= 1\\n        pj = nj\\n    rr = nj\\n    if rr < N:\\n        L[rr] = ll\\n    if ll >= 0:\\n        R[ll] = rr\\n    i -= 1\\n\\nprint(\\\"\\\".join(map(str, T)))\\n\", \"n, k = map(int, input().split())\\nstudents = list(map(int, input().split()))\\norder = sorted(range(n), key=lambda x: -students[x])\\nneighbours = [[t - 1, t + 1] for t in range(n)]\\nneighbours[-1][1] = -1\\nturn = 0\\nteam = [0] * n\\nfor i in range(n):\\n    if team[order[i]] == 0:\\n        team[order[i]] = turn % 2 + 1\\n        left, right = neighbours[order[i]]\\n        for _ in range(k):\\n            if left != -1:\\n                team[left] = turn % 2 + 1\\n                neighbours[order[i]][0] = neighbours[left][0]\\n                if neighbours[left][0] != -1:\\n                    neighbours[neighbours[left][0]][1] = order[i]\\n                left = neighbours[left][0]\\n            if right != -1:\\n                team[right] = turn % 2 + 1\\n                neighbours[order[i]][1] = neighbours[right][1]\\n                if neighbours[right][1] != -1:\\n                    neighbours[neighbours[right][1]][0] = order[i]\\n                right = neighbours[right][1]\\n        left, right = neighbours[order[i]]\\n        if left != -1:\\n            neighbours[left][1] = right\\n        if right != -1:\\n            neighbours[right][0] = left\\n        turn += 1\\nprint(*team, sep=\\\"\\\")\\n\", \"import sys\\n\\n\\nilist = [int(i) for i in input().split()]\\nn, k = ilist[0], ilist[1]\\na = [int(i) for i in input().split()]\\n\\nleft, right = [], []\\n\\nfor i in range(n):\\n    left.append(i - 1)\\n    right.append(i + 1)\\n\\nval_idx = [[a[i], i] for i in range(n)]\\nval_idx = sorted(val_idx, key=lambda x: x[0], reverse=True)\\nresult = [0 for i in range(n)]\\n\\nfinished = 0\\nteam = 1\\n\\nfor val, idx in val_idx:\\n    if finished == n:\\n        break\\n    \\n    if result[idx] != 0:\\n        continue\\n    \\n    result[idx] = team\\n    finished += 1\\n    left_k = k\\n    most_left = left[idx]\\n\\n    while left_k > 0 and most_left >= 0:\\n        result[most_left] = team\\n        finished += 1\\n        most_left = left[most_left]\\n        left_k -= 1\\n    \\n    right_k = k\\n    most_right = right[idx]\\n\\n    while right_k > 0 and most_right < n:\\n        result[most_right] = team\\n        finished += 1\\n        most_right = right[most_right]\\n        right_k -= 1\\n    \\n    if most_left >= 0:\\n        right[most_left] = most_right\\n    \\n    if most_right < n:\\n        left[most_right] = most_left\\n    \\n    if team == 1:\\n        team = 2\\n    else:\\n        team = 1\\n\\nprint(''.join([str(i) for i in result]))\\n\", \"class Node:\\n    def __init__(self, v, i):\\n        self.v = v\\n        self.i = i\\n        self.left = None\\n        self.right = None\\n\\nn, k = list(map(int, input().split()))\\nnums = list(map(int, input().split()))\\nnodes = [Node(v, i) for i, v in enumerate(nums)]\\nsort = [[v, i] for i, v in enumerate(nums)]\\nsort = sorted(sort, key = lambda x: [x[0], x[1]],reverse=True)\\nfor i in range(len(nodes)):\\n    if i < len(nodes) - 1:\\n        nodes[i].right = nodes[i + 1]\\n    if i > 0:\\n        nodes[i].left = nodes[i - 1]\\nans = [0] * n\\n\\nteam = 1\\nfor pair in sort:\\n    v, i = pair\\n\\n    # if nodes[i].left == None and nodes[i].right == None:\\n    #     continue\\n    if nodes[i].i == None:\\n        continue\\n    # print(v, i)\\n    ans[i] = team if team == 1 else 2\\n    cur = nodes[i].right\\n    right = None\\n    for j in range(k):\\n        if cur == None:\\n            break\\n        right = cur.right\\n        ans[cur.i] = team if team == 1 else 2\\n        cur.i = None\\n        cur = right\\n    cur = nodes[i].left\\n    # print(cur.i, cur.v)\\n    left = None\\n    for j in range(k):\\n        if cur == None:\\n            break\\n        left = cur.left\\n        ans[cur.i] = team if team == 1 else 2\\n        cur.i = None\\n        cur = left\\n    # if left == None and right == None:\\n    #     break\\n    if left:\\n        left.right = right\\n    if right:\\n        right.left = left\\n    team = team ^ 1\\n\\nprint(''.join([str(i) for i in ans]))\\n\", \"n, k = list(map(int,input().split()))\\nl = list(map(int,input().split()))\\nimport sys\\nfor i in range(n):\\n\\tl[i] -= 1\\ntaken = [0] * n\\nplace = [0] * n\\nnast = [i + 1 for i in range(n)]\\npoprz = [i - 1 for i in range(n)]\\nfor i in range(n):\\n\\tplace[l[i]] = i\\nbest =  n - 1\\nturn = 2\\nwhile True:\\n\\t#print(taken, poprz, nast)\\n\\t#print(best)\\n\\tturn =  3 - turn\\n\\tp = place[best]\\n\\tpp = p\\n\\t#print(pp)\\n\\ttaken[p] = turn\\n\\tfor i in range(k):\\n\\t\\tif nast[pp] < n:\\n\\t\\t\\tpp = nast[pp]\\n\\t\\t\\ttaken[pp] = turn\\n\\t\\telse:\\n\\t\\t\\tpp = n\\n\\t\\t\\tbreak\\n\\t#print('c')\\n\\tif pp < n:\\n\\t\\tright = nast[pp]\\n\\telse:\\n\\t\\tright = n\\n\\tpp = p\\n\\tfor i in range(k):\\n\\t\\tif poprz[pp] >= 0:\\n\\t\\t\\tpp = poprz[pp]\\n\\t\\t\\ttaken[pp] = turn\\n\\t\\telse:\\n\\t\\t\\tpp = -1\\n\\t\\t\\tbreak\\n\\tif pp >= 0:\\n\\t\\tleft = poprz[pp]\\n\\telse:\\n\\t\\tleft = -1\\n\\t#print(left,right)\\n\\t#print(\\\"c\\\")\\n\\tif left > -1:\\n\\t\\tnast[left] = right\\n\\tif right < n:\\n\\t\\tpoprz[right] = left\\n\\twhile True:\\n\\t\\tif best < 0:\\n\\t\\t\\tfor f in taken:\\n\\t\\t\\t\\tprint(f, end =\\\"\\\")\\n\\t\\t\\treturn\\n\\t\\tif taken[place[best]] != 0:\\n\\t\\t\\tbest -= 1\\n\\t\\telse:\\n\\t\\t\\tbreak\\n\\t\", \"n, k = map(int, input().split())\\nbin_ = list(map(int, input().split()))\\n\\nsorted_bin = []\\ncommand = [0] * n\\n\\nnext_ = [i for i in range(1, n)] + [-1]\\nprev_ = [-1] + [i for i in range(0, n-1)]\\n\\nfor elem in enumerate(bin_):\\n    sorted_bin.append(elem)\\n\\nsorted_bin.sort(key=lambda x: -x[1])\\n\\nflag = 0\\n\\nfor ind, value in sorted_bin:\\n    #print(command)\\n    if command[ind] != 0:\\n        continue\\n    command[ind] = flag + 1\\n    next_i = ind\\n    for _ in range(k):\\n        next_i = next_[next_i]\\n        if next_i != -1:\\n            command[next_i] = 1 + flag\\n        else:\\n            break\\n    \\n    prev_i = ind\\n    for _ in range(k):\\n        prev_i = prev_[prev_i]\\n        if prev_i != -1:\\n            command[prev_i] = 1 + flag\\n        else:\\n            break\\n    \\n    if prev_i != -1:\\n        prev_i = prev_[prev_i]\\n    if next_i != -1:\\n        next_i = next_[next_i]\\n    if prev_i != -1:\\n        next_[prev_i] = next_i\\n    if next_i != -1:\\n        prev_[next_i] = prev_i\\n    \\n    flag = 1 - flag\\n\\nfor i in command:\\n    print(i, end='')\", \"from heapq import heappop, heapify\\n\\n\\ndef get_max(l, r):\\n    return max(a[l: r + 1])\\n\\n\\nn, k = [int(item) for item in input().split()]\\na = [int(item) for item in input().split()]\\n\\ncoaches = [set(), set()]\\n\\ncoach = 0\\ntaken = 0\\n\\nl, r = 0, 0\\nstill_map = {0: n - 1}\\ndone_map_l = {}\\ndone_map_r = {}\\n\\nglobal_map = {}\\nfor i in range(n):\\n    global_map[a[i]] = i\\n\\ndone = [0] * (n + 1)\\nh = [-(i + 1) for i in range(n)]\\nheapify(h)\\n# print(a)\\nwhile taken < n:\\n    # max_index = -1\\n    # mx = -float(\\\"inf\\\")\\n    # mx_l = -1\\n    # for l in still_map:\\n    #     r = still_map[l]\\n    #     local_max = get_max(l, r)\\n    #     if local_max > mx:\\n    #         mx = local_max\\n    #         mx_l = l\\n    local_max = -heappop(h)\\n    while done[local_max]:\\n        local_max = -heappop(h)\\n\\n    max_index = global_map[local_max]\\n\\n    l_search, r_search = max_index - 1, max_index + 1\\n    l_count, r_count = 0, 0\\n    l_last = max_index\\n\\n    while l_search >= 0 and l_count < k:\\n        if l_search in done_map_r:\\n            new_l_search = done_map_r[l_search] - 1\\n            done_map_l[done_map_r[l_search]] = l_last\\n            done_map_r[l_last] = done_map_r[l_search]\\n\\n            l_search = new_l_search\\n        else:\\n            l_count += 1\\n            coaches[coach].add(l_search)\\n            done[a[l_search]] = 1\\n            taken += 1\\n            l_search -= 1\\n\\n    r_last = l_search + 1\\n    while r_search < n and r_count < k:\\n        if r_search in done_map_l:\\n            new_r_search = done_map_l[r_search] + 1\\n            done_map_r[done_map_l[r_search]] = r_last\\n            done_map_l[r_last] = done_map_l[r_search]\\n\\n            r_search = new_r_search\\n        else:\\n            r_count += 1\\n            coaches[coach].add(r_search)\\n            done[a[r_search]] = 1\\n            taken += 1\\n            r_search += 1\\n\\n    done[local_max] = 1\\n    coaches[coach].add(max_index)\\n    taken += 1\\n    coach ^= 1\\n    done_map_l[l_search + 1] = r_search - 1\\n    done_map_r[r_search - 1] = l_search + 1\\n    # print(done_map_l, done_map_r)\\n    # print(coaches, l_search, r_search)\\n\\n\\nprint(''.join('1' if i in coaches[0] else '2' for i in range(n)))\\n\", \"n, k = map(int, input().split())\\nls = list(map(int, input().split()))\\nres = {}\\navail = {}\\nleft = {}\\nright = {}\\nleft[0] = -1\\nfor i in range(1, n):\\n    left[i] = i-1\\nright[n-1] = -1\\nfor i in range(n-1):\\n    right[i] = i+1\\nfor i in range(n):\\n    avail[i] = True\\nls = [(ls[i], i) for i in range(n)]\\nls.sort(key=lambda x:x[0])\\nls.reverse()\\nturn = 1\\nfor i in range(n):\\n    if avail[ls[i][1]]==True:\\n        avail[ls[i][1]] = False\\n        cur = ls[i][1]\\n        res[cur] = turn\\n        if left[cur]!=-1:\\n            right[left[cur]] = right[cur]\\n        if right[cur]!=-1:\\n            left[right[cur]] = left[cur]\\n        for _ in range(k):\\n            cur = right[cur]\\n            if cur==-1: break\\n            avail[cur] = False\\n            res[cur] = turn\\n            if left[cur]!=-1:\\n                right[left[cur]] = right[cur]\\n            if right[cur]!=-1:\\n                left[right[cur]] = left[cur]\\n        cur = ls[i][1]\\n        for _ in range(k):\\n            cur = left[cur]\\n            if cur==-1: break\\n            avail[cur] = False\\n            res[cur] = turn\\n            if left[cur]!=-1:\\n                right[left[cur]] = right[cur]\\n            if right[cur]!=-1:\\n                left[right[cur]] = left[cur]\\n        if turn==1: turn = 2\\n        else: turn = 1\\nfor i in range(n):\\n    print(res[i], end='')\\n\", \"n, k = map(int, input().split())\\nA = list(map(int, input().split()))\\nA = [(a, i) for i, a in enumerate(A)]\\nA.sort(key=lambda x: x[0])\\nA.reverse()\\nleft = [-1] * n\\nfor i in range(1, n):\\n  left[i] = i - 1\\nright = [-1] * n\\nfor i in range(n - 1):\\n  right[i] = i + 1\\nvis = [0] * n\\njoin = [0] * n\\njo = 1\\nfor i in range(n):\\n  if not vis[A[i][1]]:\\n    cur = A[i][1]\\n    vis[cur] = 1\\n    join[cur] = jo\\n    if left[cur]!=-1:\\n      right[left[cur]] = right[cur]\\n    if right[cur]!=-1:\\n      left[right[cur]] = left[cur]\\n    # left\\n    for j in range(k):\\n      cur = left[cur]\\n      if cur == -1: break\\n      vis[cur] = 1\\n      join[cur] = jo\\n      if left[cur]!=-1:\\n        right[left[cur]] = right[cur]\\n      if right[cur]!=-1:\\n        left[right[cur]] = left[cur]\\n\\n    # right\\n    cur = A[i][1]\\n    for j in range(k):\\n      cur = right[cur]\\n      if cur == -1: break\\n      vis[cur] = 1\\n      join[cur] = jo\\n      if left[cur]!=-1:\\n        right[left[cur]] = right[cur]\\n      if right[cur]!=-1:\\n        left[right[cur]] = left[cur]\\n    jo = 1 if jo == 2 else 2\\nprint(*join, sep='')\\n\", \"class Node:\\n    def __init__(self, v, i):\\n        self.v = v\\n        self.i = i\\n        self.left = None\\n        self.right = None\\n\\nn, k = map(int, input().split())\\nnums = list(map(int, input().split()))\\nnodes = [Node(v, i) for i, v in enumerate(nums)]\\nsort = [[v, i] for i, v in enumerate(nums)]\\nsort = sorted(sort, key = lambda x: [x[0], x[1]],reverse=True)\\nfor i in range(len(nodes)):\\n    if i < len(nodes) - 1:\\n        nodes[i].right = nodes[i + 1]\\n    if i > 0:\\n        nodes[i].left = nodes[i - 1]\\nans = [0] * n\\n\\nteam = 1\\nfor pair in sort:\\n    v, i = pair\\n\\n    # if nodes[i].left == None and nodes[i].right == None:\\n    #     continue\\n    if nodes[i].i == None:\\n        continue\\n    # print(v, i)\\n    ans[i] = team if team == 1 else 2\\n    cur = nodes[i].right\\n    right = None\\n    for j in range(k):\\n        if cur == None:\\n            break\\n        right = cur.right\\n        ans[cur.i] = team if team == 1 else 2\\n        cur.i = None\\n        cur = right\\n    cur = nodes[i].left\\n    # print(cur.i, cur.v)\\n    left = None\\n    for j in range(k):\\n        if cur == None:\\n            break\\n        left = cur.left\\n        ans[cur.i] = team if team == 1 else 2\\n        cur.i = None\\n        cur = left\\n    # if left == None and right == None:\\n    #     break\\n    if left:\\n        left.right = right\\n    if right:\\n        right.left = left\\n    team = team ^ 1\\n\\nprint(''.join([str(i) for i in ans]))\", \"n,k=[int(x) for x in input().split()]\\nl1=[int(x)-1 for x in input().split()]\\nl2=[0 for x in range(0,n)]\\nl3=[0 for x in range(0,n)]\\nl4=[[] for x in range(0,n)]\\n#l3[i] gives index of i in input array\\n#l4[i][0] is prev untaken element\\n#l4[i][1] is forward untaken element\\n#l1 is input array\\n#l2[i] gives team of i\\nfor i in range(0,n):\\n    l4[i].append(i-1)\\n    l4[i].append(i+1)\\n#print(l4)\\nfor i in range(0,n):\\n    l3[l1[i]]=i\\ni=n-1\\nx=1\\nwhile(i>=0):\\n    t=l3[i]\\n    if(l2[t]!=0):\\n        i-=1\\n        continue\\n    else:\\n        l2[t]=x\\n        j=1\\n        m=l4[t][1]\\n        while(j<=k and m<n):\\n            if(l2[m]!=0): \\n                if(l4[m][1]>n-1):\\n                    break\\n                m=l4[m][1]\\n                continue\\n            l2[m]=x\\n            if(l4[m][1]>n-1):\\n                    break\\n            m=l4[m][1]\\n            j+=1\\n        a=m\\n        j=1\\n        m=l4[t][0]\\n        while(j<=k and m>-1):\\n            if(l2[m]!=0):\\n                if(l4[m][0]<0):\\n                    break\\n                m=l4[m][0]\\n                continue\\n            \\n            l2[m]=x\\n            if(l4[m][0]<0):\\n                    break\\n            m=l4[m][0]\\n            j+=1\\n        b=m\\n        if(a<n):\\n            l4[a][0]=b\\n        if(b>-1):\\n            l4[b][1]=a\\n            \\n    if(x==1):\\n        x=2\\n    else:\\n        x=1       \\n    i-=1\\nfor element in l2:\\n    print(element,end=\\\"\\\")\\n    \\n    \\n\", \"import sys\\n# from sortedcontainers import SortedList\\n# \\n\\nfrom bisect import bisect_left, bisect_right, insort\\nfrom itertools import chain, repeat, starmap\\nfrom math import log\\nfrom operator import add, eq, ne, gt, ge, lt, le, iadd\\nfrom textwrap import dedent\\ntry:\\n    from collections.abc import Sequence, MutableSequence\\nexcept ImportError:\\n    from collections import Sequence, MutableSequence\\n\\nfrom functools import wraps\\nfrom sys import hexversion\\n\\nif hexversion < 0x03000000:\\n      # pylint: disable=redefined-builtin\\n      # pylint: disable=redefined-builtin\\n    try:\\n        from _thread import get_ident\\n    except ImportError:\\n        from _dummy_thread import get_ident\\nelse:\\n    from functools import reduce\\n    try:\\n        from _thread import get_ident\\n    except ImportError:\\n        from _dummy_thread import get_ident\\n\\n\\ndef recursive_repr(fillvalue='...'):\\n    \\\"Decorator to make a repr function return fillvalue for a recursive call.\\\"\\n    # pylint: disable=missing-docstring\\n    # Copied from reprlib in Python 3\\n    # https://hg.python.org/cpython/file/3.6/Lib/reprlib.py\\n\\n    def decorating_function(user_function):\\n        repr_running = set()\\n\\n        @wraps(user_function)\\n        def wrapper(self):\\n            key = id(self), get_ident()\\n            if key in repr_running:\\n                return fillvalue\\n            repr_running.add(key)\\n            try:\\n                result = user_function(self)\\n            finally:\\n                repr_running.discard(key)\\n            return result\\n\\n        return wrapper\\n\\n    return decorating_function\\n\\n\\nclass SortedList(MutableSequence):\\n    \\\"\\\"\\\"Sorted list is a sorted mutable sequence.\\n\\n    Sorted list values are maintained in sorted order.\\n\\n    Sorted list values must be comparable. The total ordering of values must\\n    not change while they are stored in the sorted list.\\n\\n    Methods for adding values:\\n\\n    * :func:`SortedList.add`\\n    * :func:`SortedList.update`\\n    * :func:`SortedList.__add__`\\n    * :func:`SortedList.__iadd__`\\n    * :func:`SortedList.__mul__`\\n    * :func:`SortedList.__imul__`\\n\\n    Methods for removing values:\\n\\n    * :func:`SortedList.clear`\\n    * :func:`SortedList.discard`\\n    * :func:`SortedList.remove`\\n    * :func:`SortedList.pop`\\n    * :func:`SortedList.__delitem__`\\n\\n    Methods for looking up values:\\n\\n    * :func:`SortedList.bisect_left`\\n    * :func:`SortedList.bisect_right`\\n    * :func:`SortedList.count`\\n    * :func:`SortedList.index`\\n    * :func:`SortedList.__contains__`\\n    * :func:`SortedList.__getitem__`\\n\\n    Methods for iterating values:\\n\\n    * :func:`SortedList.irange`\\n    * :func:`SortedList.islice`\\n    * :func:`SortedList.__iter__`\\n    * :func:`SortedList.__reversed__`\\n\\n    Methods for miscellany:\\n\\n    * :func:`SortedList.copy`\\n    * :func:`SortedList.__len__`\\n    * :func:`SortedList.__repr__`\\n    * :func:`SortedList._check`\\n    * :func:`SortedList._reset`\\n\\n    Sorted lists use lexicographical ordering semantics when compared to other\\n    sequences.\\n\\n    Some methods of mutable sequences are not supported and will raise\\n    not-implemented error.\\n\\n    \\\"\\\"\\\"\\n    DEFAULT_LOAD_FACTOR = 1000\\n\\n\\n    def __init__(self, iterable=None, key=None):\\n        \\\"\\\"\\\"Initialize sorted list instance.\\n\\n        Optional `iterable` argument provides an initial iterable of values to\\n        initialize the sorted list.\\n\\n        Runtime complexity: `O(n*log(n))`\\n\\n        >>> sl = SortedList()\\n        >>> sl\\n        SortedList([])\\n        >>> sl = SortedList([3, 1, 2, 5, 4])\\n        >>> sl\\n        SortedList([1, 2, 3, 4, 5])\\n\\n        :param iterable: initial values (optional)\\n\\n        \\\"\\\"\\\"\\n        assert key is None\\n        self._len = 0\\n        self._load = self.DEFAULT_LOAD_FACTOR\\n        self._lists = []\\n        self._maxes = []\\n        self._index = []\\n        self._offset = 0\\n\\n        if iterable is not None:\\n            self._update(iterable)\\n\\n\\n    def __new__(cls, iterable=None, key=None):\\n        \\\"\\\"\\\"Create new sorted list or sorted-key list instance.\\n\\n        Optional `key`-function argument will return an instance of subtype\\n        :class:`SortedKeyList`.\\n\\n        >>> sl = SortedList()\\n        >>> isinstance(sl, SortedList)\\n        True\\n        >>> sl = SortedList(key=lambda x: -x)\\n        >>> isinstance(sl, SortedList)\\n        True\\n        >>> isinstance(sl, SortedKeyList)\\n        True\\n\\n        :param iterable: initial values (optional)\\n        :param key: function used to extract comparison key (optional)\\n        :return: sorted list or sorted-key list instance\\n\\n        \\\"\\\"\\\"\\n        # pylint: disable=unused-argument\\n        if key is None:\\n            return object.__new__(cls)\\n        else:\\n            if cls is SortedList:\\n                return object.__new__(SortedKeyList)\\n            else:\\n                raise TypeError('inherit SortedKeyList for key argument')\\n\\n\\n    @property\\n    def key(self):  # pylint: disable=useless-return\\n        \\\"\\\"\\\"Function used to extract comparison key from values.\\n\\n        Sorted list compares values directly so the key function is none.\\n\\n        \\\"\\\"\\\"\\n        return None\\n\\n\\n    def _reset(self, load):\\n        \\\"\\\"\\\"Reset sorted list load factor.\\n\\n        The `load` specifies the load-factor of the list. The default load\\n        factor of 1000 works well for lists from tens to tens-of-millions of\\n        values. Good practice is to use a value that is the cube root of the\\n        list size. With billions of elements, the best load factor depends on\\n        your usage. It's best to leave the load factor at the default until you\\n        start benchmarking.\\n\\n        See :doc:`implementation` and :doc:`performance-scale` for more\\n        information.\\n\\n        Runtime complexity: `O(n)`\\n\\n        :param int load: load-factor for sorted list sublists\\n\\n        \\\"\\\"\\\"\\n        values = reduce(iadd, self._lists, [])\\n        self._clear()\\n        self._load = load\\n        self._update(values)\\n\\n\\n    def clear(self):\\n        \\\"\\\"\\\"Remove all values from sorted list.\\n\\n        Runtime complexity: `O(n)`\\n\\n        \\\"\\\"\\\"\\n        self._len = 0\\n        del self._lists[:]\\n        del self._maxes[:]\\n        del self._index[:]\\n        self._offset = 0\\n\\n    _clear = clear\\n\\n\\n    def add(self, value):\\n        \\\"\\\"\\\"Add `value` to sorted list.\\n\\n        Runtime complexity: `O(log(n))` -- approximate.\\n\\n        >>> sl = SortedList()\\n        >>> sl.add(3)\\n        >>> sl.add(1)\\n        >>> sl.add(2)\\n        >>> sl\\n        SortedList([1, 2, 3])\\n\\n        :param value: value to add to sorted list\\n\\n        \\\"\\\"\\\"\\n        _lists = self._lists\\n        _maxes = self._maxes\\n\\n        if _maxes:\\n            pos = bisect_right(_maxes, value)\\n\\n            if pos == len(_maxes):\\n                pos -= 1\\n                _lists[pos].append(value)\\n                _maxes[pos] = value\\n            else:\\n                insort(_lists[pos], value)\\n\\n            self._expand(pos)\\n        else:\\n            _lists.append([value])\\n            _maxes.append(value)\\n\\n        self._len += 1\\n\\n\\n    def _expand(self, pos):\\n        \\\"\\\"\\\"Split sublists with length greater than double the load-factor.\\n\\n        Updates the index when the sublist length is less than double the load\\n        level. This requires incrementing the nodes in a traversal from the\\n        leaf node to the root. For an example traversal see\\n        ``SortedList._loc``.\\n\\n        \\\"\\\"\\\"\\n        _load = self._load\\n        _lists = self._lists\\n        _index = self._index\\n\\n        if len(_lists[pos]) > (_load << 1):\\n            _maxes = self._maxes\\n\\n            _lists_pos = _lists[pos]\\n            half = _lists_pos[_load:]\\n            del _lists_pos[_load:]\\n            _maxes[pos] = _lists_pos[-1]\\n\\n            _lists.insert(pos + 1, half)\\n            _maxes.insert(pos + 1, half[-1])\\n\\n            del _index[:]\\n        else:\\n            if _index:\\n                child = self._offset + pos\\n                while child:\\n                    _index[child] += 1\\n                    child = (child - 1) >> 1\\n                _index[0] += 1\\n\\n\\n    def update(self, iterable):\\n        \\\"\\\"\\\"Update sorted list by adding all values from `iterable`.\\n\\n        Runtime complexity: `O(k*log(n))` -- approximate.\\n\\n        >>> sl = SortedList()\\n        >>> sl.update([3, 1, 2])\\n        >>> sl\\n        SortedList([1, 2, 3])\\n\\n        :param iterable: iterable of values to add\\n\\n        \\\"\\\"\\\"\\n        _lists = self._lists\\n        _maxes = self._maxes\\n        values = sorted(iterable)\\n\\n        if _maxes:\\n            if len(values) * 4 >= self._len:\\n                values.extend(chain.from_iterable(_lists))\\n                values.sort()\\n                self._clear()\\n            else:\\n                _add = self.add\\n                for val in values:\\n                    _add(val)\\n                return\\n\\n        _load = self._load\\n        _lists.extend(values[pos:(pos + _load)]\\n                      for pos in range(0, len(values), _load))\\n        _maxes.extend(sublist[-1] for sublist in _lists)\\n        self._len = len(values)\\n        del self._index[:]\\n\\n    _update = update\\n\\n\\n    def __contains__(self, value):\\n        \\\"\\\"\\\"Return true if `value` is an element of the sorted list.\\n\\n        ``sl.__contains__(value)`` <==> ``value in sl``\\n\\n        Runtime complexity: `O(log(n))`\\n\\n        >>> sl = SortedList([1, 2, 3, 4, 5])\\n        >>> 3 in sl\\n        True\\n\\n        :param value: search for value in sorted list\\n        :return: true if `value` in sorted list\\n\\n        \\\"\\\"\\\"\\n        _maxes = self._maxes\\n\\n        if not _maxes:\\n            return False\\n\\n        pos = bisect_left(_maxes, value)\\n\\n        if pos == len(_maxes):\\n            return False\\n\\n        _lists = self._lists\\n        idx = bisect_left(_lists[pos], value)\\n\\n        return _lists[pos][idx] == value\\n\\n\\n    def discard(self, value):\\n        \\\"\\\"\\\"Remove `value` from sorted list if it is a member.\\n\\n        If `value` is not a member, do nothing.\\n\\n        Runtime complexity: `O(log(n))` -- approximate.\\n\\n        >>> sl = SortedList([1, 2, 3, 4, 5])\\n        >>> sl.discard(5)\\n        >>> sl.discard(0)\\n        >>> sl == [1, 2, 3, 4]\\n        True\\n\\n        :param value: `value` to discard from sorted list\\n\\n        \\\"\\\"\\\"\\n        _maxes = self._maxes\\n\\n        if not _maxes:\\n            return\\n\\n        pos = bisect_left(_maxes, value)\\n\\n        if pos == len(_maxes):\\n            return\\n\\n        _lists = self._lists\\n        idx = bisect_left(_lists[pos], value)\\n\\n        if _lists[pos][idx] == value:\\n            self._delete(pos, idx)\\n\\n\\n    def remove(self, value):\\n        \\\"\\\"\\\"Remove `value` from sorted list; `value` must be a member.\\n\\n        If `value` is not a member, raise ValueError.\\n\\n        Runtime complexity: `O(log(n))` -- approximate.\\n\\n        >>> sl = SortedList([1, 2, 3, 4, 5])\\n        >>> sl.remove(5)\\n        >>> sl == [1, 2, 3, 4]\\n        True\\n        >>> sl.remove(0)\\n        Traceback (most recent call last):\\n          ...\\n        ValueError: 0 not in list\\n\\n        :param value: `value` to remove from sorted list\\n        :raises ValueError: if `value` is not in sorted list\\n\\n        \\\"\\\"\\\"\\n        _maxes = self._maxes\\n\\n        if not _maxes:\\n            raise ValueError('{0!r} not in list'.format(value))\\n\\n        pos = bisect_left(_maxes, value)\\n\\n        if pos == len(_maxes):\\n            raise ValueError('{0!r} not in list'.format(value))\\n\\n        _lists = self._lists\\n        idx = bisect_left(_lists[pos], value)\\n\\n        if _lists[pos][idx] == value:\\n            self._delete(pos, idx)\\n        else:\\n            raise ValueError('{0!r} not in list'.format(value))\\n\\n\\n    def _delete(self, pos, idx):\\n        \\\"\\\"\\\"Delete value at the given `(pos, idx)`.\\n\\n        Combines lists that are less than half the load level.\\n\\n        Updates the index when the sublist length is more than half the load\\n        level. This requires decrementing the nodes in a traversal from the\\n        leaf node to the root. For an example traversal see\\n        ``SortedList._loc``.\\n\\n        :param int pos: lists index\\n        :param int idx: sublist index\\n\\n        \\\"\\\"\\\"\\n        _lists = self._lists\\n        _maxes = self._maxes\\n        _index = self._index\\n\\n        _lists_pos = _lists[pos]\\n\\n        del _lists_pos[idx]\\n        self._len -= 1\\n\\n        len_lists_pos = len(_lists_pos)\\n\\n        if len_lists_pos > (self._load >> 1):\\n            _maxes[pos] = _lists_pos[-1]\\n\\n            if _index:\\n                child = self._offset + pos\\n                while child > 0:\\n                    _index[child] -= 1\\n                    child = (child - 1) >> 1\\n                _index[0] -= 1\\n        elif len(_lists) > 1:\\n            if not pos:\\n                pos += 1\\n\\n            prev = pos - 1\\n            _lists[prev].extend(_lists[pos])\\n            _maxes[prev] = _lists[prev][-1]\\n\\n            del _lists[pos]\\n            del _maxes[pos]\\n            del _index[:]\\n\\n            self._expand(prev)\\n        elif len_lists_pos:\\n            _maxes[pos] = _lists_pos[-1]\\n        else:\\n            del _lists[pos]\\n            del _maxes[pos]\\n            del _index[:]\\n\\n\\n    def _loc(self, pos, idx):\\n        \\\"\\\"\\\"Convert an index pair (lists index, sublist index) into a single\\n        index number that corresponds to the position of the value in the\\n        sorted list.\\n\\n        Many queries require the index be built. Details of the index are\\n        described in ``SortedList._build_index``.\\n\\n        Indexing requires traversing the tree from a leaf node to the root. The\\n        parent of each node is easily computable at ``(pos - 1) // 2``.\\n\\n        Left-child nodes are always at odd indices and right-child nodes are\\n        always at even indices.\\n\\n        When traversing up from a right-child node, increment the total by the\\n        left-child node.\\n\\n        The final index is the sum from traversal and the index in the sublist.\\n\\n        For example, using the index from ``SortedList._build_index``::\\n\\n            _index = 14 5 9 3 2 4 5\\n            _offset = 3\\n\\n        Tree::\\n\\n                 14\\n              5      9\\n            3   2  4   5\\n\\n        Converting an index pair (2, 3) into a single index involves iterating\\n        like so:\\n\\n        1. Starting at the leaf node: offset + alpha = 3 + 2 = 5. We identify\\n           the node as a left-child node. At such nodes, we simply traverse to\\n           the parent.\\n\\n        2. At node 9, position 2, we recognize the node as a right-child node\\n           and accumulate the left-child in our total. Total is now 5 and we\\n           traverse to the parent at position 0.\\n\\n        3. Iteration ends at the root.\\n\\n        The index is then the sum of the total and sublist index: 5 + 3 = 8.\\n\\n        :param int pos: lists index\\n        :param int idx: sublist index\\n        :return: index in sorted list\\n\\n        \\\"\\\"\\\"\\n        if not pos:\\n            return idx\\n\\n        _index = self._index\\n\\n        if not _index:\\n            self._build_index()\\n\\n        total = 0\\n\\n        # Increment pos to point in the index to len(self._lists[pos]).\\n\\n        pos += self._offset\\n\\n        # Iterate until reaching the root of the index tree at pos = 0.\\n\\n        while pos:\\n\\n            # Right-child nodes are at odd indices. At such indices\\n            # account the total below the left child node.\\n\\n            if not pos & 1:\\n                total += _index[pos - 1]\\n\\n            # Advance pos to the parent node.\\n\\n            pos = (pos - 1) >> 1\\n\\n        return total + idx\\n\\n\\n    def _pos(self, idx):\\n        \\\"\\\"\\\"Convert an index into an index pair (lists index, sublist index)\\n        that can be used to access the corresponding lists position.\\n\\n        Many queries require the index be built. Details of the index are\\n        described in ``SortedList._build_index``.\\n\\n        Indexing requires traversing the tree to a leaf node. Each node has two\\n        children which are easily computable. Given an index, pos, the\\n        left-child is at ``pos * 2 + 1`` and the right-child is at ``pos * 2 +\\n        2``.\\n\\n        When the index is less than the left-child, traversal moves to the\\n        left sub-tree. Otherwise, the index is decremented by the left-child\\n        and traversal moves to the right sub-tree.\\n\\n        At a child node, the indexing pair is computed from the relative\\n        position of the child node as compared with the offset and the remaining\\n        index.\\n\\n        For example, using the index from ``SortedList._build_index``::\\n\\n            _index = 14 5 9 3 2 4 5\\n            _offset = 3\\n\\n        Tree::\\n\\n                 14\\n              5      9\\n            3   2  4   5\\n\\n        Indexing position 8 involves iterating like so:\\n\\n        1. Starting at the root, position 0, 8 is compared with the left-child\\n           node (5) which it is greater than. When greater the index is\\n           decremented and the position is updated to the right child node.\\n\\n        2. At node 9 with index 3, we again compare the index to the left-child\\n           node with value 4. Because the index is the less than the left-child\\n           node, we simply traverse to the left.\\n\\n        3. At node 4 with index 3, we recognize that we are at a leaf node and\\n           stop iterating.\\n\\n        4. To compute the sublist index, we subtract the offset from the index\\n           of the leaf node: 5 - 3 = 2. To compute the index in the sublist, we\\n           simply use the index remaining from iteration. In this case, 3.\\n\\n        The final index pair from our example is (2, 3) which corresponds to\\n        index 8 in the sorted list.\\n\\n        :param int idx: index in sorted list\\n        :return: (lists index, sublist index) pair\\n\\n        \\\"\\\"\\\"\\n        if idx < 0:\\n            last_len = len(self._lists[-1])\\n\\n            if (-idx) <= last_len:\\n                return len(self._lists) - 1, last_len + idx\\n\\n            idx += self._len\\n\\n            if idx < 0:\\n                raise IndexError('list index out of range')\\n        elif idx >= self._len:\\n            raise IndexError('list index out of range')\\n\\n        if idx < len(self._lists[0]):\\n            return 0, idx\\n\\n        _index = self._index\\n\\n        if not _index:\\n            self._build_index()\\n\\n        pos = 0\\n        child = 1\\n        len_index = len(_index)\\n\\n        while child < len_index:\\n            index_child = _index[child]\\n\\n            if idx < index_child:\\n                pos = child\\n            else:\\n                idx -= index_child\\n                pos = child + 1\\n\\n            child = (pos << 1) + 1\\n\\n        return (pos - self._offset, idx)\\n\\n\\n    def _build_index(self):\\n        \\\"\\\"\\\"Build a positional index for indexing the sorted list.\\n\\n        Indexes are represented as binary trees in a dense array notation\\n        similar to a binary heap.\\n\\n        For example, given a lists representation storing integers::\\n\\n            0: [1, 2, 3]\\n            1: [4, 5]\\n            2: [6, 7, 8, 9]\\n            3: [10, 11, 12, 13, 14]\\n\\n        The first transformation maps the sub-lists by their length. The\\n        first row of the index is the length of the sub-lists::\\n\\n            0: [3, 2, 4, 5]\\n\\n        Each row after that is the sum of consecutive pairs of the previous\\n        row::\\n\\n            1: [5, 9]\\n            2: [14]\\n\\n        Finally, the index is built by concatenating these lists together::\\n\\n            _index = [14, 5, 9, 3, 2, 4, 5]\\n\\n        An offset storing the start of the first row is also stored::\\n\\n            _offset = 3\\n\\n        When built, the index can be used for efficient indexing into the list.\\n        See the comment and notes on ``SortedList._pos`` for details.\\n\\n        \\\"\\\"\\\"\\n        row0 = list(map(len, self._lists))\\n\\n        if len(row0) == 1:\\n            self._index[:] = row0\\n            self._offset = 0\\n            return\\n\\n        head = iter(row0)\\n        tail = iter(head)\\n        row1 = list(starmap(add, list(zip(head, tail))))\\n\\n        if len(row0) & 1:\\n            row1.append(row0[-1])\\n\\n        if len(row1) == 1:\\n            self._index[:] = row1 + row0\\n            self._offset = 1\\n            return\\n\\n        size = 2 ** (int(log(len(row1) - 1, 2)) + 1)\\n        row1.extend(repeat(0, size - len(row1)))\\n        tree = [row0, row1]\\n\\n        while len(tree[-1]) > 1:\\n            head = iter(tree[-1])\\n            tail = iter(head)\\n            row = list(starmap(add, list(zip(head, tail))))\\n            tree.append(row)\\n\\n        reduce(iadd, reversed(tree), self._index)\\n        self._offset = size * 2 - 1\\n\\n\\n    def __delitem__(self, index):\\n        \\\"\\\"\\\"Remove value at `index` from sorted list.\\n\\n        ``sl.__delitem__(index)`` <==> ``del sl[index]``\\n\\n        Supports slicing.\\n\\n        Runtime complexity: `O(log(n))` -- approximate.\\n\\n        >>> sl = SortedList('abcde')\\n        >>> del sl[2]\\n        >>> sl\\n        SortedList(['a', 'b', 'd', 'e'])\\n        >>> del sl[:2]\\n        >>> sl\\n        SortedList(['d', 'e'])\\n\\n        :param index: integer or slice for indexing\\n        :raises IndexError: if index out of range\\n\\n        \\\"\\\"\\\"\\n        if isinstance(index, slice):\\n            start, stop, step = index.indices(self._len)\\n\\n            if step == 1 and start < stop:\\n                if start == 0 and stop == self._len:\\n                    return self._clear()\\n                elif self._len <= 8 * (stop - start):\\n                    values = self._getitem(slice(None, start))\\n                    if stop < self._len:\\n                        values += self._getitem(slice(stop, None))\\n                    self._clear()\\n                    return self._update(values)\\n\\n            indices = list(range(start, stop, step))\\n\\n            # Delete items from greatest index to least so\\n            # that the indices remain valid throughout iteration.\\n\\n            if step > 0:\\n                indices = reversed(indices)\\n\\n            _pos, _delete = self._pos, self._delete\\n\\n            for index in indices:\\n                pos, idx = _pos(index)\\n                _delete(pos, idx)\\n        else:\\n            pos, idx = self._pos(index)\\n            self._delete(pos, idx)\\n\\n\\n    def __getitem__(self, index):\\n        \\\"\\\"\\\"Lookup value at `index` in sorted list.\\n\\n        ``sl.__getitem__(index)`` <==> ``sl[index]``\\n\\n        Supports slicing.\\n\\n        Runtime complexity: `O(log(n))` -- approximate.\\n\\n        >>> sl = SortedList('abcde')\\n        >>> sl[1]\\n        'b'\\n        >>> sl[-1]\\n        'e'\\n        >>> sl[2:5]\\n        ['c', 'd', 'e']\\n\\n        :param index: integer or slice for indexing\\n        :return: value or list of values\\n        :raises IndexError: if index out of range\\n\\n        \\\"\\\"\\\"\\n        _lists = self._lists\\n\\n        if isinstance(index, slice):\\n            start, stop, step = index.indices(self._len)\\n\\n            if step == 1 and start < stop:\\n                if start == 0 and stop == self._len:\\n                    return reduce(iadd, self._lists, [])\\n\\n                start_pos, start_idx = self._pos(start)\\n\\n                if stop == self._len:\\n                    stop_pos = len(_lists) - 1\\n                    stop_idx = len(_lists[stop_pos])\\n                else:\\n                    stop_pos, stop_idx = self._pos(stop)\\n\\n                if start_pos == stop_pos:\\n                    return _lists[start_pos][start_idx:stop_idx]\\n\\n                prefix = _lists[start_pos][start_idx:]\\n                middle = _lists[(start_pos + 1):stop_pos]\\n                result = reduce(iadd, middle, prefix)\\n                result += _lists[stop_pos][:stop_idx]\\n\\n                return result\\n\\n            if step == -1 and start > stop:\\n                result = self._getitem(slice(stop + 1, start + 1))\\n                result.reverse()\\n                return result\\n\\n            # Return a list because a negative step could\\n            # reverse the order of the items and this could\\n            # be the desired behavior.\\n\\n            indices = list(range(start, stop, step))\\n            return list(self._getitem(index) for index in indices)\\n        else:\\n            if self._len:\\n                if index == 0:\\n                    return _lists[0][0]\\n                elif index == -1:\\n                    return _lists[-1][-1]\\n            else:\\n                raise IndexError('list index out of range')\\n\\n            if 0 <= index < len(_lists[0]):\\n                return _lists[0][index]\\n\\n            len_last = len(_lists[-1])\\n\\n            if -len_last < index < 0:\\n                return _lists[-1][len_last + index]\\n\\n            pos, idx = self._pos(index)\\n            return _lists[pos][idx]\\n\\n    _getitem = __getitem__\\n\\n\\n    def __setitem__(self, index, value):\\n        \\\"\\\"\\\"Raise not-implemented error.\\n\\n        ``sl.__setitem__(index, value)`` <==> ``sl[index] = value``\\n\\n        :raises NotImplementedError: use ``del sl[index]`` and\\n            ``sl.add(value)`` instead\\n\\n        \\\"\\\"\\\"\\n        message = 'use ``del sl[index]`` and ``sl.add(value)`` instead'\\n        raise NotImplementedError(message)\\n\\n\\n    def __iter__(self):\\n        \\\"\\\"\\\"Return an iterator over the sorted list.\\n\\n        ``sl.__iter__()`` <==> ``iter(sl)``\\n\\n        Iterating the sorted list while adding or deleting values may raise a\\n        :exc:`RuntimeError` or fail to iterate over all values.\\n\\n        \\\"\\\"\\\"\\n        return chain.from_iterable(self._lists)\\n\\n\\n    def __reversed__(self):\\n        \\\"\\\"\\\"Return a reverse iterator over the sorted list.\\n\\n        ``sl.__reversed__()`` <==> ``reversed(sl)``\\n\\n        Iterating the sorted list while adding or deleting values may raise a\\n        :exc:`RuntimeError` or fail to iterate over all values.\\n\\n        \\\"\\\"\\\"\\n        return chain.from_iterable(list(map(reversed, reversed(self._lists))))\\n\\n\\n    def reverse(self):\\n        \\\"\\\"\\\"Raise not-implemented error.\\n\\n        Sorted list maintains values in ascending sort order. Values may not be\\n        reversed in-place.\\n\\n        Use ``reversed(sl)`` for an iterator over values in descending sort\\n        order.\\n\\n        Implemented to override `MutableSequence.reverse` which provides an\\n        erroneous default implementation.\\n\\n        :raises NotImplementedError: use ``reversed(sl)`` instead\\n\\n        \\\"\\\"\\\"\\n        raise NotImplementedError('use ``reversed(sl)`` instead')\\n\\n\\n    def islice(self, start=None, stop=None, reverse=False):\\n        \\\"\\\"\\\"Return an iterator that slices sorted list from `start` to `stop`.\\n\\n        The `start` and `stop` index are treated inclusive and exclusive,\\n        respectively.\\n\\n        Both `start` and `stop` default to `None` which is automatically\\n        inclusive of the beginning and end of the sorted list.\\n\\n        When `reverse` is `True` the values are yielded from the iterator in\\n        reverse order; `reverse` defaults to `False`.\\n\\n        >>> sl = SortedList('abcdefghij')\\n        >>> it = sl.islice(2, 6)\\n        >>> list(it)\\n        ['c', 'd', 'e', 'f']\\n\\n        :param int start: start index (inclusive)\\n        :param int stop: stop index (exclusive)\\n        :param bool reverse: yield values in reverse order\\n        :return: iterator\\n\\n        \\\"\\\"\\\"\\n        _len = self._len\\n\\n        if not _len:\\n            return iter(())\\n\\n        start, stop, _ = slice(start, stop).indices(self._len)\\n\\n        if start >= stop:\\n            return iter(())\\n\\n        _pos = self._pos\\n\\n        min_pos, min_idx = _pos(start)\\n\\n        if stop == _len:\\n            max_pos = len(self._lists) - 1\\n            max_idx = len(self._lists[-1])\\n        else:\\n            max_pos, max_idx = _pos(stop)\\n\\n        return self._islice(min_pos, min_idx, max_pos, max_idx, reverse)\\n\\n\\n    def _islice(self, min_pos, min_idx, max_pos, max_idx, reverse):\\n        \\\"\\\"\\\"Return an iterator that slices sorted list using two index pairs.\\n\\n        The index pairs are (min_pos, min_idx) and (max_pos, max_idx), the\\n        first inclusive and the latter exclusive. See `_pos` for details on how\\n        an index is converted to an index pair.\\n\\n        When `reverse` is `True`, values are yielded from the iterator in\\n        reverse order.\\n\\n        \\\"\\\"\\\"\\n        _lists = self._lists\\n\\n        if min_pos > max_pos:\\n            return iter(())\\n\\n        if min_pos == max_pos:\\n            if reverse:\\n                indices = reversed(list(range(min_idx, max_idx)))\\n                return list(map(_lists[min_pos].__getitem__, indices))\\n\\n            indices = list(range(min_idx, max_idx))\\n            return list(map(_lists[min_pos].__getitem__, indices))\\n\\n        next_pos = min_pos + 1\\n\\n        if next_pos == max_pos:\\n            if reverse:\\n                min_indices = list(range(min_idx, len(_lists[min_pos])))\\n                max_indices = list(range(max_idx))\\n                return chain(\\n                    list(map(_lists[max_pos].__getitem__, reversed(max_indices))),\\n                    list(map(_lists[min_pos].__getitem__, reversed(min_indices))),\\n                )\\n\\n            min_indices = list(range(min_idx, len(_lists[min_pos])))\\n            max_indices = list(range(max_idx))\\n            return chain(\\n                list(map(_lists[min_pos].__getitem__, min_indices)),\\n                list(map(_lists[max_pos].__getitem__, max_indices)),\\n            )\\n\\n        if reverse:\\n            min_indices = list(range(min_idx, len(_lists[min_pos])))\\n            sublist_indices = list(range(next_pos, max_pos))\\n            sublists = list(map(_lists.__getitem__, reversed(sublist_indices)))\\n            max_indices = list(range(max_idx))\\n            return chain(\\n                list(map(_lists[max_pos].__getitem__, reversed(max_indices))),\\n                chain.from_iterable(list(map(reversed, sublists))),\\n                list(map(_lists[min_pos].__getitem__, reversed(min_indices))),\\n            )\\n\\n        min_indices = list(range(min_idx, len(_lists[min_pos])))\\n        sublist_indices = list(range(next_pos, max_pos))\\n        sublists = list(map(_lists.__getitem__, sublist_indices))\\n        max_indices = list(range(max_idx))\\n        return chain(\\n            list(map(_lists[min_pos].__getitem__, min_indices)),\\n            chain.from_iterable(sublists),\\n            list(map(_lists[max_pos].__getitem__, max_indices)),\\n        )\\n\\n\\n    def irange(self, minimum=None, maximum=None, inclusive=(True, True),\\n               reverse=False):\\n        \\\"\\\"\\\"Create an iterator of values between `minimum` and `maximum`.\\n\\n        Both `minimum` and `maximum` default to `None` which is automatically\\n        inclusive of the beginning and end of the sorted list.\\n\\n        The argument `inclusive` is a pair of booleans that indicates whether\\n        the minimum and maximum ought to be included in the range,\\n        respectively. The default is ``(True, True)`` such that the range is\\n        inclusive of both minimum and maximum.\\n\\n        When `reverse` is `True` the values are yielded from the iterator in\\n        reverse order; `reverse` defaults to `False`.\\n\\n        >>> sl = SortedList('abcdefghij')\\n        >>> it = sl.irange('c', 'f')\\n        >>> list(it)\\n        ['c', 'd', 'e', 'f']\\n\\n        :param minimum: minimum value to start iterating\\n        :param maximum: maximum value to stop iterating\\n        :param inclusive: pair of booleans\\n        :param bool reverse: yield values in reverse order\\n        :return: iterator\\n\\n        \\\"\\\"\\\"\\n        _maxes = self._maxes\\n\\n        if not _maxes:\\n            return iter(())\\n\\n        _lists = self._lists\\n\\n        # Calculate the minimum (pos, idx) pair. By default this location\\n        # will be inclusive in our calculation.\\n\\n        if minimum is None:\\n            min_pos = 0\\n            min_idx = 0\\n        else:\\n            if inclusive[0]:\\n                min_pos = bisect_left(_maxes, minimum)\\n\\n                if min_pos == len(_maxes):\\n                    return iter(())\\n\\n                min_idx = bisect_left(_lists[min_pos], minimum)\\n            else:\\n                min_pos = bisect_right(_maxes, minimum)\\n\\n                if min_pos == len(_maxes):\\n                    return iter(())\\n\\n                min_idx = bisect_right(_lists[min_pos], minimum)\\n\\n        # Calculate the maximum (pos, idx) pair. By default this location\\n        # will be exclusive in our calculation.\\n\\n        if maximum is None:\\n            max_pos = len(_maxes) - 1\\n            max_idx = len(_lists[max_pos])\\n        else:\\n            if inclusive[1]:\\n                max_pos = bisect_right(_maxes, maximum)\\n\\n                if max_pos == len(_maxes):\\n                    max_pos -= 1\\n                    max_idx = len(_lists[max_pos])\\n                else:\\n                    max_idx = bisect_right(_lists[max_pos], maximum)\\n            else:\\n                max_pos = bisect_left(_maxes, maximum)\\n\\n                if max_pos == len(_maxes):\\n                    max_pos -= 1\\n                    max_idx = len(_lists[max_pos])\\n                else:\\n                    max_idx = bisect_left(_lists[max_pos], maximum)\\n\\n        return self._islice(min_pos, min_idx, max_pos, max_idx, reverse)\\n\\n\\n    def __len__(self):\\n        \\\"\\\"\\\"Return the size of the sorted list.\\n\\n        ``sl.__len__()`` <==> ``len(sl)``\\n\\n        :return: size of sorted list\\n\\n        \\\"\\\"\\\"\\n        return self._len\\n\\n\\n    def bisect_left(self, value):\\n        \\\"\\\"\\\"Return an index to insert `value` in the sorted list.\\n\\n        If the `value` is already present, the insertion point will be before\\n        (to the left of) any existing values.\\n\\n        Similar to the `bisect` module in the standard library.\\n\\n        Runtime complexity: `O(log(n))` -- approximate.\\n\\n        >>> sl = SortedList([10, 11, 12, 13, 14])\\n        >>> sl.bisect_left(12)\\n        2\\n\\n        :param value: insertion index of value in sorted list\\n        :return: index\\n\\n        \\\"\\\"\\\"\\n        _maxes = self._maxes\\n\\n        if not _maxes:\\n            return 0\\n\\n        pos = bisect_left(_maxes, value)\\n\\n        if pos == len(_maxes):\\n            return self._len\\n\\n        idx = bisect_left(self._lists[pos], value)\\n        return self._loc(pos, idx)\\n\\n\\n    def bisect_right(self, value):\\n        \\\"\\\"\\\"Return an index to insert `value` in the sorted list.\\n\\n        Similar to `bisect_left`, but if `value` is already present, the\\n        insertion point with be after (to the right of) any existing values.\\n\\n        Similar to the `bisect` module in the standard library.\\n\\n        Runtime complexity: `O(log(n))` -- approximate.\\n\\n        >>> sl = SortedList([10, 11, 12, 13, 14])\\n        >>> sl.bisect_right(12)\\n        3\\n\\n        :param value: insertion index of value in sorted list\\n        :return: index\\n\\n        \\\"\\\"\\\"\\n        _maxes = self._maxes\\n\\n        if not _maxes:\\n            return 0\\n\\n        pos = bisect_right(_maxes, value)\\n\\n        if pos == len(_maxes):\\n            return self._len\\n\\n        idx = bisect_right(self._lists[pos], value)\\n        return self._loc(pos, idx)\\n\\n    bisect = bisect_right\\n    _bisect_right = bisect_right\\n\\n\\n    def count(self, value):\\n        \\\"\\\"\\\"Return number of occurrences of `value` in the sorted list.\\n\\n        Runtime complexity: `O(log(n))` -- approximate.\\n\\n        >>> sl = SortedList([1, 2, 2, 3, 3, 3, 4, 4, 4, 4])\\n        >>> sl.count(3)\\n        3\\n\\n        :param value: value to count in sorted list\\n        :return: count\\n\\n        \\\"\\\"\\\"\\n        _maxes = self._maxes\\n\\n        if not _maxes:\\n            return 0\\n\\n        pos_left = bisect_left(_maxes, value)\\n\\n        if pos_left == len(_maxes):\\n            return 0\\n\\n        _lists = self._lists\\n        idx_left = bisect_left(_lists[pos_left], value)\\n        pos_right = bisect_right(_maxes, value)\\n\\n        if pos_right == len(_maxes):\\n            return self._len - self._loc(pos_left, idx_left)\\n\\n        idx_right = bisect_right(_lists[pos_right], value)\\n\\n        if pos_left == pos_right:\\n            return idx_right - idx_left\\n\\n        right = self._loc(pos_right, idx_right)\\n        left = self._loc(pos_left, idx_left)\\n        return right - left\\n\\n\\n    def copy(self):\\n        \\\"\\\"\\\"Return a shallow copy of the sorted list.\\n\\n        Runtime complexity: `O(n)`\\n\\n        :return: new sorted list\\n\\n        \\\"\\\"\\\"\\n        return self.__class__(self)\\n\\n    __copy__ = copy\\n\\n\\n    def append(self, value):\\n        \\\"\\\"\\\"Raise not-implemented error.\\n\\n        Implemented to override `MutableSequence.append` which provides an\\n        erroneous default implementation.\\n\\n        :raises NotImplementedError: use ``sl.add(value)`` instead\\n\\n        \\\"\\\"\\\"\\n        raise NotImplementedError('use ``sl.add(value)`` instead')\\n\\n\\n    def extend(self, values):\\n        \\\"\\\"\\\"Raise not-implemented error.\\n\\n        Implemented to override `MutableSequence.extend` which provides an\\n        erroneous default implementation.\\n\\n        :raises NotImplementedError: use ``sl.update(values)`` instead\\n\\n        \\\"\\\"\\\"\\n        raise NotImplementedError('use ``sl.update(values)`` instead')\\n\\n\\n    def insert(self, index, value):\\n        \\\"\\\"\\\"Raise not-implemented error.\\n\\n        :raises NotImplementedError: use ``sl.add(value)`` instead\\n\\n        \\\"\\\"\\\"\\n        raise NotImplementedError('use ``sl.add(value)`` instead')\\n\\n\\n    def pop(self, index=-1):\\n        \\\"\\\"\\\"Remove and return value at `index` in sorted list.\\n\\n        Raise :exc:`IndexError` if the sorted list is empty or index is out of\\n        range.\\n\\n        Negative indices are supported.\\n\\n        Runtime complexity: `O(log(n))` -- approximate.\\n\\n        >>> sl = SortedList('abcde')\\n        >>> sl.pop()\\n        'e'\\n        >>> sl.pop(2)\\n        'c'\\n        >>> sl\\n        SortedList(['a', 'b', 'd'])\\n\\n        :param int index: index of value (default -1)\\n        :return: value\\n        :raises IndexError: if index is out of range\\n\\n        \\\"\\\"\\\"\\n        if not self._len:\\n            raise IndexError('pop index out of range')\\n\\n        _lists = self._lists\\n\\n        if index == 0:\\n            val = _lists[0][0]\\n            self._delete(0, 0)\\n            return val\\n\\n        if index == -1:\\n            pos = len(_lists) - 1\\n            loc = len(_lists[pos]) - 1\\n            val = _lists[pos][loc]\\n            self._delete(pos, loc)\\n            return val\\n\\n        if 0 <= index < len(_lists[0]):\\n            val = _lists[0][index]\\n            self._delete(0, index)\\n            return val\\n\\n        len_last = len(_lists[-1])\\n\\n        if -len_last < index < 0:\\n            pos = len(_lists) - 1\\n            loc = len_last + index\\n            val = _lists[pos][loc]\\n            self._delete(pos, loc)\\n            return val\\n\\n        pos, idx = self._pos(index)\\n        val = _lists[pos][idx]\\n        self._delete(pos, idx)\\n        return val\\n\\n\\n    def index(self, value, start=None, stop=None):\\n        \\\"\\\"\\\"Return first index of value in sorted list.\\n\\n        Raise ValueError if `value` is not present.\\n\\n        Index must be between `start` and `stop` for the `value` to be\\n        considered present. The default value, None, for `start` and `stop`\\n        indicate the beginning and end of the sorted list.\\n\\n        Negative indices are supported.\\n\\n        Runtime complexity: `O(log(n))` -- approximate.\\n\\n        >>> sl = SortedList('abcde')\\n        >>> sl.index('d')\\n        3\\n        >>> sl.index('z')\\n        Traceback (most recent call last):\\n          ...\\n        ValueError: 'z' is not in list\\n\\n        :param value: value in sorted list\\n        :param int start: start index (default None, start of sorted list)\\n        :param int stop: stop index (default None, end of sorted list)\\n        :return: index of value\\n        :raises ValueError: if value is not present\\n\\n        \\\"\\\"\\\"\\n        _len = self._len\\n\\n        if not _len:\\n            raise ValueError('{0!r} is not in list'.format(value))\\n\\n        if start is None:\\n            start = 0\\n        if start < 0:\\n            start += _len\\n        if start < 0:\\n            start = 0\\n\\n        if stop is None:\\n            stop = _len\\n        if stop < 0:\\n            stop += _len\\n        if stop > _len:\\n            stop = _len\\n\\n        if stop <= start:\\n            raise ValueError('{0!r} is not in list'.format(value))\\n\\n        _maxes = self._maxes\\n        pos_left = bisect_left(_maxes, value)\\n\\n        if pos_left == len(_maxes):\\n            raise ValueError('{0!r} is not in list'.format(value))\\n\\n        _lists = self._lists\\n        idx_left = bisect_left(_lists[pos_left], value)\\n\\n        if _lists[pos_left][idx_left] != value:\\n            raise ValueError('{0!r} is not in list'.format(value))\\n\\n        stop -= 1\\n        left = self._loc(pos_left, idx_left)\\n\\n        if start <= left:\\n            if left <= stop:\\n                return left\\n        else:\\n            right = self._bisect_right(value) - 1\\n\\n            if start <= right:\\n                return start\\n\\n        raise ValueError('{0!r} is not in list'.format(value))\\n\\n\\n    def __add__(self, other):\\n        \\\"\\\"\\\"Return new sorted list containing all values in both sequences.\\n\\n        ``sl.__add__(other)`` <==> ``sl + other``\\n\\n        Values in `other` do not need to be in sorted order.\\n\\n        Runtime complexity: `O(n*log(n))`\\n\\n        >>> sl1 = SortedList('bat')\\n        >>> sl2 = SortedList('cat')\\n        >>> sl1 + sl2\\n        SortedList(['a', 'a', 'b', 'c', 't', 't'])\\n\\n        :param other: other iterable\\n        :return: new sorted list\\n\\n        \\\"\\\"\\\"\\n        values = reduce(iadd, self._lists, [])\\n        values.extend(other)\\n        return self.__class__(values)\\n\\n    __radd__ = __add__\\n\\n\\n    def __iadd__(self, other):\\n        \\\"\\\"\\\"Update sorted list with values from `other`.\\n\\n        ``sl.__iadd__(other)`` <==> ``sl += other``\\n\\n        Values in `other` do not need to be in sorted order.\\n\\n        Runtime complexity: `O(k*log(n))` -- approximate.\\n\\n        >>> sl = SortedList('bat')\\n        >>> sl += 'cat'\\n        >>> sl\\n        SortedList(['a', 'a', 'b', 'c', 't', 't'])\\n\\n        :param other: other iterable\\n        :return: existing sorted list\\n\\n        \\\"\\\"\\\"\\n        self._update(other)\\n        return self\\n\\n\\n    def __mul__(self, num):\\n        \\\"\\\"\\\"Return new sorted list with `num` shallow copies of values.\\n\\n        ``sl.__mul__(num)`` <==> ``sl * num``\\n\\n        Runtime complexity: `O(n*log(n))`\\n\\n        >>> sl = SortedList('abc')\\n        >>> sl * 3\\n        SortedList(['a', 'a', 'a', 'b', 'b', 'b', 'c', 'c', 'c'])\\n\\n        :param int num: count of shallow copies\\n        :return: new sorted list\\n\\n        \\\"\\\"\\\"\\n        values = reduce(iadd, self._lists, []) * num\\n        return self.__class__(values)\\n\\n    __rmul__ = __mul__\\n\\n\\n    def __imul__(self, num):\\n        \\\"\\\"\\\"Update the sorted list with `num` shallow copies of values.\\n\\n        ``sl.__imul__(num)`` <==> ``sl *= num``\\n\\n        Runtime complexity: `O(n*log(n))`\\n\\n        >>> sl = SortedList('abc')\\n        >>> sl *= 3\\n        >>> sl\\n        SortedList(['a', 'a', 'a', 'b', 'b', 'b', 'c', 'c', 'c'])\\n\\n        :param int num: count of shallow copies\\n        :return: existing sorted list\\n\\n        \\\"\\\"\\\"\\n        values = reduce(iadd, self._lists, []) * num\\n        self._clear()\\n        self._update(values)\\n        return self\\n\\n\\n    def __make_cmp(seq_op, symbol, doc):\\n        \\\"Make comparator method.\\\"\\n        def comparer(self, other):\\n            \\\"Compare method for sorted list and sequence.\\\"\\n            if not isinstance(other, Sequence):\\n                return NotImplemented\\n\\n            self_len = self._len\\n            len_other = len(other)\\n\\n            if self_len != len_other:\\n                if seq_op is eq:\\n                    return False\\n                if seq_op is ne:\\n                    return True\\n\\n            for alpha, beta in zip(self, other):\\n                if alpha != beta:\\n                    return seq_op(alpha, beta)\\n\\n            return seq_op(self_len, len_other)\\n\\n        seq_op_name = seq_op.__name__\\n        comparer.__name__ = '__{0}__'.format(seq_op_name)\\n        doc_str = \\\"\\\"\\\"Return true if and only if sorted list is {0} `other`.\\n\\n        ``sl.__{1}__(other)`` <==> ``sl {2} other``\\n\\n        Comparisons use lexicographical order as with sequences.\\n\\n        Runtime complexity: `O(n)`\\n\\n        :param other: `other` sequence\\n        :return: true if sorted list is {0} `other`\\n\\n        \\\"\\\"\\\"\\n        comparer.__doc__ = dedent(doc_str.format(doc, seq_op_name, symbol))\\n        return comparer\\n\\n\\n    __eq__ = __make_cmp(eq, '==', 'equal to')\\n    __ne__ = __make_cmp(ne, '!=', 'not equal to')\\n    __lt__ = __make_cmp(lt, '<', 'less than')\\n    __gt__ = __make_cmp(gt, '>', 'greater than')\\n    __le__ = __make_cmp(le, '<=', 'less than or equal to')\\n    __ge__ = __make_cmp(ge, '>=', 'greater than or equal to')\\n    __make_cmp = staticmethod(__make_cmp)\\n\\n\\n    @recursive_repr()\\n    def __repr__(self):\\n        \\\"\\\"\\\"Return string representation of sorted list.\\n\\n        ``sl.__repr__()`` <==> ``repr(sl)``\\n\\n        :return: string representation\\n\\n        \\\"\\\"\\\"\\n        return '{0}({1!r})'.format(type(self).__name__, list(self))\\n\\n\\n    def _check(self):\\n        \\\"\\\"\\\"Check invariants of sorted list.\\n\\n        Runtime complexity: `O(n)`\\n\\n        \\\"\\\"\\\"\\n        try:\\n            assert self._load >= 4\\n            assert len(self._maxes) == len(self._lists)\\n            assert self._len == sum(len(sublist) for sublist in self._lists)\\n\\n            # Check all sublists are sorted.\\n\\n            for sublist in self._lists:\\n                for pos in range(1, len(sublist)):\\n                    assert sublist[pos - 1] <= sublist[pos]\\n\\n            # Check beginning/end of sublists are sorted.\\n\\n            for pos in range(1, len(self._lists)):\\n                assert self._lists[pos - 1][-1] <= self._lists[pos][0]\\n\\n            # Check _maxes index is the last value of each sublist.\\n\\n            for pos in range(len(self._maxes)):\\n                assert self._maxes[pos] == self._lists[pos][-1]\\n\\n            # Check sublist lengths are less than double load-factor.\\n\\n            double = self._load << 1\\n            assert all(len(sublist) <= double for sublist in self._lists)\\n\\n            # Check sublist lengths are greater than half load-factor for all\\n            # but the last sublist.\\n\\n            half = self._load >> 1\\n            for pos in range(0, len(self._lists) - 1):\\n                assert len(self._lists[pos]) >= half\\n\\n            if self._index:\\n                assert self._len == self._index[0]\\n                assert len(self._index) == self._offset + len(self._lists)\\n\\n                # Check index leaf nodes equal length of sublists.\\n\\n                for pos in range(len(self._lists)):\\n                    leaf = self._index[self._offset + pos]\\n                    assert leaf == len(self._lists[pos])\\n\\n                # Check index branch nodes are the sum of their children.\\n\\n                for pos in range(self._offset):\\n                    child = (pos << 1) + 1\\n                    if child >= len(self._index):\\n                        assert self._index[pos] == 0\\n                    elif child + 1 == len(self._index):\\n                        assert self._index[pos] == self._index[child]\\n                    else:\\n                        child_sum = self._index[child] + self._index[child + 1]\\n                        assert child_sum == self._index[pos]\\n        except:\\n            import sys\\n            import traceback\\n            traceback.print_exc(file=sys.stdout)\\n            print('len', self._len)\\n            print('load', self._load)\\n            print('offset', self._offset)\\n            print('len_index', len(self._index))\\n            print('index', self._index)\\n            print('len_maxes', len(self._maxes))\\n            print('maxes', self._maxes)\\n            print('len_lists', len(self._lists))\\n            print('lists', self._lists)\\n            raise\\n\\n\\nfin = sys.stdin.readline\\nn, k = [int(elem) for elem in fin().split()]\\na_list = sorted([(int(elem), i) for i, elem in enumerate(fin().split())], reverse=True)\\n# print(a_list)\\n\\nidx_to_team = [0] * n\\nprogrammers_in_row = SortedList(list(range(n)))\\ncoach = 1\\nfor a, i in a_list:\\n    if idx_to_team[i] != 0:\\n        continue\\n\\n    # Add them to the team\\n    cur_idx = programmers_in_row.bisect_left(i)\\n    cur_added = []\\n    for j in range(max(0, cur_idx - k), min(len(programmers_in_row), cur_idx + k + 1)):\\n        neighbor = programmers_in_row[j]\\n        idx_to_team[neighbor] = coach\\n        cur_added.append(neighbor)\\n\\n    # Discard them from the row\\n    for added_programmer in cur_added:\\n        programmers_in_row.remove(added_programmer)\\n\\n    coach = 2 if coach == 1 else 1\\n\\n\\nprint(\\\"\\\".join(str(coach) for coach in idx_to_team))\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nn,k=list(map(int,input().split()))\\nA=list(map(int,input().split()))\\n\\nA_INV=[-1]*n\\nfor i in range(n):\\n    A_INV[A[i]-1]=i\\n    \\nL=list(range(-1,n-1))\\nR=list(range(1,n+1))\\n\\nUSELIST=[0]*n\\nANS=[0]*n\\nNOW=1\\n\\nfor a in A_INV[::-1]:\\n    if USELIST[a]==1:\\n        continue\\n    USELIST[a]=1\\n    ANS[a]=NOW\\n\\n    if 0<=a<n and 0<=L[a]<n:\\n        R[L[a]]=R[a]\\n\\n    if 0<=a<n and 0<=R[a]<n:\\n        L[R[a]]=L[a]\\n\\n    r=a\\n    for step in range(k):\\n        r=R[r]\\n        if r<0 or r>=n:\\n            break\\n        ANS[r]=NOW\\n        USELIST[r]=1\\n\\n        if 0<=r<n and 0<=L[r]<n:\\n            R[L[r]]=R[r]\\n\\n        if 0<=r<n and 0<=R[r]<n:\\n            L[R[r]]=L[r]\\n\\n    l=a\\n    for step in range(k):\\n        l=L[l]\\n        if l<0 or l>=n:\\n            break\\n        ANS[l]=NOW\\n        USELIST[l]=1\\n\\n        if 0<=l<n and 0<=L[l]<n:\\n            R[L[l]]=R[l]\\n\\n        if 0<=l<n and 0<=R[l]<n:\\n            L[R[l]]=L[l]\\n\\n    NOW=3-NOW\\n    #print(*ANS,USELIST,L,R)\\n\\nprint(\\\"\\\".join(map(str,ANS)))\\n        \\n        \\n\", \"import heapq\\n\\n\\nn, k = [int(i) for i in input().split(' ')]\\n\\nstus = [int(i) for i in input().split(' ')]\\nss = sorted(list(enumerate(stus)), key=lambda x: -x[1])\\nnb = [[i - 1, i + 1] for i in range(n)]\\nssid = 0\\n\\nres = [-1] * n\\nturn = 0\\ncount = 0\\nfor idx, val in ss:\\n    if res[idx] != -1:\\n        continue\\n    res[idx] = turn % 2 + 1\\n    left, right = nb[idx]\\n    for i in range(k):\\n        if right < n and res[right] == -1:\\n            res[right] = turn % 2 + 1\\n            nb[idx][1] = nb[right][1]\\n            right = nb[right][1]\\n\\n        if left >= 0 and res[left] == -1:\\n            res[left] = turn % 2 + 1\\n            nb[idx][0] = nb[left][0]\\n            left = nb[left][0]\\n        if nb[idx][1] < n:\\n            nb[nb[idx][1]][0] = nb[idx][0]\\n        if nb[idx][0] >= 0:\\n            nb[nb[idx][0]][1] = nb[idx][1]\\n    turn += 1\\nprint(''.join([str(i) for i in res]))\\n\", \"# AC\\nimport sys\\n\\n\\nclass Main:\\n    def __init__(self):\\n        self.buff = None\\n        self.index = 0\\n\\n    def __next__(self):\\n        if self.buff is None or self.index == len(self.buff):\\n            self.buff = sys.stdin.readline().split()\\n            self.index = 0\\n        val = self.buff[self.index]\\n        self.index += 1\\n        return val\\n\\n    def next_int(self):\\n        return int(next(self))\\n\\n    def solve(self):\\n        n = self.next_int()\\n        k = self.next_int()\\n        x = [self.next_int() for _ in range(0, n)]\\n        bf = [x - 1 for x in range(0, n)]\\n        nx = [x + 1 for x in range(0, n)]\\n        t = [0 for _ in range(0, n)]\\n        od = [0 for _ in range(0, n)]\\n        for i in range(0, n):\\n            od[x[i] - 1] = i\\n        tt = 1\\n        for i in range(n - 1, -1, -1):\\n            if t[od[i]] == 0:\\n                o = od[i]\\n                t[o] = tt\\n                for _ in range(0, k):\\n                    o = bf[o]\\n                    if o == -1:\\n                        break\\n                    t[o] = tt\\n\\n                oo = od[i]\\n                for _ in range(0, k):\\n                    oo = nx[oo]\\n                    if oo == n:\\n                        break\\n                    t[oo] = tt\\n                if o != -1 and bf[o] != -1:\\n                    nx[bf[o]] = oo if oo == n else nx[oo]\\n                if oo != n and nx[oo] != n:\\n                    bf[nx[oo]] = o if o == -1 else bf[o]\\n                tt = 3 - tt\\n        print(''.join([str(xx) for xx in t]))\\n\\n\\ndef __starting_point():\\n    Main().solve()\\n\\n__starting_point()\", \"import heapq\\n\\nn, k = map(int, input().split())\\na = list(map(int, input().split()))\\n\\nfirst = [False] * n\\nsecond = [False] * n\\npq = []\\nnexts = [None] * n\\nprevs = [None] * n\\nfor i in range(n):\\n    heapq.heappush(pq, (-a[i], i))\\n    if i < n - 1:\\n        nexts[i] = i + 1\\n    if i > 0:\\n        prevs[i] = i - 1\\n\\nturn = 0\\nwhile pq:\\n    _, curIdx = heapq.heappop(pq)\\n    if first[curIdx] or second[curIdx]:\\n        continue\\n    if turn == 0:\\n        first[curIdx] = True\\n    else:\\n        second[curIdx] = True\\n\\n    fromLeft = 0\\n    i = prevs[curIdx]\\n    while fromLeft < k and i != None:\\n        if turn == 0:\\n            first[i] = True\\n        else:\\n            second[i] = True\\n        i = prevs[i]\\n        fromLeft += 1\\n    prevs[curIdx] = i\\n\\n    fromRight = 0\\n    i = nexts[curIdx]\\n    while fromRight < k and i != None:\\n        if turn == 0:\\n            first[i] = True\\n        else:\\n            second[i] = True\\n        i = nexts[i]\\n        fromRight += 1\\n    nexts[curIdx] = i\\n\\n    if prevs[curIdx] != None:\\n        nexts[prevs[curIdx]] = nexts[curIdx]\\n    if nexts[curIdx] != None:\\n        prevs[nexts[curIdx]] = prevs[curIdx]\\n\\n    turn ^= 1\\n\\nfor i in range(n):\\n    print(1 if first[i] else 2, end='')\", \"n,k = list(map(int,input().split()))\\na = list(map(int,input().split()))\\npos = {}\\npre = [i-1 for i in range(n+2)]\\nnex = [i+1 for i in range(n+2)]\\nfor i,j in enumerate(a):\\n    pos[j] = i+1\\ngroup = 1\\ntaken = [0 for _ in range(n+2)]\\nright = left = 0\\nfor i in range(n,0,-1):\\n    if taken[pos[i]] != 0:\\n        continue\\n    group = (group + 1) % 2\\n    p = k\\n    now = pos[i]\\n    taken[now] = group + 1\\n    while p > 0 and now <= n:\\n        now = nex[now]\\n        if taken[now] == 0:\\n            taken[now] = group + 1\\n            p -= 1\\n        right = now\\n    p = k\\n    now = pos[i]\\n    while p > 0 and now > 0:\\n        now = pre[now]\\n        if taken[now] == 0:\\n            taken[now] = group + 1\\n            p -= 1\\n        left = now\\n    nex[left] = right\\n    pre[right] = left\\nans = [str(i) for i in taken]\\nprint(''.join(ans[1:n+1]))\\n\", \"import heapq\\ndef main():\\n    n, k = list(map(int, input().split()))\\n    a = list(map(int, input().split()))\\n\\n    q = []\\n    for i in range(n):\\n        heapq.heappush(q, (-a[i], i))\\n\\n    teams = [0] * n\\n    nextLeft = [i-1 for i in range(n)]\\n    nextRight = [i+1 for i in range(n)]\\n    used = [False] * n\\n\\n    team = 0\\n    while q:\\n        item, pos = heapq.heappop(q)\\n        while q and used[pos]:\\n            item, pos = heapq.heappop(q)\\n        if used[pos]:\\n            break  # all done\\n\\n        teams[pos] = team + 1\\n        used[pos] = True\\n\\n        deletedLeft = 0\\n        currLeft = pos\\n        while deletedLeft < k and nextLeft[currLeft] >= 0:\\n            currLeft = nextLeft[currLeft]\\n            used[currLeft] = True\\n            teams[currLeft] = team + 1\\n            deletedLeft += 1\\n\\n        deletedRight = 0\\n        currRight = pos\\n        while deletedRight < k and nextRight[currRight] < n:\\n            currRight = nextRight[currRight]\\n            used[currRight] = True\\n            teams[currRight] = team + 1\\n            deletedRight += 1\\n\\n        if currLeft >= 0:\\n            currLeft = nextLeft[currLeft]\\n        if currRight < n:\\n            currRight = nextRight[currRight]\\n\\n        if currLeft >= 0:\\n            nextRight[currLeft] = currRight\\n        if currRight < n:\\n            nextLeft[currRight] = currLeft\\n\\n        team = (team + 1) % 2\\n\\n    print(''.join(map(str, teams)))\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"n, k = list(map(int, input().split()))\\nrow = list(map(int, input().split()))\\n\\nranked = list([x[1] for x in sorted([(-x[1], x[0]) for x in enumerate(row)])])\\n\\nprev = list(range(-1, n - 1))\\nnxt = list(range(1, n + 1))\\nteams = [0] * n\\ncurrent = 1\\ntotal = 0\\n\\nfor i in ranked:\\n    if total > n:\\n        break\\n\\n    if not teams[i]:\\n        teams[i] = current\\n        took = 1\\n\\n        # walk left\\n        count = k\\n        left = prev[i]\\n        while count > 0 and left != -1:\\n            teams[left] = current\\n            left = prev[left]\\n            took += 1\\n            count -= 1\\n\\n        # walk right\\n        count = k\\n        right = nxt[i]\\n        while count > 0 and right != n:\\n            teams[right] = current\\n            right = nxt[right]\\n            took += 1\\n            count -= 1\\n\\n        if left != -1:\\n            nxt[left] = right\\n\\n        if right != n:\\n            prev[right] = left\\n\\n        total += took\\n        current = 2 if current == 1 else 1\\n\\nprint(''.join(map(str, teams)))\\n\", \"n, k = list(map(int, input().split()))\\na = list(map(int, input().split()))\\npre = {}\\nnex = {}\\nd = {}\\nfor i in range(n):\\n    d[a[i]] = i\\nfor i in range(n):\\n    pre[i] = i - 1\\n    nex[i] = i + 1\\n\\nt = 1\\nans = [-1] * n\\nfor i in range(n, 0, -1):\\n    j = d[i]\\n    if ans[j] != -1:\\n        continue\\n    ans[j] = t\\n    l, r = pre[j], nex[j]\\n    for p in range(k):\\n        if l == -1:\\n            break\\n        ans[l] = t\\n        l = pre[l]\\n\\n    for p in range(k):\\n        if r == n:\\n            break\\n        ans[r] = t\\n        r = nex[r]\\n\\n    if l >= 0:\\n        nex[l] = r\\n    if r < n:\\n        pre[r] = l\\n\\n    t = 3 - t\\n\\nprint(''.join(map(str, ans)))\\n\\n\", \"#!/usr/bin/env python\\n# -*- coding: utf-8 -*-\\n\\n\\\"\\\"\\\"Codeforces Round #552 (Div. 3)\\n\\nProblem E. Two Teams\\n\\n:author:         Kitchen Tong\\n:mail:    kctong529@gmail.com\\n\\nPlease feel free to contact me if you have any question\\nregarding the implementation below.\\n\\\"\\\"\\\"\\n\\n__version__ = '1.0'\\n__date__ = '2019-04-17'\\n\\nimport sys\\n\\n\\ndef remove_me(to_left, to_right, index):\\n    left_id = to_left[index]\\n    right_id = to_right[index]\\n    if right_id < len(to_left):\\n        to_left[right_id] = left_id\\n    if left_id >= 0:\\n        to_right[left_id] = right_id\\n    return (left_id, right_id)\\n\\ndef join_team(n, k, students):\\n    teams = ['0'] * n\\n    mydict = dict(list(zip(students, list(range(n)))))    # {skill: id}\\n    to_left = [i-1 for i in range(n)]\\n    to_right = [i+1 for i in range(n)]\\n\\n    next_chosen = n\\n    chosen_total = 0\\n    while chosen_total < n:\\n        for couch in ['1', '2']:\\n            while teams[mydict[next_chosen]] != '0':\\n                next_chosen -= 1\\n                if next_chosen < 1:\\n                    return teams\\n            teams[mydict[next_chosen]] = couch\\n            chosen_total += 1\\n            left_id, right_id = remove_me(to_left, to_right,\\n                                          mydict[next_chosen])\\n            for i in range(k):\\n                if left_id < 0:\\n                    break\\n                teams[left_id] = couch\\n                chosen_total += 1\\n                left_id, right_id = remove_me(to_left, to_right, left_id)\\n            for i in range(k):\\n                if right_id >= n:\\n                    break\\n                teams[right_id] = couch\\n                chosen_total += 1\\n                left_id, right_id = remove_me(to_left, to_right, right_id)\\n    return teams\\n\\ndef main(argv=None):\\n    n, k = list(map(int, input().split()))\\n    students = list(map(int, input().split()))\\n    print(''.join(join_team(n, k, students)))\\n    return 0\\n\\ndef __starting_point():\\n    STATUS = main()\\n    return(STATUS)\\n\\n\\n__starting_point()\"]", "task": "apps", "difficulty": "introductory", "split": "test", "transformation_type": "vanilla"}