{"qid": 109, "orig_input": "While Grisha was celebrating New Year with Ded Moroz, Misha gifted Sasha a small rectangular pond of size n \u00d7 m, divided into cells of size 1 \u00d7 1, inhabited by tiny evil fishes (no more than one fish per cell, otherwise they'll strife!).\n\nThe gift bundle also includes a square scoop of size r \u00d7 r, designed for fishing. If the lower-left corner of the scoop-net is located at cell (x, y), all fishes inside the square (x, y)...(x + r - 1, y + r - 1) get caught. Note that the scoop-net should lie completely inside the pond when used.\n\nUnfortunately, Sasha is not that skilled in fishing and hence throws the scoop randomly. In order to not frustrate Sasha, Misha decided to release k fishes into the empty pond in such a way that the expected value of the number of caught fishes is as high as possible. Help Misha! In other words, put k fishes in the pond into distinct cells in such a way that when the scoop-net is placed into a random position among (n - r + 1)\u00b7(m - r + 1) possible positions, the average number of caught fishes is as high as possible.\n\n\n-----Input-----\n\nThe only line contains four integers n, m, r, k (1 \u2264 n, m \u2264 10^5, 1 \u2264 r \u2264 min(n, m), 1 \u2264 k \u2264 min(n\u00b7m, 10^5)).\n\n\n-----Output-----\n\nPrint a single number\u00a0\u2014 the maximum possible expected number of caught fishes.\n\nYou answer is considered correct, is its absolute or relative error does not exceed 10^{ - 9}. Namely, let your answer be a, and the jury's answer be b. Your answer is considered correct, if $\\frac{|a - b|}{\\operatorname{max}(1,|b|)} \\leq 10^{-9}$.\n\n\n-----Examples-----\nInput\n3 3 2 3\n\nOutput\n2.0000000000\n\nInput\n12 17 9 40\n\nOutput\n32.8333333333\n\n\n\n-----Note-----\n\nIn the first example you can put the fishes in cells (2, 1), (2, 2), (2, 3). In this case, for any of four possible positions of the scoop-net (highlighted with light green), the number of fishes inside is equal to two, and so is the expected value. [Image]", "input": "Calculate the maximum expected value of fish caught by a square net in a rectangular grid, given pond dimensions, net size, and number of fish to place.", "test_cases": {"inputs": ["3 3 2 3\n", "12 17 9 40\n", "1 1 1 1\n", "10 10 5 100\n", "7 1 1 4\n", "1000 1000 59 100000\n", "100000 100000 1000 100000\n", "100000 100000 100000 100000\n", "3 100000 2 88700\n", "200 100000 55 100000\n", "74 2 1 36\n", "2 59 1 112\n", "96 33 24 928\n", "20 78 8 997\n", "44 22 13 515\n", "68 66 33 2353\n", "96 7 4 534\n", "20 59 2 88\n", "45 3 1 35\n", "69 48 18 167\n", "34994 5189 2572 83748\n", "51122 86737 45712 45929\n", "1308 96219 150 13599\n", "84732 45064 24231 99973\n", "860 93908 193 29450\n", "51580 42753 1589 91632\n", "67708 58893 32854 21110\n", "51133 7737 2779 83291\n", "67261 65094 36712 36961\n", "17981 81234 438 66438\n", "86852 96025 86852 82059\n", "96877 86600 86600 94110\n", "93240 88881 88881 94245\n", "90706 97197 90706 96593\n", "93289 95214 93289 96084\n", "90755 85790 85790 98432\n", "80779 83807 80779 97924\n", "98246 89266 89266 80270\n", "80828 99843 80828 99763\n", "98295 88157 88157 82110\n", "52329 55202 45142 8532\n", "68457 4046 983 38009\n", "18644 46233 17019 62575\n", "2068 62373 1084 92053\n", "18196 43921 15918 54235\n", "68916 60062 7636 83712\n", "85044 8906 4115 45894\n", "68468 33559 15324 99563\n", "84596 49699 46033 61745\n", "35316 31247 27829 91223\n", "51444 47388 21532 20700\n", "67572 96232 61366 50178\n", "17759 38418 4313 7448\n", "1183 87263 148 4221\n", "84607 36107 29486 33699\n", "68031 52248 51042 20073\n", "84159 1092 683 49550\n", "67583 49936 46141 11732\n", "51007 74589 14733 41209\n", "34431 23433 19371 27583\n", "52 45 38 49\n", "80 89 32 26\n", "74 63 30 92\n", "2 20 1 14\n", "22 60 13 48\n", "50 5 4 29\n", "74 49 48 99\n", "2 89 2 80\n", "22 38 9 58\n", "50 86 11 36\n", "98155 95063 95062 98875\n", "95606 98563 95342 99783\n", "95468 97642 95176 95192\n", "96394 96141 96028 96100\n", "100000 1 1 99999\n", "100000 100000 1 100000\n", "100000 100000 100000 1\n", "88888 99999 77777 1\n", "77777 99999 77777 7\n", "100000 100000 1 1\n", "3689 2691 1885 47808\n", "3907 4563 2248 99346\n", "1785 3525 1785 82536\n", "4761 2433 2433 46586\n", "3106 2359 1558 16919\n", "3291 1679 1679 70630\n", "6439 5463 3240 91287\n", "10000 10000 3000 100000\n", "7159 6332 3563 82463\n", "8402 6135 4222 85384\n", "8946 8108 4509 80203\n", "9199 8137 4561 82660\n", "8208 8895 4508 97736\n", "9513 11191 5633 90250\n", "11562 20387 10218 95794\n", "80000 80000 40000 100000\n", "7 100 4 12\n"], "outputs": ["2.0000000000\n", "32.8333333333\n", "1.0000000000\n", "25.0000000000\n", "0.5714285714\n", "392.2854657164\n", "10.2028343872\n", "100000.0000000000\n", "1.7740177402\n", "20.7303724833\n", "0.2432432432\n", "0.9491525424\n", "299.8356164384\n", "55.2026002167\n", "139.7312500000\n", "930.8962418301\n", "14.6129032258\n", "0.3194192377\n", "0.2592592593\n", "33.5657568238\n", "6526.6982502848\n", "45929.0000000000\n", "2.7480097244\n", "40039.1022280255\n", "17.5230504355\n", "112.4258885780\n", "19898.0903744083\n", "2682.4996497742\n", "36961.0000000000\n", "8.9916815389\n", "82059.0000000000\n", "94110.0000000000\n", "94245.0000000000\n", "96593.0000000000\n", "96084.0000000000\n", "98432.0000000000\n", "97924.0000000000\n", "80270.0000000000\n", "99763.0000000000\n", "82110.0000000000\n", "8532.0000000000\n", "177.6486146644\n", "36452.6416224542\n", "1628.0869962473\n", "30828.1934723611\n", "1519.2830994297\n", "2003.8686025940\n", "24124.0525512989\n", "61745.0000000000\n", "91223.0000000000\n", "12407.9770445558\n", "50178.0000000000\n", "302.0942031080\n", "1.0244272005\n", "18026.3545226951\n", "20073.0000000000\n", "405.4128682152\n", "11732.0000000000\n", "4119.5718891113\n", "27583.0000000000\n", "49.0000000000\n", "9.3680506685\n", "53.8823529412\n", "0.3500000000\n", "13.0000000000\n", "2.4680851064\n", "99.0000000000\n", "1.8181818182\n", "11.1857142857\n", "1.4328947368\n", "98875.0000000000\n", "99783.0000000000\n", "95192.0000000000\n", "96100.0000000000\n", "0.9999900000\n", "0.0000100000\n", "1.0000000000\n", "1.0000000000\n", "7.0000000000\n", "0.0000000001\n", "47808.0000000000\n", "95853.0468547766\n", "82534.7300402068\n", "46586.0000000000\n", "16897.4346155270\n", "70630.0000000000\n", "91097.0460375450\n", "18362.1002496817\n", "81427.6340771341\n", "85384.0000000000\n", "80188.7715868009\n", "81268.3728190748\n", "97736.0000000000\n", "90250.0000000000\n", "95794.0000000000\n", "99625.0947119987\n", "0.4948453608\n"]}, "solutions": "[\"import heapq as hq\\nfrom queue import PriorityQueue\\n\\nimport math\\nn,m,r, k= input().split()\\nN = int(n)\\nM = int(m)\\nR = int(r)\\nK = int(k)\\n\\nq = PriorityQueue()\\n\\n\\n\\nfor i in range(1,math.floor((N+1)/2) + 1):\\n    maxi = min(min(i,N-i+1),min(R,N-R+1)) * min(min(R,M-R+1),math.ceil(M/2))\\n    num = M - (2 * min(min(R,M-R+1),math.ceil(M/2))-2)\\n    mult = 2\\n    if(i > math.floor(N/2)):\\n        mult = 1\\n    q.put((-maxi,num * mult,i))\\n    #print(str(maxi) + \\\" \\\" + str(num) + \\\" \\\" + str(mult))\\n\\n\\nans = 0\\nwhile(K > 0):\\n    pop = q.get()\\n    #print(pop)\\n    a = -1 * pop[0]\\n    b = pop[1]\\n    c = pop[2]\\n    d = min(min(c,N-c+1),min(R,N-R+1))\\n    if(d != a):\\n       # if(q.)\\n       # if(q.get(-(a - d)) != )\\n        mult = 2\\n        if (c > N / 2):\\n            mult = 1\\n        q.put((-(a - d),2*mult,c))\\n    ans += a * min(b,K)\\n    K -= b;\\n\\ntot = (N-R+1) * (M-R+1)\\n#print(\\\"ANS = \\\" + str(ans))\\n#print(\\\"FINANS = \\\" + str(ans/tot))\\nprint(str(ans/tot))\\n\\n\\n'''\\n\\nd = []\\nfor i in range(0,N):\\n    d.append([])\\n    for j in range(0,M):\\n        d[i].append(0)\\n\\ntot = 0\\nfor i in range(0,N-R+1):\\n    for j in range(0,M-R+1):\\n        for k in range(i,i+R):\\n            for l in range(j,j+R):\\n                d[k][l] += 1\\n                tot += 1\\n\\n\\nprint(N-R+1)*(M-R+1) * (R*R)\\nprint(tot)\\nprint()\\nfor i in d:\\n    print(i)\\n\\n'''\\n\", \"class TupleHeap(object):\\n    def __init__(self):\\n        self.heap = [0]\\n    def mult(self, i):\\n        return self.heap[i][0] * self.heap[i][1]\\n    def __str__(self):\\n        return \\\" \\\".join(map(str, self.heap))\\n    def add(self, var):\\n        self.heap.append(var)\\n        if len(self.heap) > 2:\\n            # \\u043d\\u0430\\u0434\\u043e \\u0441\\u043e\\u0440\\u0442\\u0438\\u0440\\u043e\\u0432\\u0430\\u0442\\u044c \\u0441\\u043d\\u0438\\u0437\\u0443\\n            el = len(self.heap) - 1\\n            par = el // 2\\n            while (el != 1) and (self.mult(el) > self.mult(par)):\\n                self.heap[el], self.heap[par] = self.heap[par], self.heap[el]\\n                el = par\\n                par = el // 2\\n    def pop(self):\\n        if len(self.heap) == 1:\\n            return None  # \\u041d\\u0435\\u0447\\u0435\\u0433\\u043e \\u0431\\u0440\\u0430\\u0442\\u044c \\u0438\\u0437 \\u043a\\u0443\\u0447\\u0438\\n        ans = self.heap[1]\\n        if len(self.heap) == 2:\\n            self.heap.pop()\\n            return ans\\n        self.heap[1] = self.heap.pop()\\n        # \\u0434\\u0435\\u043b\\u0430\\u0435\\u043c \\u0441\\u043e\\u0440\\u0442\\u0438\\u0440\\u043e\\u0432\\u043a\\u0443 \\u0432\\u043d\\u0438\\u0437\\n        el = 1\\n        var_el = self.mult(el)\\n        child1 = el * 2\\n        if child1 < len(self.heap):\\n            var_child1 = self.mult(child1)\\n        else:\\n            var_child1 = -1\\n        child2 = el * 2 + 1\\n        if child2 < len(self.heap):\\n            var_child2 = self.mult(child2)\\n        else:\\n            var_child2 = -1\\n        while (var_child2 > var_el) or (var_child1 > var_el):\\n            if var_child1 > var_child2:\\n                self.heap[el], self.heap[child1] = self.heap[child1], self.heap[el]\\n                el = child1\\n            else:\\n                self.heap[el], self.heap[child2] = self.heap[child2], self.heap[el]\\n                el = child2\\n            var_el = self.mult(el)\\n            child1 = el * 2\\n            if child1 < len(self.heap):\\n                var_child1 = self.mult(child1)\\n            else:\\n                var_child1 = -1\\n            child2 = el * 2 + 1\\n            if child2 < len(self.heap):\\n                var_child2 = self.mult(child2)\\n            else:\\n                var_child2 = -1\\n        return ans\\n\\nn, m, r , k = map(int, input().split())\\n\\nmax_x = min(r, n - r + 1)\\nmax_y = min(r, m - r + 1)\\ncol_max_x = n - 2 * (max_x - 1)\\ncol_max_y = m - 2 * (max_y - 1)\\nNr = (n - r + 1) * (m - r + 1)\\n\\n\\ntuple_heap = TupleHeap()\\ntuple_heap.add((max_x, max_y))\\nused = {(max_x, max_y)}\\nSUMM = 0\\n\\ncurr = tuple_heap.pop()\\nwhile (curr is not None) and (curr[0] > 0) and (curr[1] > 0) and (k > 0):\\n    # \\u043a\\u043b\\u0430\\u0434\\u0451\\u043c \\u0432 \\u043a\\u0443\\u0447\\u0443 \\u0441\\u043b\\u0435\\u0434\\u0443\\u044e\\u0449\\u0438\\u0435 \\u044d\\u043b\\u0435\\u043c\\u0435\\u043d\\u0442\\u044b (\\u0435\\u0441\\u043b\\u0438 \\u0438\\u0445 \\u0442\\u0430\\u043c \\u043d\\u0435\\u0442)\\n    new_tuple1 = (curr[0] - 1, curr[1])\\n    if new_tuple1 not in used:\\n        used.add(new_tuple1)\\n        tuple_heap.add(new_tuple1)\\n    new_tuple2 = (curr[0], curr[1] - 1)\\n    if new_tuple2 not in used:\\n        used.add(new_tuple2)\\n        tuple_heap.add(new_tuple2)\\n    # \\u0432\\u044b\\u0447\\u0438\\u0441\\u043b\\u044f\\u0435\\u043c \\u043a\\u043e\\u043b-\\u0432\\u043e \\u044d\\u043b\\u0435\\u043c\\u0435\\u043d\\u0442\\u043e\\u0432 \\u043f\\u043e\\u043b\\u044f \\u0434\\u043b\\u044f \\u0442\\u0430\\u043a\\u043e\\u0433\\u043e curr\\n    x = 2 if curr[0] != max_x else col_max_x\\n    y = 2 if curr[1] != max_y else col_max_y\\n    col = min(x * y, k)                          # \\u0440\\u0430\\u0437\\u043c\\u0435\\u0449\\u0430\\u0435\\u043c \\u0440\\u044b\\u0431\\u043e\\u043a \\u0432 \\u043a\\u0432\\u0430\\u0434\\u0440\\u0430\\u0442\\u044b, \\u043d\\u043e \\u043d\\u0435 \\u0431\\u043e\\u043b\\u0435\\u0435 1 \\u0440\\u044b\\u0431\\u043a\\u0438 \\u043d\\u0430 \\u043a\\u0432\\u0430\\u0434\\u0440\\u0430\\u0442\\n    k = k - col                           # \\u0441\\u043a\\u043e\\u043b\\u044c\\u043a\\u043e \\u0435\\u0449\\u0451 \\u0440\\u044b\\u0431\\u043e\\u043a \\u043d\\u0430\\u0434\\u043e \\u0440\\u0430\\u0437\\u043c\\u0435\\u0441\\u0442\\u0438\\u0442\\u044c\\n    SUMM = SUMM + col * curr[0] * curr[1]\\n    curr = tuple_heap.pop()\\n\\n#print(tuple_heap)\\n#print(used)\\n#print(max_x, max_y)\\n#print(col_max_x, col_max_y)\\n#print(\\\"SUMM =\\\", SUMM)\\n#print(\\\"Nr =\\\", Nr)\\nprint(SUMM/Nr)\", \"from heapq import *\\nn, m, r, k = map(int, input().split())\\nu, v = n // 2, m // 2\\nh = []\\ng = lambda z, l: min(z + 1, l - z, l - r + 1, r)\\ndef f(x, y):\\n    if 0 <= x < n and 0 <= y < m:\\n        s = g(x, n) * g(y, m)\\n        heappush(h, (-s, x, y))\\nf(u, v)\\nt = 0\\nfor i in range(k):\\n    s, x, y = heappop(h)\\n    t -= s\\n    if x <= u: f(x - 1, y)\\n    if x == u and y <= v: f(x, y - 1)\\n    if x >= u: f(x + 1, y)\\n    if x == u and y >= v: f(x, y + 1)\\nprint(t / (n - r + 1) / (m - r + 1))\", \"import queue\\nq = queue.PriorityQueue()\\nn, m, r, k = map(int, input().split())\\na = min(r, n - r + 1)\\nb = min(r, m - r + 1)\\nu = n - 2 * a + 2\\nv = m - 2 * b + 2\\nfor i in range(1, a + 1): q.put((-b * i, i))\\nt = 0\\nwhile k:\\n    s, i = q.get()\\n    q.put((s + i, i))\\n    d = min((u if i == a else 2) * (v if s == -b * i else 2), k)\\n    t -= s * d\\n    k -= d\\nprint(t / (n - r + 1) / (m - r + 1))\", \"# https://codeforces.com/problemset/problem/912/D\\nimport heapq\\nfrom heapq import heappush as push\\nfrom heapq import heappop  as pop\\n\\nbase = 100009\\nQ=[]\\nused={}\\nans=0\\n\\ndx = [0,0,-1,1]\\ndy = [-1,1,0,0]\\n\\ndef f(x, y):\\n    x1, x2 = min(x, r-1),   max(0, x-n+r)\\n    y1, y2 = min(y, r-1),   max(0, y-m+r)\\n    \\n    return -(x1-x2+1)*(y1-y2+1)\\n    \\ndef cal(i, j):\\n    return i*base+j\\n\\ndef get(ind):\\n    return ind//base, ind%base\\n\\ndef is_ok(x, y, x_, y_):\\n    if x+x_>=0 and x+x_<n and y+y_>=0 and y+y_<m:\\n        return True\\n    return False\\n   \\nn, m, r, k = map(int, input().split())    \\nx0, y0 = n//2, m//2 \\nQ=[(f(x0, y0), cal(x0, y0))]\\n\\nwhile k > 0:\\n    val, ind = pop(Q)\\n    \\n    if ind in used:\\n        continue\\n        \\n    x, y = get(ind)\\n    used[ind]=True\\n    val  = -val\\n    #print((x, y), val)\\n    ans += val\\n    for x_, y_ in zip(dx, dy):\\n        if is_ok(x, y, x_, y_):\\n            push(Q, (f(x+x_, y+y_), cal(x+x_, y+y_)))\\n    k-=1\\n    \\nprint(ans/((n-r+1)*(m-r+1)))    \"]", "task": "apps", "difficulty": "interview", "split": "test", "transformation_type": "plain_summary"}