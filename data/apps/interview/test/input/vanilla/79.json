{"qid": 79, "orig_input": "Vivek initially has an empty array $a$ and some integer constant $m$.\n\nHe performs the following algorithm:  Select a random integer $x$ uniformly in range from $1$ to $m$ and append it to the end of $a$.  Compute the greatest common divisor of integers in $a$.  In case it equals to $1$, break  Otherwise, return to step $1$. \n\nFind the expected length of $a$. It can be shown that it can be represented as $\\frac{P}{Q}$ where $P$ and $Q$ are coprime integers and $Q\\neq 0 \\pmod{10^9+7}$. Print the value of $P \\cdot Q^{-1} \\pmod{10^9+7}$.\n\n\n-----Input-----\n\nThe first and only line contains a single integer $m$ ($1 \\leq m \\leq 100000$).\n\n\n-----Output-----\n\nPrint a single integer\u00a0\u2014 the expected length of the array $a$ written as $P \\cdot Q^{-1} \\pmod{10^9+7}$.\n\n\n-----Examples-----\nInput\n1\n\nOutput\n1\n\nInput\n2\n\nOutput\n2\n\nInput\n4\n\nOutput\n333333338\n\n\n\n-----Note-----\n\nIn the first example, since Vivek can choose only integers from $1$ to $1$, he will have $a=[1]$ after the first append operation, and after that quit the algorithm. Hence the length of $a$ is always $1$, so its expected value is $1$ as well.\n\nIn the second example, Vivek each time will append either $1$ or $2$, so after finishing the algorithm he will end up having some number of $2$'s (possibly zero), and a single $1$ in the end. The expected length of the list is $1\\cdot \\frac{1}{2} + 2\\cdot \\frac{1}{2^2} + 3\\cdot \\frac{1}{2^3} + \\ldots = 2$.", "input": "Vivek initially has an empty array $a$ and some integer constant $m$.\n\nHe performs the following algorithm:  Select a random integer $x$ uniformly in range from $1$ to $m$ and append it to the end of $a$.  Compute the greatest common divisor of integers in $a$.  In case it equals to $1$, break  Otherwise, return to step $1$. \n\nFind the expected length of $a$. It can be shown that it can be represented as $\\frac{P}{Q}$ where $P$ and $Q$ are coprime integers and $Q\\neq 0 \\pmod{10^9+7}$. Print the value of $P \\cdot Q^{-1} \\pmod{10^9+7}$.\n\n\n-----Input-----\n\nThe first and only line contains a single integer $m$ ($1 \\leq m \\leq 100000$).\n\n\n-----Output-----\n\nPrint a single integer\u00a0\u2014 the expected length of the array $a$ written as $P \\cdot Q^{-1} \\pmod{10^9+7}$.\n\n\n-----Examples-----\nInput\n1\n\nOutput\n1\n\nInput\n2\n\nOutput\n2\n\nInput\n4\n\nOutput\n333333338\n\n\n\n-----Note-----\n\nIn the first example, since Vivek can choose only integers from $1$ to $1$, he will have $a=[1]$ after the first append operation, and after that quit the algorithm. Hence the length of $a$ is always $1$, so its expected value is $1$ as well.\n\nIn the second example, Vivek each time will append either $1$ or $2$, so after finishing the algorithm he will end up having some number of $2$'s (possibly zero), and a single $1$ in the end. The expected length of the list is $1\\cdot \\frac{1}{2} + 2\\cdot \\frac{1}{2^2} + 3\\cdot \\frac{1}{2^3} + \\ldots = 2$.", "test_cases": {"inputs": ["1\n", "2\n", "4\n", "3\n", "5\n", "6\n", "7\n", "8\n", "9\n", "10\n", "11\n", "12\n", "100000\n", "99991\n", "30030\n", "99594\n", "91402\n", "93493\n", "96917\n", "80555\n", "30238\n", "5447\n", "5714\n", "735\n", "64\n", "256\n", "2048\n", "32768\n", "65536\n", "23\n", "12167\n", "13\n", "14\n", "15\n", "16\n", "17\n", "18\n", "19\n", "20\n", "10609\n", "93179\n", "10859\n", "677\n", "919\n", "7635\n", "95835\n", "92138\n", "29019\n", "64444\n", "88373\n", "88439\n", "7710\n", "7404\n", "8616\n", "92386\n", "99622\n", "92171\n", "99360\n", "90661\n", "92213\n", "91068\n", "93378\n", "98179\n", "91286\n", "91568\n", "91086\n", "95539\n", "90740\n", "94998\n", "95042\n", "92239\n", "78088\n", "74792\n", "22028\n", "36884\n", "66917\n", "36312\n", "79162\n", "42626\n", "6752\n", "611\n", "2864\n", "9304\n", "1045\n", "9376\n", "8636\n", "75232\n", "48457\n", "60255\n", "54369\n", "46654\n", "83480\n", "22799\n", "68540\n", "47539\n", "64115\n", "41764\n", "99900\n", "99911\n", "99329\n", "99945\n", "99896\n", "99936\n", "82460\n", "74074\n", "55311\n", "15015\n", "77385\n", "86632\n"], "outputs": ["1\n", "2\n", "333333338\n", "2\n", "166666670\n", "500000006\n", "716666674\n", "476190482\n", "225000004\n", "567460324\n", "430555561\n", "318181823\n", "534174612\n", "434191575\n", "723188569\n", "166105505\n", "347601361\n", "606807336\n", "838672461\n", "409222861\n", "750441533\n", "741627218\n", "559826101\n", "607779919\n", "572467262\n", "927439938\n", "665668016\n", "645842651\n", "458595757\n", "485745620\n", "831671589\n", "468253974\n", "966666676\n", "553571435\n", "85780889\n", "519841276\n", "625000007\n", "984514841\n", "935537382\n", "503257127\n", "765292545\n", "380490066\n", "948537108\n", "434774514\n", "874467055\n", "834924464\n", "751784127\n", "963174399\n", "249303275\n", "857337836\n", "567687036\n", "33998115\n", "785109731\n", "340579911\n", "159998877\n", "109597446\n", "323804671\n", "557358009\n", "413855313\n", "876201665\n", "917827355\n", "820319423\n", "674222305\n", "843541605\n", "866047090\n", "685679455\n", "125860916\n", "178533194\n", "123894686\n", "460012534\n", "736315231\n", "185311544\n", "683829911\n", "797695183\n", "120075637\n", "760262294\n", "657550913\n", "283204023\n", "9522345\n", "689855972\n", "328389339\n", "225651508\n", "891558121\n", "883481609\n", "362881216\n", "768818941\n", "376862836\n", "559402589\n", "917128937\n", "200047474\n", "500907462\n", "124910318\n", "767471115\n", "291762913\n", "442384963\n", "570892404\n", "65880203\n", "313467660\n", "55921825\n", "635418994\n", "47143644\n", "423867335\n", "129595366\n", "79287597\n", "472079813\n", "341088608\n", "618014296\n", "724140171\n", "626563584\n"]}, "solutions": "[\"big = 100010\\ndef gen_mu():\\n    mu = [1]*big\\n    mu[0] = 0\\n    P = [True]*big\\n    P[0] = P[1] = False\\n    for i in range(2,big):\\n        if P[i]:\\n            j = i\\n            while j<big:\\n                P[j] = False\\n                mu[j] *= -1\\n                j += i\\n            j = i*i\\n            while j<big:\\n                mu[j] = 0\\n                j += i*i\\n    return mu\\n\\nm = int(input())\\nmu = gen_mu()\\n\\nMOD = 10**9+7\\ndef mod_inv(x):\\n    return pow(x, MOD-2, MOD)\\n\\ns = 1\\nfor i in range(2,big):\\n    # p is probabilty that i | a random number [1,m]\\n    p = (m//i)*mod_inv(m)\\n    s += (-mu[i])*(p)*mod_inv(1-p)\\nprint(s%MOD)\", \"# https://codeforces.com/blog/entry/66101?#comment-501153\\nMOD = 10 ** 9 + 7\\nm = int(input())\\nf = [0] * (m + 1)\\nans = 1\\nfor i in range(m, 1, -1):\\n    p = m // i * pow(m, MOD - 2, MOD)\\n    f[i] = p * pow(1 - p, MOD - 2, MOD) % MOD\\n    for j in range(2 * i, m + 1, i):\\n        f[i] = (f[i] - f[j]) % MOD\\n    ans += f[i]\\nprint(ans % MOD)\", \"q = 100010\\n\\n\\ndef rop():\\n    a = [1] * q\\n    a[0] = 0\\n    s = [True] * q\\n    s[0] = s[1] = False\\n    for i in range(2, q):\\n        if s[i]:\\n            o = i\\n            while o < q:\\n                s[o] = False\\n                a[o] *= -1\\n                o += i\\n            o = i ** 2\\n            while o < q:\\n                a[o] = 0\\n                o +=  i ** 2\\n    return a\\n\\nd = int(input())\\na = rop()\\n\\n\\ndef pro(x):\\n    return pow(x, 10 ** 9 + 5, 10 ** 9 + 7)\\n\\nf = 1\\nfor i in range(2, q):\\n    z = (d // i) * pro(d)\\n    f += (-a[i]) * z * pro(1 - z)\\nprint(f % (10 ** 9 + 7))\", \"'''\\nhttps://codeforces.com/contest/1139/problem/D\\nhttps://codeforces.com/blog/entry/66101?#comment-500999\\nhttps://brilliant.org/wiki/linearity-of-expectation/\\nhttps://en.wikipedia.org/wiki/Negative_binomial_distribution\\nSuppose there is a sequence of independent Bernoulli trials. Thus, each trial has two potential outcomes called \\\"success\\\" and \\\"failure\\\". In each trial the probability of success is p and of failure is (1 \\u2212 p). We are observing this sequence until a predefined number r of failures has occurred. Then the random number of successes we have seen, X, will have the negative binomial (or Pascal) distribution:\\n\\n{\\\\displaystyle X\\\\sim \\\\operatorname {NB} (r,p)} {\\\\displaystyle X\\\\sim \\\\operatorname {NB} (r,p)}\\n1. mobius function: \\n2. Negative binomial distribution\\n'''\\n\\nN = 100010\\n\\ndef gen_mobius_function():\\n    mu = [1] * N\\n    mu[0] = 0\\n    P = [True] * N\\n    P[0] = P[1] = False\\n    for i in range(2, N):\\n        if P[i]:\\n            j = i\\n            while j < N:\\n                P[j] = False\\n                mu[j] *= -1\\n                j += i\\n            j = i * i\\n            while j < N:\\n                mu[j] = 0\\n                j += i * i\\n    return mu\\n\\nm = int(input())\\nmu = gen_mobius_function()\\n\\nMOD = 10**9 + 7\\n\\ndef mod_inv(x):\\n    return pow(x, MOD - 2, MOD)\\n\\nE = 1\\nfor i in range(2, N):\\n    p = m // i * mod_inv(m)\\n    E += -mu[i] * p * mod_inv(1 - p) #mobius, Negative binomial function\\nprint(E % MOD)\\n\", \"from math import floor\\nfrom functools import reduce\\nMOD = floor(1e9+7)\\nexpected_len = [0, 1]\\n\\nn = int(input())\\n\\nfactors = [[] for i in range(n+1)]\\nprime_factors = [[] for i in range(n+1)]\\n\\ndef ext_euclid(a, b):\\n    if b == 0:\\n        return 1, 0, a\\n    x, y, q = ext_euclid(b, a % b)\\n    x, y = y, (x - (a//b) * y)\\n    return x, y, q\\n\\n\\ndef inverse(num):\\n    return ext_euclid(MOD, num)[1] % MOD\\n\\n\\ninv = [0] * (n+1)\\nfor i in range(n+1):\\n    inv[i] = inverse(i)\\n\\nfor i in range(1, n+1):\\n    prime_fact = False\\n    if len(prime_factors[i]) < 2:\\n        prime_factors[i].append(i)\\n        prime_fact = True\\n    \\n    factors[i].append(i)\\n    for j in range(2*i, n+ 1, i):\\n        factors[j].append(i)\\n        if prime_fact:\\n            prime_factors[j].append(i)\\n\\n# Calculate the number i = x * y\\n# Such that j in [1, n // x]  gcd(j, y) == 1\\n\\ndef f(x, y):\\n    remain = 0\\n    new_n = n // x\\n\\n    new_y = reduce(lambda x, y: x*y, prime_factors[y])\\n    for fact in factors[new_y]:\\n        if fact != 1:\\n            if len(prime_factors[fact]) & 1:\\n                remain -= new_n // fact\\n            else:\\n                remain += new_n // fact\\n    return new_n - remain\\n\\n\\nfor i in range(2, n+1):\\n    # i = y * b\\n    e_len = 0\\n    for ele in factors[i]:\\n        if ele != i:\\n            e_len += (f(ele, i // ele) * expected_len[ele] * inv[n]) % MOD\\n    e_len = ((e_len + 1)* n *  inv[n-f(i, 1)]) % MOD\\n    expected_len.append(e_len)\\n\\nprint((sum(expected_len) * inv[n]) % MOD)\\n\", \"\\\"\\\"\\\"\\n    Author : thekushalghosh\\n    Team   : CodeDiggers\\n\\\"\\\"\\\"\\nimport sys,math\\ninput = sys.stdin.readline\\n \\n############ ---- USER DEFINED INPUT FUNCTIONS ---- ############\\ndef inp():\\n    return(int(input()))\\ndef inlt():\\n    return(list(map(int,input().split())))\\ndef insr():\\n    s = input()\\n    return(s[:len(s) - 1])\\ndef invr():\\n    return(map(int,input().split()))\\n################################################################\\n############ ---- THE ACTUAL CODE STARTS BELOW ---- ############\\nt = 1\\nfor tt in range(t):\\n    m = int(input())\\n    q = [0] * (m + 1)\\n    c = 1\\n    for i in range(m, 1, -1):\\n        w = m // i * pow(m, 1000000007 - 2, 1000000007)\\n        q[i] = w * pow(1 - w, 1000000007 - 2, 1000000007) % 1000000007\\n        for j in range(2 * i, m + 1, i):\\n            q[i] = (q[i] - q[j]) % 1000000007\\n        c = c + q[i]\\n    print(c % 1000000007)\", \"from sys import *\\nm = int(input())\\nq = [0] * (m + 1)\\nc = 1\\nfor i in range(m, 1, -1):\\n    w = m // i * pow(m, 1000000007 - 2, 1000000007)\\n    q[i] = w * pow(1 - w, 1000000007 - 2, 1000000007) % 1000000007\\n    for j in range(2 * i, m + 1, i):\\n        q[i] = (q[i] - q[j]) % 1000000007\\n    c = c + q[i]\\nprint(c % 1000000007)\"]", "task": "apps", "difficulty": "interview", "split": "test", "transformation_type": "vanilla"}